---
--- Generated by lvyuqiang
--- File name : story.lua.txt
--- DateTime : 2022/06/09
--- Description : 剧情对象，目前有主线、战斗和学院三种模式
---

local t = tables
local game_data_manager = game_data_manager
local data = data
local log = log
local string = string
local net = network
local scene = scene
local pt = enum.proto
local window = window
local window_type = df.enum.window_type
local msg_names = message_names
local game_network = game_network
local scene_manager = game_scene_manager
local battle = system_manager.battle
local msg = message
local tostring = tostring
local array = array_table
local msg_types = enum.message_type
local cutscene_class = require 'framework/cutscene/cutscene'
local avg_class = require 'game/systems/story/model/avg'
local story_const = require 'game/systems/story/story_const'
local story_mode = require 'game/systems/story/model/story_mode'
local module_type = require 'game/systems/story/model/story_module_type'
local load_type = require 'game/windows/loading/model/loading_type'
local game_util = require "game/utils/game_util"

---@class story
local story = class("story")

---构造函数
---@private
function story:ctor(mode)
    self.mode = mode
    ---当前章节
    self.current_chapter = nil
    ---当前模块
    ---@type Module
    self.current_module = nil
    ---当前cutscene
    ---@type cutscene
    self.current_cutscene = nil
    ---当前AVG
    ---@type avg
    self.current_avg = nil

    self.on_cutscene_complete_func = function()
        self:on_cutscene_complete()
    end

    self.on_avg_complete_func = function()
        self:on_avg_complete()
    end

    if self.mode == story_mode.main_story then
        self.module_table_name = t.Module.name
        net.add_message_listener(pt.EGameMsgID.ACK_UPDATE_MODULE, msg_names.AckUpdateModule, self.on_ack_update_main_story_module, self)
    elseif self.mode == story_mode.branch_story then
        self.module_table_name = t.ModuleBranch.name
        net.add_message_listener(pt.EGameMsgID.ACK_STORY_BRANCH_UPDATE_MODULE, msg_names.AckStoryBranchUpdateModule, self.on_ack_update_branch_story_module, self)
    elseif self.mode == story_mode.explorer_story then
        self.module_table_name = t.ModuleExplore.name
    else
        self.module_table_name = t.ModuleSide.name
    end
end

--region 基础

---初始化功能剧情数据
---@public
---@param chapter_id string 章节Id，仅支线剧情传参
---@param module_ids table 模块Id集合，仅功能剧情传参
---@param story_window_id string 窗口id，仅功能剧情传参
---@param data_source_type number 模块数据来源 仅魔女轶事剧情传参(0/空 为默认；1 为 ModuleCharacter)
function story:init(chapter_id, module_ids, story_window_id, data_source_type)
    self.next_story_window_id = story_window_id
    story_const.init()
    if self.mode == story_mode.branch_story then
        self.chapter_id = chapter_id
    else
        self.module_ids = module_ids
        self.current_module_index = 0
        local current_module_type = data_source_type or 0
        if current_module_type == 1 then
            -- 魔女轶事
            self.module_table_name = t.ModuleCharacter.name
            self.mode = story_mode.anecdote_story
        end
    end
    self:refresh_chapter_module_info()
end

---开始剧情
---@public
---@param keep_windows_while_first_switch_scene boolean 剧情中第一次切场景时，是否保留当前场景中的窗体状态
---@param end_callback function 剧情结束回调
---@param preload_callback function 剧情预加载完成回调
---@param scene_param any 场景参数
function story:start(keep_windows_while_first_switch_scene, end_callback, preload_callback, scene_param)
    self.end_callback = end_callback
    self.preload_callback = preload_callback
    ---@public
    ---@type boolean
    self.is_running = true
    self.keep_windows_while_first_switch_scene = keep_windows_while_first_switch_scene
    if not self:try_swap_battle_ready_scene(scene_param) then
        if not self:swap_scene_for_current_module(scene_param) then
            if self.mode == story_mode.main_story then
                log.error("can't start main story without swap scene")
            else
                window.open(self.next_story_window_id or t.Window.ids.Story, { start_after_window = true })
            end
        end
    end
end

---为主线剧情跳转到战备场景
---@private
function story:try_swap_battle_ready_scene(scene_param)
    if scene_param and scene_param.loading_type == load_type.StartChapter then
        if self.current_module.Type == module_type.battle and not string.is_nil_or_empty(self.current_module.Battle) then
            local battle_id = self.current_module.Battle
            local battle_set_data = data.get(t.BTLBattle.name, battle_id, t.BTLBattle.properties.BattleSetData)
            if not game_util.is_bit_flag(battle_set_data, 3) then
                local battle_ready_scene_id = data.get(t.ConstClient.name, t.ConstClient.ids.KW_STORY_BATTLE_READY_EMPTY_SCENE, t.ConstClient.properties.String)
                scene_param.battle_id = battle_id
                scene_param.chapter = self.current_module.Chapter
                scene_param.module_id = self.current_module.Id
                scene_param.module_table_name = self.module_table_name
                scene_manager.switch_scene(battle_ready_scene_id, 0, scene_param)
                return true
            end
        end
    end
    return false
end

---@public
function story:dispose()
    if self.mode == story_mode.main_story then
        net.remove_message_listener(pt.EGameMsgID.ACK_UPDATE_MODULE, msg_names.AckUpdateModule, self.on_ack_update_main_story_module, self)
    elseif self.mode == story_mode.branch_story then
        net.remove_message_listener(pt.EGameMsgID.ACK_STORY_BRANCH_UPDATE_MODULE, msg_names.AckStoryBranchUpdateModule, self.on_ack_update_branch_story_module, self)
    end
    self.current_chapter = nil
    self.current_module = nil
    self.current_cutscene = nil
    self.current_avg = nil
    self.chapter_id = nil
    self.module_ids = nil
end

---刷新章节模块信息
---public
function story:refresh_chapter_module_info()
    self.is_module_preload = false
    if self.mode == story_mode.main_story then
        local current_module_id = game_data_manager.player.player_net_obj:get_property_string(t.Player.properties.ModuleId)
        if current_module_id and current_module_id ~= '' then
            self.current_module = data.get(self.module_table_name, current_module_id)
            self.chapter_id = self.current_module.Chapter
            self.current_chapter = data.get(t.Chapter.name, self.chapter_id)
            log.info("refresh_chapter_module_info(main_story): ", self.current_module.Id)
        else
            log.error("player's ModuleId property is nil")
        end
    elseif self.mode == story_mode.branch_story then
        local chapter_row = self:get_branch_story_chapter_record_row()
        self.current_module = data.get(self.module_table_name, chapter_row:get_value(t.Player.records.StoryBranch.columns.ModuleID))
        self.current_chapter = data.get(t.ChapterBranch.name, self.chapter_id)
        log.info("refresh_chapter_module_info(branch_story): ", self.current_module.Id)
    else
        self.current_module_index = self.current_module_index + 1
        if self.current_module_index <= #self.module_ids then
            self.current_module = data.get(self.module_table_name, self.module_ids[self.current_module_index])
            log.info("refresh_chapter_module_info(explore_story or func_story): ", self.current_module.Id)
        end
    end
end

---获取支线剧情章节record行数据
---@private
---@return record_row
function story:get_branch_story_chapter_record_row()
    local branch_story_record = game_data_manager.player.player_net_obj:get_record(t.Player.records.StoryBranch.name)
    local rows = branch_story_record:get_rows()
    for _, row in pairs(rows) do
        local chapter_id = row:get_value(t.Player.records.StoryBranch.columns.ChapterID)
        if self.chapter_id == chapter_id then
            return row
        end
    end
    log.error("get_branch_story_record_row is nil: ", self.chapter_id)
end

---获取当前章节（仅限非功能剧情）
---@public
---@return Chapter
function story:get_current_chapter()
    if self.mode == story_mode.main_story then
        local chapter_status = game_data_manager.player.player_net_obj:get_property_string(t.Player.properties.ChapterStatus)
        self.current_chapter.status = chapter_status
        self.current_chapter.is_active = chapter_status ~= 0
    end
    return self.current_chapter
end

---获取当前模块
---@public
function story:get_current_module()
    return self.current_module
end

---确认主线剧情章节奖励
---@public
function story:confirm_main_story_chapter_reward()
    net.send_message_async(pt.EGameMsgID.REQ_CHAPTER_TIP_OK, msg_names.ReqChapterRewardTipOk, { player_id = game_data_manager.player.player_net_obj.id })
end

---确认支线剧情章节奖励
---@public
function story:confirm_branch_story_chapter_reward(chapter_id)
    net.send_message_async(pt.EGameMsgID.REQ_STORY_BRANCH_CHAPTER_TIP_OK, msg_names.ReqStoryBranchChapterRewardTipOk, { player_id = game_data_manager.player.player_net_obj.id, chapter_id = chapter_id })
end

---切换至当前模块场景
---@public
function story:swap_scene_for_current_module(scene_param)
    ---如果是战斗类型，直接请求进入战斗    
    if self.current_module.Type == module_type.battle and not string.is_nil_or_empty(self.current_module.Battle) then
        local battle_id = self.current_module.Battle
        local battle_ready_util = require 'game/windows/battle/battle_ready/battle_ready_util'
        battle_ready_util.show_battle_ready_or_enter({ battle_id = battle_id, chapter = self.current_module.Chapter, module_id = self.current_module.Id, cb = function(team_id, player_id, witch_id, idx)
            game_network.req_enter_battle(self.current_module.Id, team_id, nil, nil, nil, nil, nil, nil, player_id, witch_id, idx, scene_param)
        end, exist_cb = function()
            self:stop_by_interrupt()
        end })
        return true
    end

    ---非战斗类型，判断是否需要切换场景
    if self.current_module.Scene > 0 and scene.current().id ~= tostring(self.current_module.Scene) then
        if scene_param == nil then
            scene_param = {}
        end
        scene_param.story_window_id = self.next_story_window_id or t.Window.ids.Story
        scene_manager.switch_scene(tostring(self.current_module.Scene), self.keep_windows_while_first_switch_scene and 1 or 0, scene_param)
        self.keep_windows_while_first_switch_scene = false
        if self.mode == story_mode.func_story then
            ---标识功能剧情跳转了场景
            self.switch_scene_for_func_story = true
        end
        return true
    end
end

---开始当前模块
---@public
function story:start_current_module()
    log.info('start_current_module:', self.current_module.Id)
    if self.current_module.Type == module_type.cutscene then
        self:start_cutscene()
    elseif self.current_module.Type == module_type.avg then
        self:start_avg()
    end
end

---切换到下一章节
---@private
function story:switch_next_chapter()
    local current_module_id = game_data_manager.player.player_net_obj:get_property_string(t.Player.properties.ModuleId)
    local current_chapter_id = data.get(self.module_table_name, current_module_id, t.Module.properties.Chapter)
    log.info('switch_next_chapter:', current_chapter_id)
    self.current_chapter = data.get(t.Chapter.name, current_chapter_id)
    self:switch_next_module(current_module_id, false)
end

---切换到下一个模块
---@private
function story:switch_next_module(module_id, skip)
    self.is_module_preload = false
    if self.mode == story_mode.main_story or self.mode == story_mode.branch_story then
        self.current_module = data.get(self.module_table_name, module_id)
        log.info("switch_next_module(main_story or branch_story): ", self.current_module.Id)
    else
        ---功能剧情
        local finish = false
        if skip then
            local next_module_id = self.current_module.SkipToModule
            if string.is_nil_or_empty(next_module_id) then
                ---结束功能剧情
                finish = true
            else
                local next_module_index = array.index_of(self.module_ids, next_module_id)
                if next_module_index > 0 and next_module_index <= #self.module_ids then
                    self.current_module_index = next_module_index
                    self.current_module = data.get(self.module_table_name, next_module_id)
                    log.info("switch_next_module skip to: ", next_module_id)
                else
                    log.error("switch_next_module, SkipToModule error: ", next_module_id)
                end
            end
        else
            self.current_module_index = self.current_module_index + 1
            if self.current_module_index <= #self.module_ids then
                local current_module_id = self.module_ids[self.current_module_index]
                self.current_module = data.get(self.module_table_name, current_module_id)
                log.info("switch_next_module(func_story): ", self.current_module.Id)
            else
                finish = true
            end
        end
        if finish then
            self.is_running = false
            ---战斗中正在执行战斗结束前的触发器时
            ---保留StoryWindow，通过卸载场景自动销毁StoryWindow
            if self.switch_scene_for_func_story then
                scene_manager.set_finish_callback(function()
                    scene_manager.set_finish_callback(nil)
                    if self.end_callback then
                        self.end_callback(skip)
                    end
                end)
                scene_manager.go_back(nil, { loading_type = self.current_module.LoadingType })
            else
                if not battle:is_in_battle() or not battle:get_data():get_is_execute_trigger() then
                    --window.close_by_id(next_story_window_id or t.Window.ids.Story, true)
                    local story_win_id = self.next_story_window_id or t.Window.ids.Story
                    local story_win = window.get_window(story_win_id)
                    if story_win.window_type == window_type.nav_window then
                        --防止UI穿透
                        timer_manager.add_timer(0.1, function()
                            window.go_back()
                        end)
                    elseif story_win.window_type == window_type.free_window then
                        --防止UI穿透
                        timer_manager.add_timer(0.1, function()
                            window.close_by_id(story_win_id, true)
                        end)
                    else
                        log.error("story window type error")
                    end
                end
                if self.end_callback then
                    self.end_callback(skip)
                end
            end
            self.switch_scene_for_func_story = nil
            self.next_story_window_id = nil
            return
        end
    end
    log.info('switch_next_module:', self.current_module.Id)

    if not self:swap_scene_for_current_module() then
        msg.broadcast(msg_types.STORY_MODULE_READY)
    end
end

---预加载模块资源
---@public
function story:preload_current_module_sync()
    if self.is_module_preload then
        return
    end
    if self.current_module.Type == module_type.cutscene then
        self.current_cutscene = cutscene_class.new(self.current_module.Animate)
        self.current_cutscene:preload_sync()
    elseif self.current_module.Type == module_type.avg then
        self.current_avg = avg_class.new(self.current_module.StartAvg, self.current_module.Camera, self.mode)
        self.current_avg:preload_sync()
    end
    self.is_module_preload = true
    if self.preload_callback then
        self.preload_callback()
    end
end

---主线剧情模块结束响应
---@private
---@param ack_info AckUpdateModule
function story:on_ack_update_main_story_module(ack_info)
    if ack_info.event_code == pt.EGameEventCode.SUCCESS then
        local ack_module_id = ack_info.module_id
        local ack_chapter_status = ack_info.chapter_status
        log.info('on_ack_update_main_story_module, ack_chapter_status: ', ack_chapter_status, ', ack_module_id: ', ack_module_id)
        if ack_chapter_status == 1 then
            ---当前章节已激活，但未完成。切换到新模块
            self:switch_next_module(ack_module_id, false)
        elseif ack_chapter_status == 2 then
            ---当前章节已完成，但未确认奖励。返回居所确认奖励
            self.is_running = false
            system_manager.story:go_home({ loading_type = self.current_module.LoadingType == 0 and load_type.FinishChapter or self.current_module.LoadingType })
        else
            log.error("on_ack_update_main_story_module error, ack_chapter_status: ", ack_chapter_status)
        end
    else
        log.error("on_ack_update_main_story_module error:", ack_info.event_code)
    end
end

---支线剧情模块结束响应a
---@private
---@param ack_info AckStoryBranchUpdateModule
function story:on_ack_update_branch_story_module(ack_info)
    if ack_info.event_code == pt.EGameEventCode.SUCCESS then
        local ack_module_id = ack_info.module_id
        local ack_chapter_status = ack_info.chapter_status
        log.info('on_ack_update_branch_story_module, ack_chapter_status: ', ack_chapter_status, ', ack_module_id: ', ack_module_id)
        if ack_chapter_status == 1 then
            ---当前章节未完成。切换到新模块
            self:switch_next_module(ack_module_id, false)
        elseif ack_chapter_status == 2 or ack_chapter_status == 3 then
            ---支线剧情章节已完成，但未确认奖励。返回居所确认奖励。
            ---支线剧情章节已完成。返回居所。
            self.is_running = false
            system_manager.story:go_home({ loading_type = self.current_module.LoadingType })
        else
            log.error("on_ack_update_branch_story_module error, ack_chapter_status: ", ack_chapter_status)
        end
    else
        log.error("on_ack_update_branch_story_module error:", ack_info.event_code)
    end
end

---通知服务端Module结束(主线剧情)
---@param skip boolean 是否通过跳过按钮结束当前模块
---@public
function story:req_update_main_story_module(skip)
    log.info('req_update_main_story_module')
    net.send_message_async(pt.EGameMsgID.REQ_UPDATE_MODULE, msg_names.ReqUpdateModule, { player_id = game_data_manager.player.player_net_obj.id, skip = skip == true and 1 or 0 })
end

---通知服务端Module结束(支线剧情)
---@param skip boolean 是否通过跳过按钮结束当前模块
---@public
function story:req_update_branch_story_module(skip)
    log.info('req_update_branch_story_module')
    net.send_message_async(pt.EGameMsgID.REQ_STORY_BRANCH_UPDATE_MODULE, msg_names.ReqStoryBranchUpdateModule, { player_id = game_data_manager.player.player_net_obj.id, chapter_id = self.chapter_id, skip = skip == true and 1 or 0 })
end

---检查模块是否结束
---@param skip boolean 是否通过跳过按钮结束当前模块
---@public
function story:check_module_complete(skip)
    if self.mode == story_mode.main_story then
        self:req_update_main_story_module(skip)
    elseif self.mode == story_mode.branch_story then
        self:req_update_branch_story_module(skip)
    else
        self:switch_next_module(nil, skip)
    end
end

---战斗退出或失败导致中断剧情
---@public
function story:stop_by_interrupt()
    self.is_running = false
end

---模块开始时淡入遮罩是否可用
---@public
function story:is_begin_module_fade_in_mask_enable()
    if self:is_last_module_of_chapter() then
        return false
    end
    if self.current_module.Type == module_type.avg then
        local current_clip = self.current_avg.current_clip
        return current_clip == nil and self.current_module.BlackIn == 1
    else
        return self.current_module.BlackIn == 1
    end
end

---Loading遮罩是否可用
---@public
function story:is_loading_mask_enable(skip)
    if self:is_last_module_of_chapter() then
        return false
    elseif skip and self:is_main_branch_chapter_end_after_skip() then
        return false
    end

    if self.current_module then
        return self.current_module.BlackIn == 1 or self.current_module.BlackOut == 1
    else
        log.error("current module is nil")
    end
end

---AVG模块结束时淡出遮罩是否可用
---@public
function story:is_end_avg_module_fadeout_mask_enable(skip)
    if self:is_last_module_of_chapter() then
        return false
    elseif skip and self:is_main_branch_chapter_end_after_skip() then
        return false
    end

    if self.current_module and self.current_module.Type == module_type.avg then
        local next_clip = self.current_avg:get_next_clip()
        return next_clip == nil and self.current_module.BlackOut == 1
    else
        log.error("is_end_avg_module_fadeout_mask_enable error")
    end
end

---两个AVG幕衔接时，淡入淡出遮罩是否可用
---@public
function story:is_avg_clip_fadein_out_mask_enable()
    --if self:is_last_module_of_chapter() or self:is_end_avg_module_fadeout_mask_enable() then
    --    return false
    --end
    if self.current_module and self.current_module.Type == module_type.avg then
        return self.current_avg:is_clip_fade_in_out_enable()
    else
        log.error("is_avg_clip_fadein_out_mask_enable error")
    end
    return false
end

---是否打开褪色滤镜
---@public
function story:is_enable_fade_filter(is_current)
    if self.current_module and self.current_module.Type == module_type.avg then
        local clip = is_current == true and self.current_avg.current_clip or self.current_avg:get_next_clip()
        return clip and array.contains(clip.MemoryFilter, 2)
    end
    return false
end

---是否打开灵能滤镜
---@public
function story:is_enable_magic_filter(is_current)
    if self.current_module and self.current_module.Type == module_type.avg then
        local clip = is_current == true and self.current_avg.current_clip or self.current_avg:get_next_clip()
        return clip and array.contains(clip.MemoryFilter, 3)
    end
    return false
end

---是否关闭褪色滤镜
---@public
function story:is_disable_fade_filter()
    if self.current_module and self.current_module.Type == module_type.avg then
        local current_clip = self.current_avg.current_clip
        ---AVG当前幕移除褪色滤镜
        return current_clip and array.contains(current_clip.MemoryFilterEnd, 2)
    end
    return false
end

---是否关闭灵能滤镜
---@public
function story:is_disable_magic_filter()
    if self.current_module and self.current_module.Type == module_type.avg then
        local current_clip = self.current_avg.current_clip
        ---AVG当前幕移除褪色滤镜
        return current_clip and array.contains(current_clip.MemoryFilterEnd, 3)
    end
    return false
end

---是否是主支线剧情的最后一个模块
---@public
function story:is_last_module_of_chapter()
    if self.mode == story_mode.main_story then
        return self:is_main_branch_story_chapter_end()
    elseif self.mode == story_mode.branch_story then
        local next_module_id = self.current_module.NextModule
        if string.is_nil_or_empty(next_module_id) then
            return true
        end
    end
    return false
end

---主支线点击跳过后是否结束当前章节
---@public
function story:is_main_branch_chapter_end_after_skip()
    if self.mode == story_mode.main_story or self.mode == story_mode.branch_story then
        return string.is_nil_or_empty(self.current_module.SkipToModule)
    end
    return false
end

---主支线剧情当前章节是否结束
---@public
function story:is_main_branch_story_chapter_end()
    if self.mode == story_mode.main_story or self.mode == story_mode.branch_story then
        local next_module_id = self.current_module.NextModule
        if string.is_nil_or_empty(next_module_id) then
            return true
        else
            local current_module_chapter_id = self.current_module.Chapter
            local next_module_chapter_id = data.get(self.module_table_name, next_module_id, t.Module.properties.Chapter)
            if current_module_chapter_id ~= next_module_chapter_id then
                return true
            end
        end
    end
    return false
end

--endregion

--region 动画

---开始剧情动画
---@private
function story:start_cutscene()
    self.current_cutscene:play(nil, self.on_cutscene_complete_func, false)
    msg.broadcast(msg_types.STORY_START_CUTSCENE, self.current_cutscene)
end

---剧情动画结束回调
---@private
function story:on_cutscene_complete()
    msg.broadcast(msg_types.STORY_END_CUTSCENE)
    --self:check_module_complete()
end

---销毁cutscene
---@public
function story:dispose_cutscene()
    self.current_cutscene:dispose()
    self.current_cutscene = nil
end

---cutscene结束后，是否要切换场景
---@public
function story:is_switch_scene_after_cutscene()
    if self.mode == story_mode.func_story and self.current_module_index >= #self.module_ids - 1 then
        return true
    end
    return false
end

--endregion

--region AVG

---开始AVG
---@private
function story:start_avg()
    log.info('avg start')
    msg.broadcast(msg_types.STORY_START_AVG, self.current_avg)
    self.current_avg:play(self.on_avg_complete_func)
end

---暂停AVG
---@public
function story:pause_avg()
    log.info('pause_avg')
    self.current_avg:pause()
end

---恢复AVG播放
---@public
function story:resume_avg()
    log.info('resume_avg')
    self.current_avg:resume()
end

---avg是否结束
---@public
function story:is_avg_end(is_skip)
    return is_skip == true or self.current_avg:get_next_clip() == nil
end

---AVG结束回调
---@private
function story:on_avg_complete()
    log.info('avg complete')
    msg.broadcast(msg_types.STORY_END_AVG)

    ---需要等待avg淡出，再销毁avg。交由窗体逻辑控制
    --self.current_avg:dispose()
    --self.current_avg = nil
end

---需要等待avg淡出，再销毁avg。交由窗体逻辑控制。
---@public
function story:dispose_avg()
    if self.current_avg then
        self.current_avg:dispose()
        self.current_avg = nil
    end
end

--endregion

return story