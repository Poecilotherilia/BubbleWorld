---
--- Generated by lvyuqiang
--- File name : story_system.lua.txt
--- DateTime : 2022/06/09
--- Description : 剧情管理器
---
local story_class = require 'game/systems/story/model/story'
local mode = require 'game/systems/story/model/story_mode'
local chapter_item_class = require 'game/systems/story/model/story_chapter_item'
local reward_data = require 'game/windows/item/data/reward_data'
local reward_item = require "game/windows/common/reward/reward_item"
local load_type = require 'game/windows/loading/model/loading_type'
local record_event_type = require "framework/network/model/record_event_type"
local localization = localization
local string_keys = string_keys
local to_number = tonumber
local table_mul_sort = table.mul_sort
local game_data_manager = game_data_manager
local game_scene_manager = game_scene_manager
local string_format = string.format
local string_is_nil_or_empty = string.is_nil_or_empty
local message_names = message_names
local enum_proto = enum.proto
local EGameEventCode = enum_proto.EGameEventCode
local EGameMsgID = enum_proto.EGameMsgID
local network = network
local array = array_table
local t = tables
local data = data
local log = log
local message = message
local msg_type = enum.message_type
local window = window
local window_status = df.enum.window_status
local setting = setting
local scene = scene

---@class story_system
local story_system = class("story_system")

function story_system:ctor()
    ---主线剧情
    ---@public
    self.main_story = story_class.new(mode.main_story)
    ---支线剧情
    ---@public
    self.branch_story = story_class.new(mode.branch_story)
    ---功能剧情
    ---@public
    self.func_story = story_class.new(mode.func_story)
    ---探索剧情
    ---@public
    self.explorer_story = story_class.new(mode.explorer_story)

    -- 监听战斗退出消息
    message.add_listener(enum.message_type.BATTLE_CUSTOM_EXIT_BATTLE_FLOW, self.on_battle_custom_exit_flow_handle, self)
end

function story_system:start()
    self.red_point_prefix = "RED_POINT_" .. game_data_manager.player:get_string_account()
    self:init_main_story()
    self:refresh_story_red_point()
    game_data_manager.player.player_net_obj:add_record_listener(t.Player.records.StoryBranch.name, self.on_branch_story_record_changed, self)
end

--region 红点

---隐藏剧情红点
---@public
function story_system:hide_story_red_point()
    ---主线
    local main_chapter_status = game_data_manager.player.player_net_obj:get_property_number(t.Player.properties.ChapterStatus)
    if main_chapter_status == 1 then
        local main_module_id = game_data_manager.player.player_net_obj:get_property_string(t.Player.properties.ModuleId)
        if not string_is_nil_or_empty(main_module_id) then
            local main_chapter_id = data.get(t.Module.name, main_module_id, t.Module.properties.Chapter)
            setting.set_int(main_chapter_id, 1, self.red_point_prefix)
        else
            log.error("player's ModuleId property is nil")
        end
    end

    ---支线
    local branch_story_record = game_data_manager.player.player_net_obj:get_record(t.Player.records.StoryBranch.name)
    local rows = branch_story_record:get_rows()
    for _, row in pairs(rows) do
        local branch_chapter_status = row:get_value(t.Player.records.StoryBranch.columns.ChapterStatus)
        if branch_chapter_status == 1 then
            local branch_chapter_id = row:get_value(t.Player.records.StoryBranch.columns.ChapterID)
            setting.set_int(branch_chapter_id, 1, self.red_point_prefix)
        end
    end
    message.broadcast(msg_type.SET_RED_POINT, t.RedPoint.ids.RedPoint_Task_Stroy_Enter, false)
end

---刷新剧情红点状态
---@private
function story_system:refresh_story_red_point()
    local red = self:get_story_red_point()
    message.broadcast(msg_type.SET_RED_POINT, t.RedPoint.ids.RedPoint_Task_Stroy_Enter, red)
end

---获取剧情红点状态
---@private
function story_system:get_story_red_point()
    ---setting中记录了所有已开启且进入过的章节
    local red = false

    ---主线
    local main_chapter_status = game_data_manager.player.player_net_obj:get_property_number(t.Player.properties.ChapterStatus)
    if main_chapter_status == 1 then
        local main_module_id = game_data_manager.player.player_net_obj:get_property_string(t.Player.properties.ModuleId)
        if not string_is_nil_or_empty(main_module_id) then
            local main_chapter_id = data.get(t.Module.name, main_module_id, t.Module.properties.Chapter)
            if not setting.has_key(main_chapter_id, self.red_point_prefix) then
                red = true
            end
        else
            log.error("player's ModuleId property is nil")
        end
    end

    ---支线
    if not red then
        local branch_story_record = game_data_manager.player.player_net_obj:get_record(t.Player.records.StoryBranch.name)
        local rows = branch_story_record:get_rows()
        for _, row in pairs(rows) do
            local branch_chapter_status = row:get_value(t.Player.records.StoryBranch.columns.ChapterStatus)
            if branch_chapter_status == 1 then
                local branch_chapter_id = row:get_value(t.Player.records.StoryBranch.columns.ChapterID)
                if not setting.has_key(branch_chapter_id, self.red_point_prefix) then
                    red = true
                    break
                end
            end
        end
    end

    return red
end

---设置章节访问状态为已访问
---@private
function story_system:set_chapter_visited(chapter_id)
    if not setting.has_key(chapter_id, self.red_point_prefix) then
        setting.set_int(chapter_id, 1, self.red_point_prefix, true)
        self:refresh_story_red_point()
    end
end

---@private
function story_system:on_branch_story_record_changed(event_type, row, col, old_value, new_value)
    local refresh = false
    if event_type == record_event_type.add_row then
        refresh = true
    elseif event_type == record_event_type.update_value then
        if col == t.Player.records.StoryBranch.columns.ChapterStatus and new_value == 1 and old_value ~= 4 then
            refresh = true
        end
    end
    if refresh then
        self:refresh_story_red_point()
    end
end

--endregion

---获取运行中的剧情
---@public
---@return story
function story_system:get_running_story()
    ---由于主支线剧情运行过程中，可能同时运行功能剧情，所以把主线放到最后    
    if self.func_story.is_running then
        return self.func_story
    elseif self.explorer_story.is_running then
        return self.explorer_story
    elseif self.branch_story.is_running then
        return self.branch_story
    elseif self.main_story.is_running then
        return self.main_story
    end
end

---返回居所
---@public
function story_system:go_home(param)
    local home_scene_id = data.get(t.ConstClient.name, t.ConstComm.ids.KW_SCENE_HOME, t.ConstClient.properties.String)
    game_scene_manager.switch_scene(home_scene_id, 0, param)
end

---初始化主线剧情
---@private
function story_system:init_main_story()
    self.main_story:init()
    game_data_manager.player.player_net_obj:add_property_listener(t.Player.properties.ModuleId, self.on_module_id_changed, self)
    game_data_manager.player.player_net_obj:add_property_listener(t.Player.properties.ChapterStatus, self.refresh_chapter_enable_status, self)
    game_data_manager.player.player_net_obj:add_property_listener(t.Player.properties.Level, self.refresh_chapter_enable_status, self)
    network.add_message_listener(EGameMsgID.ACK_CHAPTER_TIP_OK, message_names.AckChapterRewardTipOk, self.on_ack_confirm_chapter_rewards, self)
end

---开始主线剧情
---@public
function story_system:start_main_story()
    local is_start_chapter = false
    local current_scene_id = game_scene_manager.current_scene().id
    if current_scene_id ~= scene.root_scene_id then
        local scene_type = data.get(t.Scene.name, current_scene_id, t.Scene.properties.Type)
        if scene_type == 2 or scene_type == 4 then
            is_start_chapter = true
        end
    end

    local scene_param
    if is_start_chapter then
        ---居所和探索场景，开始主线时使用主线剧情专属Loading
        scene_param = { loading_type = load_type.StartChapter }
    end
    self.main_story:start(nil, nil, nil, scene_param)
    self:set_chapter_visited(self.main_story.chapter_id)
end

---开始支线剧情
---@param chapter_id string 章节Id
---@public
function story_system:start_branch_story(chapter_id)
    self.branch_story:init(chapter_id)
    self.branch_story:start()
    self:set_chapter_visited(chapter_id)
end

---开始功能剧情
---@public
---@param module_ids table<string> 模块Id
---@param story_window_id string 自定义剧情窗口id
---@param keep_windows_while_first_switch_scene boolean 剧情中第一次切场景时，是否保留当前场景中的窗体状态
---@param callback function 回调
---@param module_type number 剧情加载数据来源 : 0/空 数据来源为ModuleSide,AvgSide; 1 为 ModuleCharacter,AvgCharacter
function story_system:start_func_story(module_ids, story_window_id, keep_windows_while_first_switch_scene, callback, module_type)
    if module_ids == nil or #module_ids <= 0 then
        log.error("can't start_func_story, module_ids is nil")
        return
    end
    local module = module_type or 0
    local module_name = t.ModuleSide.name
    local Avg_name = t.AvgSide.name
    local black_in
    if module == 0 then
        data.load(module_name)
        data.load(Avg_name)
        black_in = data.get(t.ModuleSide.name, module_ids[1], t.ModuleSide.properties.BlackIn) == 1
    else  --- 更改数据来源
        module_name = t.ModuleCharacter.name
        Avg_name = t.AvgCharacter.name
        data.load(module_name)
        data.load(Avg_name)
        black_in = data.get(module_name, module_ids[1], t.ModuleCharacter.properties.BlackIn) == 1
    end
    self.func_story:init(nil, module_ids, story_window_id, module_type) ---添加数据来源参数
    local start_func_story = function()
        ---气泡特殊处理
        self.hide_bubbles = false
        local home_content_win = window.get_window(t.Window.ids.HomeContent)
        if home_content_win and home_content_win.status == window_status.show then
            self.hide_bubbles = true
            message.broadcast(msg_type.TRIGGER_HIDE_BUBBLES)
        end
        ---隐藏冲突的窗体
        local hidden_window_ids = data.get(t.ConstClient.name, t.ConstClient.ids.KW_AVG_MUTUALLY_EXCLUSIVE_WINDOW, t.ConstClient.properties.Array_String)
        self.hidden_window_func_story = {}
        for i = 1, #hidden_window_ids do
            local win = window.get_window(hidden_window_ids[i])
            if win and win.status == window_status.show then
                win:set_enable(false)
                array.insert(self.hidden_window_func_story, win)
            end
        end
        self.func_story:start(keep_windows_while_first_switch_scene, function(skip)
            ---恢复隐藏的窗体
            for i = 1, #self.hidden_window_func_story do
                self.hidden_window_func_story[i]:set_enable(true)
            end
            self.hidden_window_func_story = nil
            data.unload(module_name)
            data.unload(Avg_name)

            if self.hide_bubbles then
                message.broadcast(msg_type.TRIGGER_SHOW_BUBBLES)
                self.hide_bubbles = nil
            end
            if callback then
                callback(skip)
            end
        end, function()
            if black_in then
                window.hide_global_mask()
            end
        end)
    end

    if black_in then
        window.play_global_mask_fade_out(function()
            start_func_story()
        end)
    else
        start_func_story()
    end
end

---开始探索剧情
---@public
---@param module_ids table<string> 模块Id
---@param story_window_id string 自定义剧情窗口id
---@param keep_windows_while_first_switch_scene boolean 剧情中第一次切场景时，是否保留当前场景中的窗体状态
---@param callback function 回调
function story_system:start_explorer_story(module_ids, story_window_id, keep_windows_while_first_switch_scene, callback)
    data.load(t.ModuleExplore.name)
    data.load(t.AvgExplore.name)
    self.explorer_story:init(nil, module_ids, story_window_id)
    self.explorer_story:start(keep_windows_while_first_switch_scene, function()
        data.unload(t.ModuleExplore.name)
        data.unload(t.AvgExplore.name)
        if callback then
            callback()
        end
    end)
end

---获取主线章节对象
---@public
---@return story_chapter_item
function story_system:get_main_story_chapter()
    if not self.main_story_chapter then
        self.main_story_chapter = chapter_item_class.new()
        self:refresh_chapter_info()
    end

    return self.main_story_chapter
end

---@private
function story_system:on_module_id_changed(_, _, _, _)
    self.main_story:refresh_chapter_module_info()
end

---@private
function story_system:refresh_chapter_enable_status(_, _, _, _)
    self:refresh_chapter_info()
end

---刷新章节信息
---@private
function story_system:refresh_chapter_info()
    if self.main_story_chapter == nil then
        return
    end

    local current_chapter = self.main_story:get_current_chapter()
    local current_module = self.main_story:get_current_module()
    self.main_story_chapter.is_main_story = true
    self.main_story_chapter.chapter_id = current_chapter.Id
    self.main_story_chapter.chapter_name = current_chapter.Name
    self.main_story_chapter.is_chapter_unlock = game_data_manager.player.player_net_obj:get_property_number(t.Player.properties.ChapterStatus) > 0
    self.main_story_chapter.chapter_desc = current_chapter.Desc
    ---@type table
    self.main_story_chapter.chapter_rewards = self:get_chapter_reward(current_chapter.Id, t.Chapter.name)
    if self.main_story_chapter.is_chapter_unlock then
        local current, total = array.index_of(current_chapter.Modules, current_module.Id), #current_chapter.Modules
        if not current then
            current = 0
        end
        self.main_story_chapter.chapter_progress = current / total
        self.main_story_chapter.chapter_progress_string = string_format("(%d/%d)", current, total)
        self.main_story_chapter.chapter_desc_or_unlock_condition = self.main_story_chapter.chapter_desc
        self.main_story_chapter.chapter_progress_or_unlock_progress_string = self.main_story_chapter.chapter_progress_string
    else
        ---@type Condition
        local condition = data.get(t.Condition.name, current_chapter.UnlockCondition)
        self.main_story_chapter.chapter_progress = 0
        self.main_story_chapter.chapter_progress_string = "(?/?)"
        self.main_story_chapter.chapter_unlock_condition = condition.Name
        self.main_story_chapter.chapter_desc_or_unlock_condition = self.main_story_chapter.chapter_unlock_condition
        if condition.Type == 8 then
            local required_level = condition.Data[1].Array[2]
            local level = game_data_manager.player.player_net_obj:get_property_number(t.Player.properties.Level)
            self.main_story_chapter.chapter_progress_or_unlock_progress_string = string_format("(<color=#de2714>%d</color>/%d)", level, required_level)
            self.main_story_chapter.chapter_unlock_progress = level / required_level
        else
            self.main_story_chapter.chapter_progress_or_unlock_progress_string = "(<color=#de2714>0</color>/1)"
            self.main_story_chapter.chapter_unlock_progress = 0
        end
    end
end

---领取奖励ack
---@private
function story_system:on_ack_confirm_chapter_rewards(ack)
    if ack.event_code == EGameEventCode.SUCCESS then
        self:refresh_chapter_info()
        self:refresh_story_red_point()
    end
end

---获取章节奖励
---@private
function story_system:get_chapter_reward(chapter_id, chapter_data_name)
    if not data.is_name(chapter_id, chapter_data_name) then
        log.error("error chapter id ", chapter_id)
    end

    local random_id = data.get(chapter_data_name, chapter_id, t.Chapter.properties.Bonus)
    if string_is_nil_or_empty(random_id) then
        return {}
    end
    if not data.is_name(random_id, t.Random.name) then
        log.error("error random id ", random_id)
        return
    end

    local drop_data = data.get(t.Random.name, random_id, t.Random.properties.DropData)
    local rewards = {}
    for i, v in ipairs(drop_data) do
        local r_data = reward_data.new()
        r_data.item_id = v.Array[1]
        r_data.item_count = to_number(v.Array[2])

        local r_item = reward_item.new(r_data)
        array.insert(rewards, r_item)
    end

    return rewards
end

---获取支线剧情章节数据
---@public
---@return table<story_chapter_item>
function story_system:get_branch_story_chapters()
    local chapters = {}
    local branch_story_record = game_data_manager.player.player_net_obj:get_record(t.Player.records.StoryBranch.name)
    local rows = branch_story_record:get_rows()
    local player_level_unlock_formatter = localization.get_string(string_keys.module_unlock_condition)
    for _, row in pairs(rows) do
        local chapter_status = row:get_value(t.Player.records.StoryBranch.columns.ChapterStatus)
        if chapter_status < 3 then
            local chapter_id = row:get_value(t.Player.records.StoryBranch.columns.ChapterID)
            local module_id = row:get_value(t.Player.records.StoryBranch.columns.ModuleID)
            local unlock_condition_id = row:get_value(t.Player.records.StoryBranch.columns.UnlockConditionID)
            local chapter_data = data.get(t.ChapterBranch.name, chapter_id)
            local current = array.index_of(chapter_data.Modules, module_id)
            local total = #chapter_data.Modules
            if not current then
                current = 0
            end

            local chapter = chapter_item_class.new()
            chapter.chapter_id = chapter_id
            chapter.is_main_story = false
            chapter.chapter_name = chapter_data.Name
            chapter.chapter_desc = chapter_data.Desc
            chapter.is_chapter_unlock = chapter_status ~= 0
            chapter.chapter_rewards = self:get_chapter_reward(chapter_id, t.ChapterBranch.name)
            if chapter.is_chapter_unlock then
                chapter.chapter_progress = current / total
                chapter.chapter_progress_string = string_format("(%d/%d)", current, total)
                chapter.chapter_progress_or_unlock_progress_string = chapter.chapter_progress_string
                chapter.chapter_desc_or_unlock_condition = chapter_data.Desc
            else
                ---@type Condition
                local condition = data.get(t.Condition.name, unlock_condition_id)
                local colored_unlock_progress_string = nil
                if condition.Type == 8 then
                    ---玩家等级条件
                    local level = game_data_manager.player.player_net_obj:get_property_number(t.Player.properties.Level)
                    local required_level = condition.Data[1].Array[2]
                    chapter.chapter_unlock_condition = string_format(player_level_unlock_formatter, required_level)
                    chapter.chapter_unlock_progress_string = string_format("%d/%d", level, required_level)
                    chapter.chapter_unlock_progress = level / to_number(required_level)
                    colored_unlock_progress_string = string_format("(<color=#de2714>%d</color>/%d)", level, required_level)
                else
                    ---其他类型条件
                    chapter.chapter_unlock_condition = condition.Name
                    chapter.chapter_unlock_progress_string = "0/1"
                    chapter.chapter_unlock_progress = 0
                    colored_unlock_progress_string = "(<color=#de2714>0</color>/1)"
                end
                chapter.chapter_progress_string = "(?/?)"
                chapter.chapter_progress_or_unlock_progress_string = colored_unlock_progress_string
                chapter.chapter_desc_or_unlock_condition = chapter.chapter_unlock_condition
            end

            array.insert(chapters, chapter)
        end
    end

    ---刷新排序
    table_mul_sort(chapters, function(val)
        return {
            val.is_chapter_unlock,
            val.chapter_id
        }
    end)
    return chapters
end

---战斗定制退出处理
---@private
---@param exit_type battle_exit_type 退出战斗类型（0-普通退出；1-特殊退出流程；2-重新挑战；3-跳转（指定场景退出））
---@param battle_type table
---@param is_victory boolean
function story_system:on_battle_custom_exit_flow_handle(exit_type, battle_type, is_victory)
    if exit_type ~= 1 then
        return
    end

    local EBattleType = enum.proto.EBattleType
    if battle_type ~= EBattleType.BATTLE_TYPE_STORY and battle_type ~= EBattleType.BATTLE_TYPE_STORY_BRANCH then
        return
    end

    local story = self:get_running_story()
    if is_victory then
        story:check_module_complete()
    else
        story:stop_by_interrupt()
        self:go_home()
    end
end

---销毁
---@public
function story_system:dispose()
    -- 移除事件监听
    message.remove_listener(enum.message_type.BATTLE_CUSTOM_EXIT_BATTLE_FLOW, self.on_battle_custom_exit_flow_handle, self)
    network.remove_message_listener(EGameMsgID.ACK_CHAPTER_TIP_OK, self.on_ack_confirm_chapter_rewards, self)
    game_data_manager.player.player_net_obj:remove_property_listener(t.Player.properties.ModuleId, self.on_module_id_changed, self)
    game_data_manager.player.player_net_obj:remove_property_listener(t.Player.properties.ChapterStatus, self.refresh_chapter_enable_status, self)
    game_data_manager.player.player_net_obj:remove_property_listener(t.Player.properties.Level, self.refresh_chapter_enable_status, self)
    game_data_manager.player.player_net_obj:remove_record_listener(t.Player.records.StoryBranch.name, self.on_branch_story_record_changed, self)
end

return story_system