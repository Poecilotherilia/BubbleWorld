---
--- Generated by wuhaijun
--- File name : state_utility.lua.txt
--- DateTime : 2021/07/6
--- Description : 状态控制工具类，状态相关操作需要通过该类完成
---

local helper = battle_helper
local data_mgr = data
local table_names = tables

---@type fsm_battle_factory
local fsm_battle_factory = require(helper.path.battle_fsm .. 'fsm/fsm_battle_factory')
---@type battle_components
local battle_components = require(helper.path.battle_components)

---@class state_utility
local state_utility = { cname = "state_utility" }

--region 私有方法
---获取或添加状态限制组件
---@private
---@param entity entity
---@return state_constraint_component_data
local get_or_add_constraint_comp = function(entity)
    if entity == nil then
        helper.error('Invalid entity')
        return
    end
    if not entity:is_active() then
        helper.error('Entity.is_active = false')
        return
    end
    
    ---@type state_constraint_component_data
    local state_comp = entity:get_component(battle_components.state_constraint)
    if state_comp == nil then
        state_comp = entity:add_component(battle_components.state_constraint, 0)
    end
    
    return state_comp
end

---检测状态是否是受限的
---@private
---@param entity entity 目标实体
---@param state_mid string 状态表id
---@return boolean true:受限, false:不受限
local check_state_constraint = function(entity, state_mid)
    ---@type number 状态类型
    local state_type = data_mgr.get(table_names.BTLState.name, state_mid, table_names.BTLState.properties.StateType)
    if state_type == nil then return false end
    
    local comp_value = get_or_add_constraint_comp(entity).value
    local value = comp_value & (1 << state_type)
    
    return 0 ~= value
end
--endregion

---尝试切换实体状态
---@public
---@param entity entity 目标实体
---@param state_mid string 目标状态
---@return boolean 是否切换成功
function state_utility.try_switch_state(entity, state_mid)
    if entity == nil or state_mid == nil then
        helper.error('invalid arguments, state_mid = ', state_mid)
        return false
    end

    ---@type unit_state_component_data
    local state_comp = entity:get_component(battle_components.unit_state)
    helper.assert(state_comp ~= nil, "Initial unit_state not added, eid = ", entity.eid)

    -- 受限状态不能切换
    if check_state_constraint(entity, state_mid) then
        helper.warning('state constraint, eid = ', entity.eid, ', from = ', state_comp.current, ', to = ', state_mid)
        return false, state_comp.current
    end
  
    -- 记录历史状态
    local cur_fsm_state = fsm_battle_factory.get_fsm(state_comp.current)
    if cur_fsm_state == nil or (cur_fsm_state:is_need_restore() and not state_comp.history:contains(state_comp.current)) then
        state_comp.history:push(state_comp.current)
    end
    -- 待恢复状态中有目标状态，则移除
    state_comp.history:remove(state_mid)

    if not helper.is_debug then
        helper.log('switch unit FSM, eid = ', entity.eid, ', from = ', state_comp.current, ', to = ', state_mid)
    else
        local his_str = {}
        state_comp.history:foreach(function(key)
            his_str[#his_str + 1] = key
        end)
        local concat_str = table.concat(his_str, ',')
        helper.log('switch unit state, eid = ', entity.eid, ', from = ', state_comp.current, ', to = ', state_mid, ", history = ", concat_str)
    end

    -- 切换状态处理
    state_utility.switch_state_handle(entity, state_comp.current, state_mid, state_comp.history)
    
    return true
end

---切换状态处理
---@private
---@param entity entity 目标实体
---@param current string 当前类型
---@param history stack 历史状态表<string> 
---@return boolean 是否切换成功
function state_utility.switch_state_handle(entity, current, next, history)
    -- 退出当前状态
    state_utility.set_unit_state(entity, current, false)
    -- 设置状态组件
    entity:replace_component(battle_components.unit_state, next, history)
    -- 进入新状态
    state_utility.set_unit_state(entity, next, true)
end


---尝试切换实体状态
---@public
---@param entity entity 目标实体
---@param state_type number 目标类型
---@return boolean 是否切换成功
function state_utility.try_switch_state_type(entity, state_type)
    local state_mid = state_utility.get_state_mid_by_type(state_type)
    return state_utility.try_switch_state(entity, state_mid)
end

---实体退出该状态
---@public
---@param entity entity 目标实体
---@param state_mid string 退出指定状态id
---@return boolean 状态是否转换成功
function state_utility.exit_state(entity, state_mid)
    if entity == nil then
        helper.error('invalid entity = ', entity)
        return
    end

    ---@type unit_state_component_data
    local state_comp = entity:get_component(battle_components.unit_state)
    if state_comp == nil then return end

    -- 获取历史状态
    ---@type stack
    local historical = state_comp.history
    if state_mid == nil or state_comp.current == state_mid then
        -- 返回上一个状态
        if historical:count() > 0 then
             local state = historical:pop()
             helper.log('exit unit state, eid = ', entity.eid, ', from = ', state_comp.current, ', to = ', state)

            -- 切换状态处理
            state_utility.switch_state_handle(entity, state_comp.current, state, state_comp.history)
        end
    else
        -- 移除历史状态
        helper.log('exit unit state, eid = ', entity.eid, ", cur_state = ", state_comp.current, ', remove history = ', state_mid)
        historical:remove(state_mid)
    end
end

---实体退出该状态
---@public
---@param content context
---@param eid number
---@param target_state_mid string 指定的状态id
---@return boolean 状态是否转换成功
function state_utility.exit_state_by_eid(content, eid, target_state_mid)
    local entity = content:get_entity_by_primary_index(battle_components.eid, eid)
    return state_utility.exit_state(entity, target_state_mid)
end

---设置单位状态
---@public
---@param entity entity 目标实体
---@param state_mid string 状态类型
---@return boolean
function state_utility.set_unit_state(entity, state_mid, is_enter)
    local fsm_state = fsm_battle_factory.get_fsm(state_mid)
    if fsm_state == nil then return end

    if is_enter then
        fsm_state:on_enter_state(entity)
    else
        fsm_state:on_exit_state(entity)
    end
end

---获取状态配置id根据状态类型
---@public
---@param state_type number 状态类型
---@return boolean 是否切换成功
function state_utility.get_state_mid_by_type(state_type)
    ---@type table<string, BTLState>
    local state_dict = data_mgr.get_all(table_names.BTLState.name)
    for state_mid, state_value in pairs(state_dict) do
        if state_value.StateType == state_type then
            return state_mid
        end
    end
end

---检测是否与当前状态一致
---@public
---@param entity entity 目标实体
---@param state_mid string 状态类型
---@return boolean
function state_utility.is_current_state(entity, state_mid)
    ---@type unit_state_component_data
    local state_comp = entity:get_component(battle_components.unit_state)
    return state_comp ~= nil and (state_comp.current == state_mid)
end

---添加状态限制
---@public
---@param entity entity 目标实体
---@param state_mid string 状态类型
function state_utility.add_state_constraint_by_mid(entity, state_mid)
    local state_type = data_mgr.get(table_names.BTLState.name, state_mid, table_names.BTLState.properties.StateType)
    if state_type == nil then return end
    
    local comp = get_or_add_constraint_comp(entity)
    entity:replace_component(battle_components.state_constraint, comp.value | (1 << state_type))
end

---移除状态限制
---@public
---@param entity entity 目标实体
---@param state_mid string 状态类型
function state_utility.remove_state_constraint_by_mid(entity, state_mid)
    local state_type = data_mgr.get(table_names.BTLState.name, state_mid, table_names.BTLState.properties.StateType)
    if state_type == nil then return end
    
    local comp = get_or_add_constraint_comp(entity)
    entity:replace_component(battle_components.state_constraint, comp.value ~ (1 << state_type))
end

---实体清空状态限制
---@public
---@param entity entity 目标实体
function state_utility.clear_state_constraint(entity)
    entity:replace_component(battle_components.state_constraint, 0)
end

---初始化
---@public
function state_utility.initialize(context)
    fsm_battle_factory.init(context)
end

---销毁
---@public
function state_utility.dispose()
    fsm_battle_factory.dispose()
end

return state_utility