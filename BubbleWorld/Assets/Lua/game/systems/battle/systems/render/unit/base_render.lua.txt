---
--- Generated by wuhaijun
--- File name : base_render.lua.txt
--- DateTime : 2021/04/02
--- Description : 
---

local helper = battle_helper
local table_remove = table.remove
local string_is_nil_or_empty = string.is_nil_or_empty
local MaterialPropertyType = cs.MaterialPropertyType
local MaterialPropertyData = cs.MaterialPropertyData
local UpdateType = cs.UpdateType
local asset_type = df.enum.asset_type
local Color = cs.Color
local Vector4 = cs.Vector4
local Vector2 = cs.Vector2

---@type object_pool
local object_pool = require 'framework/pool/object_pool'
---@type callback
local callback = require(ecs_helper.path .. 'callback')
---@type battle_components
local battle_components = require(helper.path.battle_components)

local wwise_util = require 'game/utils/wwise_util/wwise_util'

---@class base_render
local base_render = class("base_render")

---构造函数
---@protected
function base_render:ctor(type)
    ---渲染器类型
    ---@public
    ---@type battle_renderer_type
    self.renderer_type = type

    ---加载资源回调
    ---@protected
    ---@type fun(go:UnityEngine.GameObject)
    self.loaded_gameobject_callback = function(go) self:load_unit_finished(go) end
    ---特效播放完毕回调
    ---@private
    ---@type fun(e:base_effect)
    self.play_effect_finished_callback = function(e) self:play_effect_finished_handle(e) end
    ---播放音效完毕回调
    ---@private
    ---@type fun(a:audio)
    self.play_sound_finished_callback = function(a) self:play_sound_finished_handle(a) end

    ---播放音效完毕回调
    ---@private
    ---@type fun(m, id)
    self.set_material_property_callback = function(m, id) self:set_material_property_data_handle(m, id) end
    
    ---是否初始化
    ---@private
    ---@type boolean
    self.is_init = nil
    ---是否显示
    ---@protected
    ---@type boolean
    self.is_show = nil
    ---是否激活
    ---@protected
    ---@type boolean
    self.is_active = nil

    ---单位预制体
    ---@public
    ---@type UnityEngine.GameObject
    self.gameobject = nil
    ---单位预制体Transform
    ---@public
    ---@type UnityEngine.Transform
    self.transform = nil

    ---战斗上下文
    ---@protected
    ---@type context
    self.context = nil
    ---战斗渲染层
    ---@protected
    ---@type battle_renderer
    self.renderer = nil
    ---实体id
    ---@private
    ---@type number
    self.entity_id = nil
    ---资源路径
    ---@protected
    self.res_path = nil
    ---父节点
    ---@protected
    ---@type UnityEngine.Transform
    self.parent_trans = nil
    
    ---播放速度
    ---@protected
    ---@type number
    self.play_speed = nil

    ---初始化完毕回调
    ---@public
    ---@type callback
    self.init_finished_callback = nil

    ---当前动作配置ID
    ---@public
    ---@type string
    self.current_action_mid = nil

    ---正在播放的特效列表
    ---@protected
    ---@type number[]
    self.effect_list = {}
    ---正在播放的特效列表
    ---@protected
    ---@type number[]
    self.audio_list = {}

    ---Shader使用的TimerId
    ---@private
    ---@type table<number, boolean>
    self.shader_timer_id_dict = {}
    ---材质球使用的的贴图
    ---@private
    ---@type table<string, DeusFramework.Res.Model.DfRes>
    self.material_texture_asset_dict = {}
end

--region 初始化相关
---初始化
---@public
---@param context context
---@param eid number entityId
---@param res_path string 资源路径
---@param finished_callback fun(render:base_render)
function base_render:initialize(context, eid, res_path, finished_callback)
    self.context = context
    self.renderer = context.renderer
    self.entity_id = eid
    self.res_path = res_path
    self.init_finished_callback = callback.new(finished_callback)

    ---@type UnityEngine.Transform 父节点
    self.parent_trans = self.renderer:get_root_transform()
    self:set_play_speed(context.controller:get_time_scale())
    
    -- 加载单位
    self:load_unit_handle()
end

---加载单位预制体
---@protected
function base_render:load_unit_handle()
    if self.renderer ~= nil then
        self.renderer:load_gameobject_async(self.res_path, self.parent_trans, self.loaded_gameobject_callback)
    end
end

---加载预制体完成
---@private
---@param go UnityEngine.GameObject
function base_render:load_unit_finished(go)
    helper.assert(go ~= nil, "invalid prefab, asset_path = ", self.res_path)

    self.gameobject = go
    self.transform = go.transform
    self.is_init = true
    
    -- 开始
    self:on_start()
    
    -- 初始完毕回调
    if self.init_finished_callback ~= nil then
        self.init_finished_callback(self)
    end
end

---初始化完毕，开始渲染层逻辑
---@protected
function base_render:on_start()
end
--endregion

--region 设置相关
---设置激活状态
---@public
---@param active boolean
function base_render:set_is_active(active)
    self.is_active = active == true
    if self.renderer == nil then return end

    -- 设置特效显隐
    local effect_ctrl = self.renderer:get_effect_ctrl()
    local effect_list = self.effect_list
    for i = 1, #effect_list do
        effect_ctrl:set_effect_hide_by_unique_id(effect_list[i], active == false)
    end

    -- 设置音效显隐
    if not active then
        for i = 1, #self.audio_list do
            local audio_data = self.audio_list[i]
            wwise_util.stop_audio_by_playing_id(audio_data.play_id)
        end
        self.audio_list = {}
    end
    --local audio_ctrl = self.renderer:get_audio_ctrl()
    --local audio_list = self.audio_list
    --for i = 1, #audio_list do
    --    local audio_uid = audio_list[i]
    --    if not active then
    --        audio_ctrl:stop_sound(audio_uid)
    --    end
    --end
end
--endregion

--region 获取相关
---获取激活状态
---@public
---@return boolean
function base_render:get_is_active()
    return self.is_active
end

---获取初始化状态
---@public
---@return boolean
function base_render:get_is_init()
    return self.is_init
end

---获得资源路径
---@public
function base_render:get_res_path()
    return self.res_path
end

---获取实体id
---@public
function base_render:get_eid()
    return self.entity_id
end

---获取实体
---@protected
---@return entity
function base_render:get_entity()
    -- 防止逻辑层被销毁情况
    if not self.context:is_active() then return end

    ---@type entity
    local entity
    ---@type number eid
    local current_eid = self:get_eid()
    if self.context:has_entity_eid(current_eid) then
        entity = self.context:get_entity_by_primary_index(battle_components.eid, current_eid)
    end

    return entity
end

---获取res_loader和res_pool
---@public
---@return DeusFramework.Res.DfResLoader, DeusFramework.Pool.DfResPool
function base_render:get_res_loader_and_pool()
    if self.renderer ~= nil then
        return self.renderer:get_res_loader_and_pool()
    end
end

---获取挂点
---@public
---@param point_name string 挂点名字
---@param is_show_error boolean 输出日志
---@return UnityEngine.Transform
function base_render:get_attach_point(point_name, is_show_error)
    helper.error('Subclass implementation interface, point_name = ', point_name, ', is_show_error = ', is_show_error)
end

---获取位置
---@public
---@return number, number, number
function base_render:get_position()
    helper.error('Subclass implementation interface, get_position')
end

---获取欧拉角
---@public
---@return number, number, number
function base_render:get_euler_angles()
    helper.error('Subclass implementation interface, get_euler_angles')
end

---获取战斗单位Lua绑定器
---@public
---@return Game.Behaviour.BattleUnitLuaBehaviour
function base_render:get_lua_behaviour()
    helper.error('Subclass implementation interface, get_lua_behaviour')
end
--endregion

--region 时间相关
---设置动画播放速度
---@public
---@param speed number
function base_render:set_play_speed(speed)
    self.play_speed = speed

    -- 设置特效播放速度
    local effect_ctrl = self.renderer:get_effect_ctrl()
    local effect_list = self.effect_list
    for i = 1, #effect_list do
        effect_ctrl:set_effect_speed_by_unique_id(effect_list[i], speed)
    end

    local audio_list = self.audio_list
    for i = 1, #audio_list do
        wwise_util.set_audio_time(speed, audio_list[i].play_id)
    end
    --wwise_util.set_audio_speed(speed)
    
    --local audio_ctrl = self.renderer:get_audio_ctrl()
    --
    ------ 设置音效播放速度
    ----audio_ctrl:set_battle_audio_speed(speed)
    --
    --local audio_list = self.audio_list
    --for i = 1, #audio_list do
    --    local audio = audio_ctrl:get_audio_by_unique_id(audio_list[i])
    --    if audio ~= nil and not audio._speed_keep then
    --        audio:set_audio_speed(speed)
    --    end
    --end
end

---补帧处理
---@public
---@param target_value number 目标缩放值
---@param duration number 持续时间（秒）
function base_render:fix_render_frame_handle(target_value, duration)
    helper.error('subclass implementation fix_render_frame_handle method，args = ', target_value, duration)
end
--endregion

--region 动画相关
---播放动画片段
---@public
---@param clip_path string 动画片段路径
---@param play_speed number 播发速度
---@param fade_time number 融合时间
---@param is_loop boolean 是否循环
---@param finish_callback fun(eid:number) 播放完成回调
function base_render:play_animation(clip_path, play_speed, fade_time, is_loop, finish_callback)
    -- helper.error('subclass implementation play_animation method，args = ', clip_path, play_speed, fade_time, is_loop, finish_callback)
end
--endregion

--region 特效相关
---播放特效在挂点上
---@public
---@param effect_mid string 特效配置id
---@param point_name string 挂点名字
---@param xx number x偏移
---@param yy number y偏移
---@param zz number z偏移
---@return number 播放特效产生的uid
function base_render:play_effect_by_attack_point(effect_mid, point_name, xx, yy, zz)
    ---特效父节点
    ---@type UnityEngine.Transform
    local parent_trans = self:get_attach_point(point_name)
    return self:play_effect_internal(effect_mid, parent_trans, xx, yy, zz)
end

---播放特效在坐标上
---@public
---@param effect_mid string 特效配置id
---@param xx number x坐标
---@param yy number y坐标
---@param zz number z坐标
---@return number 播放特效产生的uid
function base_render:play_effect_by_position(effect_mid, xx, yy, zz)
    ---特效父节点
    ---@type UnityEngine.Transform
    local parent_trans = self.renderer:get_root_transform()
    return self:play_effect_internal(effect_mid, parent_trans, xx, yy, zz)
end

---播放特效
---@protected
---@param effect_mid string 特效配置id
---@param parent_trans UnityEngine.Transform 特效父节点
---@param xx number x偏移
---@param yy number y偏移
---@param zz number z偏移
---@return number 播放特效产生的uid
function base_render:play_effect_internal(effect_mid, parent_trans, xx, yy, zz)
    helper.assert(effect_mid ~= nil, "invalid effect_mid in play_effect")
    
    xx = xx or 0
    yy = yy or 0
    zz = zz or 0
    
    local speed = self.play_speed
    local effect_ctrl = self.renderer:get_effect_ctrl()
    local effect_list = self.effect_list

    -- 播放特效
    -- local effect_uid = effect_ctrl:play_effect_by_pool_sync(effect_mid, parent_trans, speed, self.play_effect_finished_callback)
    local effect_uid = effect_ctrl:play_effect_by_pool_async(effect_mid, parent_trans, speed, self.play_effect_finished_callback)
    -- 检测特效是否存在
    if helper.is_debug then
        for i = 1, #effect_list do
            if effect_list[i] == effect_uid then
                helper.error('Why does the effect_id already exist, effect_mid = ', effect_mid, ', effect_id = ', effect_uid)
                break
            end
        end
    end
    effect_list[#effect_list + 1] = effect_uid

    -- 设置偏移
    effect_ctrl:set_effect_local_position_by_unique_id(effect_uid, xx, yy, zz)
    -- 设置显隐
    effect_ctrl:set_effect_hide_by_unique_id(effect_uid, self:get_is_active() == false)

    return effect_uid
end

---播放特效完毕
---@private
---@param effect base_effect
function base_render:play_effect_finished_handle(effect)
    if effect == nil then return end

    local effect_list = self.effect_list
    
    for i = 1, #effect_list do
        if effect_list[i] == effect.unique_id then
            table_remove(effect_list, i)
            break
        end
    end
end

---移除特效处理
---@public
---@param effect_mid string 特效配置ID
function base_render:remove_effect_handle(effect_mid)
    helper.assert(effect_mid ~= nil, "invalid effect_mid in remove_effect")
    
    local effect_ctrl = self.renderer:get_effect_ctrl()
    local effect_list = self.effect_list
    
    for i = 1, #effect_list do
        local effect_uid = effect_list[i]
        local effect = effect_ctrl:get_effect_by_unique_id(effect_uid)
        if effect ~= nil and effect.id == effect_mid then
            effect_ctrl:manual_unload_effect(effect_uid)
            table_remove(effect_list, i)
            break
        end
    end
end

---显示溶解效果
---@public
---@param is_show boolean 是否显示溶解效果
---@param duration_time number 显示持续时间
function base_render:show_dissolve_effect(is_show, duration_time)
    helper.error('subclass implementation show_dissolve_effect method，args = ', is_show, duration_time)
end
--endregion

--region 音效相关
---播放音效
---@public
---@param audio_mid string 音效配置id
---@param speed_keep boolean 是否保持播放速度为1
function base_render:play_sound(audio_mid, speed_keep)
    helper.assert(audio_mid ~= nil, "invalid audio_mid in play_sound")
    local info, pid = wwise_util.play_audio_in_persistence(audio_mid, nil, self.play_sound_finished_callback)
    if pid == nil or pid <= 0 then
        helper.error('Fail to play a battle audio:', audio_mid)
    --else
    --    self.audio_list[#self.audio_list + 1] = {audio_id = audio_mid, play_id = pid}
    end
end

---播放音效完毕
---@private
---@param audio audio_info wwise的音效播放逻辑类
function base_render:play_sound_finished_handle(audio)
    if self.audio_list == nil then return end
    if audio == nil then return end
    
    local audio_list = self.audio_list
    for i = 1, #audio_list do
        if audio_list[i].audio_id == audio.audio_id then
            table_remove(audio_list, i)
            break
        end
    end
end

---移除音效处理
---@public
---@param audio_mid string 音效配置ID
function base_render:remove_sound_handle(audio_mid)
    helper.assert(audio_mid ~= nil, "invalid audio_mid in remove_sound")
    local audio_list = self.audio_list
    for i = 1, #audio_list do
        local audio_data = audio_list[i]
        if audio_data.audio_id == audio_mid then
            wwise_util.stop_audio_by_playing_id(audio_data.play_id)
            -- table_remove(audio_list, i)
            break
        end
    end
end
--endregion

--region Shader相关
---设置材质球keyword
---@public
---@param keyword string Keyword
---@param is_active boolean 是否激活
---@param material_name string 材质球名
function base_render:set_material_keyword(keyword, is_active, material_name)
    if string_is_nil_or_empty(keyword) then return end

    local lua_behaviour = self:get_lua_behaviour()
    lua_behaviour:SetMaterialKeyword(keyword, is_active, material_name)
end

---设置材质球属性数据
---@public
---@param property_data battle_material_property_data 属性数据
function base_render:set_material_property_data(property_data)
    if string_is_nil_or_empty(property_data.PropertyName) then return end
    
    local id = self.context.controller:add_timer(property_data.DelayTime, self.set_material_property_callback, property_data)
    self.shader_timer_id_dict[id] = true
end

---设置材质球属性处理
---@private
---@param property_data battle_material_property_data shader数据
function base_render:set_material_property_data_handle(property_data, id)
    self.shader_timer_id_dict[id] = nil

    local property = property_data.PropertyName
    local material = property_data.MaterialName
    local lua_behaviour = self:get_lua_behaviour()

    -- 7是keyword
    if property_data.PropertyType ~= 7 then
        local target_data = self:get_config_property_data(property_data)
        local duration = property_data.DurationTime / 1000
        local delay<const> = 0
        local fcb<const>
        lua_behaviour:MaterialPropertyDataChanged(property, target_data, duration, fcb, delay, material, UpdateType.Manual)
    else
        lua_behaviour:SetMaterialKeyword(property, property_data.IsOpenKeyword, material)
    end
end

---获取材质球属性数据
---@public
---@param property_data battle_material_property_data
---@return Game.Behaviour.MaterialPropertyData
function base_render:get_config_property_data(property_data)
    ---@type Game.Behaviour.MaterialPropertyType
    local property_type = MaterialPropertyType.__CastFrom(property_data.PropertyType)
    
    local target_data = MaterialPropertyData()
    target_data.ValueType = property_type
   
    if property_type == MaterialPropertyType.Float then
        target_data.FloatValue = property_data.TargetFloatValue
    elseif property_type == MaterialPropertyType.Int then
        target_data.INTValue = property_data.TargetIntValue
    elseif property_type == MaterialPropertyType.Color then
        target_data.ColorValue = self:get_color(property_data.TargetColorValue)
    elseif property_type == MaterialPropertyType.Vector4 then
        target_data.Vector4Value = self:get_vector4(property_data.TargetVector4Value)
    elseif property_type == MaterialPropertyType.TextureScale then
        target_data.ScaleValue = self:get_vector2(property_data.TargetTextureScale)
    elseif property_type == MaterialPropertyType.TextureOffset then
        target_data.OffsetValue = self:get_vector2(property_data.TargetTextureOffset)
    elseif property_type == MaterialPropertyType.Texture then
        if not string_is_nil_or_empty(property_data.TargetTextureValue) then
            local texture_asset_data = self.material_texture_asset_dict[property_data.TargetTextureValue]
            if texture_asset_data == nil then
                texture_asset_data = self.renderer:load_asset(property_data.TargetTextureValue, asset_type.texture)
                self.material_texture_asset_dict[property_data.TargetTextureValue] = texture_asset_data
            end
            if texture_asset_data ~= nil then
                target_data.TextureValue = texture_asset_data.Result
            end
        end
    elseif property_type == MaterialPropertyType.Keyword then
        target_data.IsOpenKeyword = property_data.IsOpenKeyword
    else
        helper.error("PropertyType to be processed, PropertyType = ", property_type)
    end

    return target_data
end

---获取Color
---@private
---@param info skill_color_info
---@return UnityEngine.Color
function base_render:get_color(info)
    return Color(info.R, info.G, info.B, info.A)
end

---获取Vector4
---@private
---@param info skill_pos_info
---@return UnityEngine.Vector4
function base_render:get_vector4(info)
    return Vector4(info.X, info.Y, info.Z, info.W)
end

---获取Vector2
---@private
---@param info skill_pos_info
---@return UnityEngine.Vector2
function base_render:get_vector2(info)
    return Vector2(info.X, info.Y)
end
--endregion

--region 检测
---是否是目标类型
---@public
---@param type battle_renderer_type
---@return boolean
function base_render:check_renderer_type(type)
    return self.renderer_type == type
end
--endregion

--region 静态方法
---清理MaterialPropertyData
---@protected
function base_render.create_material_property_data()
    return MaterialPropertyData()
end

---清理MaterialPropertyData
---@protected
---@param data Game.Behaviour.MaterialPropertyData
function base_render.clear_material_property_data(data)
    data:Clear()
end

---MaterialPropertyData结构池
base_render.material_property_data_pool = object_pool.new(base_render.create_material_property_data,
        base_render.clear_material_property_data, base_render.clear_material_property_data)
--endregion

--region 清理与卸载
---卸载GameObject
---@protected
function base_render:unload_gameobject()
    if self.renderer ~= nil and self.gameobject ~= nil then
        self.renderer:unload_gameobject(self.gameobject)
    end
    self.gameobject = nil
    self.transform = nil
end

---清理
---@public
function base_render:clear()
    self:unload_gameobject()

    local renderer = self.renderer
    
    -- 清理特效
    local effect_ctrl = renderer:get_effect_ctrl()
    local effect_list = self.effect_list
    for i = 1, #effect_list do
        effect_ctrl:manual_unload_effect(effect_list[i])
    end
    helper.clear_array(self.effect_list)

    -- 清理音效
    local audio_list = self.audio_list
    for i = 1, #audio_list do
        wwise_util.stop_audio_by_playing_id(audio_list[i].play_id)
    end
    helper.clear_array(self.audio_list)
    --wwise_util.unload_all_persistence_audios()
    -------------------------------------------------
    --local audio_ctrl = renderer:get_audio_ctrl()
    --local audio_list = self.audio_list
    --for i = 1, #audio_list do
    --    audio_ctrl:manual_unload_audio(audio_list[i])
    --end
    --helper.clear_array(self.audio_list)
    
    -- 清理Shader

    if self.context.controller ~= nil then
        local timer_id_dict = self.shader_timer_id_dict
        for timer_id, _ in pairs(timer_id_dict) do
            self.context.controller:remove_timer(timer_id)
            timer_id_dict[timer_id] = nil
        end
    end

    for path, asset in pairs(self.material_texture_asset_dict) do
        renderer:unload_asset(asset)
        self.material_texture_asset_dict[path] = nil
    end
    helper.clear(self.material_property_source_dict)

    self.res_path = nil
    self.parent_trans = nil
    self.entity_id = nil
    self.is_active = nil
    self.current_action_mid = nil
    self.init_finished_callback:clear()
    self.renderer = nil
    self.context = nil
    self.is_init = false
end

---销毁
---@public
function base_render:dispose()
    self:clear()

    if self.init_finished_callback ~= nil then
        self.init_finished_callback:dispose()
        self.init_finished_callback = nil
    end
    self.is_init = nil

    self.material_texture_asset_dict = nil
    self.shader_timer_id_dict = nil
    self.effect_list = nil
    self.audio_list = nil
    self.renderer_type = nil
    self.loaded_gameobject_callback = nil
    self.play_effect_finished_callback = nil
    self.play_sound_finished_callback = nil
    self.set_material_property_callback = nil
    self.fix_render_frame_update_callback = nil
end
--endregion

return base_render