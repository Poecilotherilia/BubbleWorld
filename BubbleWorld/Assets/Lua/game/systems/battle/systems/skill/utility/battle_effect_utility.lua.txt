---
--- Generated by wuhaijun
--- File name : battle_effect_utility.lua.txt
--- DateTime : 2022/03/12
--- Description : 战斗效果（服务器）实用工具
---

---@type battle_helper
local helper = battle_helper
local data_mgr = data
local table_names = tables
---@type enum_battle
local enum_battle = enum.battle
local buff_trigger_event_type = enum_battle.buff_trigger_event_type
local behavior_class_name = enum_battle.behavior_class_name
local battle_unit_death_type = enum_battle.battle_unit_death_type
local BTLBuffRemoveReason = enum.proto.BTLBuffRemoveReason
local battle_buff_type = enum_battle.battle_buff_type
local is_nil_or_empty = string.is_nil_or_empty
local math_max = math.max
local math_floor = math.floor
local table_deep_copy = table.deep_copy

---@type ident
local ident = require(helper.path.battle_utils .. 'ident')
---@type state_utility
local state_utility = require(helper.path.battle_fsm .. 'state_utility')
---@type queue
local queue = require 'framework/basic/queue'
---@type battle_utility
local battle_utility = require(helper.path.battle_utils .. 'battle_utility')
---@type battle_constant
local battle_constant = require(helper.path.battle_utils .. 'battle_constant')
---@type battle_components
local battle_components = require(helper.path.battle_components)

---@class battle_effect_utility
local battle_effect_utility = { cname = 'battle_effect_utility' }

--region 技能效果处理
---更实体数据
---@private
---@param context context 战斗环境
---@param entities BTLEntity[]
function battle_effect_utility.update_entities_handle(context, entities)
    if entities == nil then return end

    -- 向网络层同步数据
    local database = context.database
    for i = 1, #entities do
        database:set_network_object_data(entities[i])
    end
end

---召唤数据处理
---@private
---@param context context 战斗环境
---@param effect BTLEffect 技能效果数据
function battle_effect_utility.skill_summon_data_handle(context, effect)
    if effect.summon == nil or effect.summon.entities == nil then return end

    local database = context.database
    ---@type BTLEntity[]
    local entities = effect.summon.entities
    local unit_state = table_names.BTLState.ids.BTLState_Born
    for i = 1, #entities do
        ---@type BTLEntity
        local new_btl_entity = entities[i]
        local unit_info = database:add_unit_info(new_btl_entity)
        battle_utility.generate_unit_entity(context, unit_info, true, unit_state)
    end
end

---技能变身数据处理
---@private
---@param context context 战斗环境
---@param effect BTLEffect 技能效果数据
function battle_effect_utility.skill_transform_data_handle(context, effect)
    ---@type BTLTransformInfo
    local transform_info = effect.transform
    if transform_info == nil then return end

    ---@type string 新的敌人id
    local new_enemy_id = transform_info.new_enemy_id
    ---@type Enemy 敌人
    local enemy_data = data_mgr.get(table_names.Enemy.name, new_enemy_id)
    if enemy_data == nil then
        helper.error_skill("not found enemy data, new_enemy_id = ", new_enemy_id)
        return
    end
    ---@type Monster 怪物
    local monster_data = data_mgr.get(table_names.Monster.name, enemy_data.MonsterId)
    if monster_data == nil then
        helper.error_skill('not found monster data, MonsterId = ', enemy_data.MonsterId)
        return
    end
    ---@type RoleRes RoleRes表数据
    local role_res_data = data_mgr.get(table_names.RoleRes.name, monster_data.RoleResIdData)
    if role_res_data == nil then
        helper.error_skill('not found RoleRes data, RoleResIdData = ', monster_data.RoleResIdData)
        return
    end
    ---@type number 缩放值
    local scale_value = role_res_data.Scale / 10000

    ---@type entity
    local entity = context:get_entity_by_primary_index(battle_components.uid, effect.caster_id)
    helper.assert(entity ~= nil, "caster entity not found, caster_id = ", effect.caster_id)
    
    -- 新数值覆盖
    ---@type battle_unit_info
    local unit_info = entity:get_component(battle_components.unit_info).value
    ---@type net_object
    local net_object = context.database:get_net_object(unit_info.uid)
    unit_info.enemy_mid = new_enemy_id
    unit_info.role_res_mid = monster_data.RoleResIdData
    unit_info.res_path = role_res_data.ModelPath
    unit_info.role_rare = net_object:get_property_value(table_names.Monster.properties.Rare)
    unit_info.hp_value = net_object:get_property_value(table_names.Monster.properties.Hp)
    unit_info.scale:set(scale_value ,scale_value, scale_value)
    
    -- 移除当前渲染单位
    context.renderer:remove_render_unit(entity.eid)
    -- 创建新的渲染单位
    entity:replace_component(battle_components.replace_render, unit_info.res_path, battle_constant.RENDER_BATTLE_UNIT)
    -- 向UI层同步变身单位
    context.message:send_sync_delete_render(unit_info.uid)
end

---技能复活数据处理
---@private
---@param context context 战斗环境
---@param effect BTLEffect 技能效果数据
function battle_effect_utility.skill_revive_data_handle(context, effect)
    ---@type BTLReviveInfo
    local revive_info = effect.revive
    if revive_info == nil then return end

    ---@type entity
    local entity = context:get_entity_by_primary_index(battle_components.uid, revive_info.entity_id)
    helper.assert(entity ~= nil, "caster entity not found, caster_id = ", effect.caster_id)

    ---@type battle_unit_info
    local unit_info = entity:get_component(battle_components.unit_info).value
    
    -- 移除当前渲染单位
    context.renderer:remove_render_unit(entity.eid)
    -- 创建新的渲染单位
    entity:replace_component(battle_components.replace_render, unit_info.res_path, battle_constant.RENDER_BATTLE_UNIT)
    -- 切换单位复活状态
    state_utility.try_switch_state(entity, table_names.BTLState.ids.BTLState_Revive)

    -- 重置死亡标识
    unit_info.is_death = false
end

---触发器
---@public
---@param context context 战斗环境
---@param effect BTLEffect 技能效果数据
function battle_effect_utility.trigger_data_handle(context, effect)
    ---@type BTLTriggerInfo 触发器
    local trigger_data = effect.trigger
    if trigger_data == nil then return end

    local battlefield_entity = context:get_unique_component(battle_components.battle_field)
    local trigger_comp = battlefield_entity:get_component(battle_components.skill_trigger)
    ---@type queue
    local data_queue
    if trigger_comp ~= nil then
        data_queue = trigger_comp.value
    else
        data_queue = queue.new()
    end
    data_queue:enqueue(trigger_data)
    
    battlefield_entity:replace_component(battle_components.skill_trigger, data_queue)
end
--endregion

--region Buff相关
---Buff数据处理
---@public
---@param context context 战斗环境
---@param effect BTLEffect 技能效果数据
function battle_effect_utility.skill_buff_data_handle(context, effect)
    ---@type BTLBuffInfo buff数据
    local buff_data = effect.buff
    if buff_data == nil then return end

    ---@type entity buff目标实体
    local target_entity = context:get_entity_by_primary_index(battle_components.uid, effect.target_id)
    -- 目标有可能为空，比如单位死亡了，移除其身上buff的情况
    if target_entity == nil then return end

    -- 尝试添加buff
    battle_effect_utility.try_to_adding_buff(context, target_entity, buff_data.add_buff)
    -- 移除buff
    battle_effect_utility.remove_buff_handle(context, target_entity, buff_data.remove_buff)
end

---尝试添加buff
---@private
---@param context context 战斗环境
---@param entity entity Buff持有者
---@param buff_info BTLAddBuffInfo 添加buff信息
function battle_effect_utility.try_to_adding_buff(context, entity, buff_info)
    if buff_info == nil then return end

    -- 获取Buff配置数据
    ---@type BTLBuff
    local meta_data = data_mgr.get(table_names.BTLBuff.name, buff_info.buff_id)
    if meta_data == nil then
        helper.error_skill("not found buff data, buff_id = ", buff_info.buff_id)
        return
    end

    -- 包装ident
    buff_info.buff_guid = ident.wrap(buff_info.buff_guid)
    
    -- 添加buff
    battle_effect_utility.add_buff_handle(context, entity, buff_info.buff_guid, buff_info.buff_id, meta_data.Type, meta_data.DirectorId);
    -- 触发添加Buff事件
    battle_effect_utility.trigger_buff_event_type(context, entity, buff_trigger_event_type.ADD, buff_info.buff_guid)
end

---添加buff处理
---@public
---@param context context 战斗环境
---@param entity entity Buff持有者
---@param buff_uid ident buff唯一id
---@param buff_mid string buff配置id
---@param buff_type battle_buff_type buff类型
---@param director_id string 导演id
function battle_effect_utility.add_buff_handle(context, entity, buff_uid, buff_mid, buff_type, director_id)
    ---@type buff_data_component_data[]
    local buff_list
    ---@type { value:buff_data_component_data[] } buff列表
    local comp = entity:get_component(battle_components.buff_data)
    if comp ~= nil then
        buff_list = comp.value
    else
        buff_list = {}
    end

    ---@type buff_data_component_data
    local buff_data = context:get_free_table('battle_effect_utility.add_buff_handle.buff_data')
    buff_data.running_data = context:get_free_table('battle_effect_utility.add_buff_handle.buff_data.running_data')
    buff_data.buff_uid = buff_uid
    buff_data.buff_mid = buff_mid
    buff_data.buff_type = buff_type
    if not is_nil_or_empty(director_id) then
        buff_data.buff_director_data = data_mgr.get(battle_constant.BUFF_DIRECTOR_DATA_NAME, director_id)
    end

    buff_list[#buff_list + 1] = buff_data
    -- 更新数据
    entity:replace_component(battle_components.buff_data, buff_list)
end

---移除buff处理
---@private
---@param context context 战斗环境
---@param entity entity Buff持有者
---@param buff_info BTLRemoveBuffInfo 删除buff信息
function battle_effect_utility.remove_buff_handle(context, entity, buff_info)
    if buff_info == nil then return end
    
    -- 触发移除Buff事件
    for i = 1, #buff_info.buffs do
        local buff = buff_info.buffs[i]
        -- 包装ident
        buff.buff_guid = ident.wrap(buff.buff_guid)

        ---@type buff_trigger_event_type
        local event_type
        if buff.reason == BTLBuffRemoveReason.BT_BRR_TIMEOUT or buff.reason == BTLBuffRemoveReason.BT_BRR_SKILL_EFFECT then
            event_type = buff_trigger_event_type.REMOVE
        elseif buff.reason == BTLBuffRemoveReason.BT_BRR_REPLACE or buff.reason == BTLBuffRemoveReason.BT_BRR_BATTLE_END then
            event_type = buff_trigger_event_type.REMOVE_REPLACE
        elseif buff.reason == BTLBuffRemoveReason.BT_BRR_SHIELD_BROKEN or buff.reason == BTLBuffRemoveReason.BT_BRR_ENTITY_DEAD then
            event_type = buff_trigger_event_type.REMOVE_CRUSH
        elseif buff.reason == BTLBuffRemoveReason.BT_BRR_DISPEL then
            event_type = buff_trigger_event_type.REMOVE_DISPEL
        elseif buff.reason == BTLBuffRemoveReason.BT_BRR_PURIFY then
            event_type = buff_trigger_event_type.REMOVE_PURIFY
        else
            event_type = buff_trigger_event_type.REMOVE
        end
        battle_effect_utility.trigger_buff_event_type(context, entity, event_type, buff.buff_guid)
    end
end

---触发Buff事件
---@public
---@param context context 战斗环境
---@param entity entity Buff持有者
---@param event_type buff_trigger_event_type Buff触发事件点
---@param buff_uid ident 唯一id
---@param skill_data battle_skill_data 技能数据【可能为空】
---@param perform_state buff_perform_state 表演状态【可能为空】
---@return boolean
function battle_effect_utility.trigger_buff_event_type(context, entity, event_type, buff_uid, skill_data, perform_state)
    ---@type queue buff列表
    local data_queue
    ---@type { value:queue } buff_behavior_component_data 数据队列
    local comp = entity:get_component(battle_components.buff_behavior)
    if comp ~= nil then
        data_queue = comp.value
    else
        data_queue = queue.new()
    end

    -- 将数据添加到队列中
    ---@type buff_behavior_component_data
    local behavior_data = context:get_free_table('battle_effect_utility.trigger_buff_event_type.behavior_data')
    behavior_data.buff_uid = buff_uid
    behavior_data.event_type = event_type
    behavior_data.skill_data = skill_data
    behavior_data.perform_state = perform_state

    data_queue:enqueue(behavior_data)

    -- 更新数据
    entity:replace_component(battle_components.buff_behavior, data_queue)
    
    return true
end

---前端独立触发buff，为了做表现
---@public
---@param context context
---@param skill_data battle_skill_data
---@param perform_state buff_perform_state
---@param trigger_event string
---@return boolean
function battle_effect_utility.try_to_trigger_buff(context, skill_data, perform_state, trigger_event)
    ---@type entity
    local t_entity = context:get_entity_by_primary_index(battle_components.uid, skill_data.target_uid)
    if t_entity == nil then
        helper.error_skill("no entity found to execute buff, buff_uid = ", skill_data.guid.index, '_', skill_data.guid.svrid,
                ', buff_mid = ', skill_data.mid, ', target_uid = ', skill_data.target_uid.index, '_', skill_data.target_uid.svrid)
        return false
    end

    ---@type { value:buff_data_component_data[] }
    local buff_data_comp = t_entity:get_component(battle_components.buff_data)
    if skill_data.guid.index == battle_constant.BATTLE_EFFECT_SYSTEM_2_ID then
        -- 系统2是特殊处理，此时由于是纯前端创建buff，所以需要执行完整BUFF的流程：添加、触发、移除
        local tmp_mid<const> = 'client_trigger_buff'
        battle_effect_utility.add_buff_handle(context, t_entity, skill_data.guid, tmp_mid, battle_buff_type.STATE, skill_data.mid);
        battle_effect_utility.trigger_buff_event_type(context, t_entity, trigger_event, skill_data.guid, skill_data, perform_state)
        battle_effect_utility.trigger_buff_event_type(context, t_entity, buff_trigger_event_type.REMOVE, skill_data.guid)
    elseif buff_data_comp ~= nil and #buff_data_comp.value > 0 then
        -- 触发buff事件
        battle_effect_utility.trigger_buff_event_type(context, t_entity, trigger_event, skill_data.guid, skill_data, perform_state)
    else
        -- 未找到要触发的buff数据
        helper.error_skill("buff to be triggered was not found, uid = ", skill_data.guid.index, '_', skill_data.guid.svrid,
        ', mid = ', skill_data.mid)
        return false
    end

    return true
end
--endregion

--region 死亡相关
---检测单位是否死亡并处理
---@public
---@param context context 战斗环境
---@param unit_info battle_unit_info 战斗环境
---@param death_type battle_unit_death_type 死亡类型
---@return boolean 是否死亡
function battle_effect_utility.check_unit_death_handle(context, unit_info, death_type)
    if unit_info == nil then return false end
    
    -- 如果血量小于等于0，则认为角色死亡
    if not unit_info.is_death and unit_info.hp_value <= 0 then
        -- 设置死亡标识
        unit_info.is_death = true
        unit_info.death_type = death_type or battle_unit_death_type.NORMAL
        
        -- 执行单位死亡逻辑
        local entity = context:get_entity_by_primary_index(battle_components.uid, unit_info.uid)
        if entity ~= nil then
            state_utility.try_switch_state(entity, table_names.BTLState.ids.BTLState_Death)
        end
        
        return true
    end
    
    return false
end

---检测目标单位死亡，如果死亡则执行死亡表现
---@public
---@param context context 战斗环境
---@param target_uid ident 目标uid
---@param death_type battle_unit_death_type 死亡类型
function battle_effect_utility.check_unit_death_by_uid(context, target_uid, death_type)
    local unit_info = context.database:get_unit_info_by_uid(target_uid)
    if unit_info ~= nil then
        battle_effect_utility.check_unit_death_handle(context, unit_info, death_type)
    end
end

---遍历全部单位检测是否死亡，如果死亡则执行死亡表现
---@public
---@param context context 战斗环境
---@param death_type battle_unit_death_type 死亡类型
function battle_effect_utility.check_all_units_death_handle(context, death_type)
    local unit_info_list = context.database:get_unit_info_list()
    for i = 1, #unit_info_list do
        battle_effect_utility.check_unit_death_handle(context, unit_info_list[i], death_type)
    end
end
--endregion

--region 震屏相关
---生成震屏技能行为
---@public
---@param behavior base_behavior 当前行为
---@param config_data shake_screen_config 震屏数据
function battle_effect_utility.generate_shake_screen_behavior(behavior, config_data)
    if config_data.ShakeDuration <= 0 or config_data.ShakeForce == 0 then return end

    local start_time = config_data.DelayTime
    local end_time = config_data.DelayTime + config_data.ShakeDuration

    ---@type skill_behavior_config_args
    local config_args = behavior.context:get_free_table("battle_effect_utility.generate_shake_screen_behavior")
    config_args.ShakeScreenConfigData = config_data

    behavior:generate_behavior(start_time, end_time, behavior_class_name.SHAKE_SCREEN, config_args, behavior:get_current_eid())
end
--endregion

--region 生成技能行为
---生成顿屏技能行为
---@public
---@param behavior base_behavior 当前行为
---@param config_data freeze_frame_config 数据
function battle_effect_utility.generate_freeze_battle_behavior(behavior, config_data)
    if config_data.Duration <= 0 then return end

    local start_time = config_data.DelayTime
    local end_time = config_data.DelayTime + config_data.Duration

    ---@type skill_behavior_config_args
    local config_args = behavior.context:get_free_table("battle_effect_utility.generate_freeze_battle_behavior")
    config_args.FreezeFrameConfigData = config_data

    behavior:generate_behavior(start_time, end_time, behavior_class_name.FREEZE_BATTLE, config_args, behavior:get_current_eid())
end

---生成顿帧技能行为
---@public
---@param behavior base_behavior 当前行为
---@param config_data freeze_frame_config 数据
---@param target_eid number 顿帧实体id
function battle_effect_utility.generate_freeze_frame_behavior(behavior, config_data, target_eid)
    if config_data.Duration <= 0 then return end

    local start_time = config_data.DelayTime
    local end_time = config_data.DelayTime + config_data.Duration

    ---@type skill_behavior_config_args
    local config_args = behavior.context:get_free_table("battle_effect_utility.generate_freeze_frame_behavior")
    config_args.FreezeFrameConfigData = config_data

    behavior:generate_behavior(start_time, end_time, behavior_class_name.FREEZE_FRAME, config_args, behavior:get_current_eid(),
            nil, target_eid)
end

---生成技能效果
---@public
---@param behavior base_behavior 当前行为
---@param client_data skill_effect_data 客户端数据
---@param server_data battle_effect_data 服务器数据
---@param target_eid number 顿帧实体id
---@param is_last_data boolean 是否是最后一个数据
---@param delay_time number 行为执行附加延迟时间
---@param attack_times number 攻击次数
function battle_effect_utility.generate_skill_effect_behavior(behavior, client_data, server_data, target_eid, is_last_data, 
                                                              delay_time, attack_times)
    ---@type number 延迟执行时间
    local delay = client_data.DelayTime + (delay_time or 0)
    ---@type number 持续时间
    local duration = math_max(client_data.DurationTime, client_data.ActionDelayTime)
    if client_data.CriticalHitShakeScreenConfig ~= nil then
        duration = math_max(client_data.CriticalHitShakeScreenConfig.DelayTime, duration)
    end
    for i = 1, #client_data.EffectResDataList do
        duration = math_max(client_data.EffectResDataList[i].DelayTime, duration)
    end
    for i = 1, #client_data.CriticalHitEffectResDataList do
        duration = math_max(client_data.CriticalHitEffectResDataList[i].DelayTime, duration)
    end
    if client_data.FreezeFrameConfigData ~= nil then
        for i = 1, #client_data.FreezeFrameConfigData.ConfigList do
            duration = math_max(client_data.FreezeFrameConfigData.ConfigList[i].DelayTime, duration)
        end
    end
  
    if duration > 0 then
        duration = delay + duration
    end

    ---@type skill_behavior_config_args
    local config_args = behavior.context:get_free_table("battle_effect_utility.generate_skill_effect_behavior.config_args")
    config_args.SkillEffectData = client_data

    ---@class skill_behavior_additional_data
    ---@field server_data battle_effect_data
    ---@field is_last_data boolean
    ---@field attack_times number
    local additional_data = behavior.context:get_free_table("battle_effect_utility.generate_skill_effect_behavior.additional_data")
    additional_data.server_data = server_data
    additional_data.is_last_data = is_last_data
    additional_data.attack_times = attack_times
    
    behavior:generate_behavior(delay, duration, behavior_class_name.SKILL_EFFECT, config_args, target_eid, nil, 
            nil, additional_data)
end

---生成多个技能效果行为
---@public
---@param behavior base_behavior 当前行为
---@param client_list skill_effect_data[] 攻击帧数据列表
---@param server_data battle_effect_data 服务器数据
---@param is_last_data boolean 是否是服务器最后一个数据
---@param delay_time number 行为执行附加延迟时间
---@param attack_times number 攻击次数
function battle_effect_utility.generate_multi_skill_effect_behavior(behavior, client_list, server_data, is_last_data, delay_time,
                                                                    attack_times)
    ---@type battle_effect_data
    local tmp_data = battle_effect_utility.get_cleanly_skill_effect_data(table_deep_copy(server_data))

    local data_count = #client_list
    for i = 1, data_count do
        local client_data = client_list[i]

        -- 分割技能效果
        local hp_config = client_data.SkillEffectHpData
        local is_first = i == 1
        local is_end = i == data_count
        ---@type battle_effect_data
        local part_data = battle_effect_utility.split_skill_effect_data(server_data, hp_config, is_first, is_end,
                data_count > 1, tmp_data)

        ---@type entity 执行效果的实体
        local target_entity = behavior.context:get_entity_by_primary_index(battle_components.uid, part_data.effect.target_id)
        if target_entity == nil then
            behavior:log_error("invalid target_id in skill_effect_data, target_id = ", helper.to_string(part_data.effect.target_id))
        end

        ---@type boolean 是否是最后一击
        local is_last_attack = is_last_data and is_end

        -- 执行技能效果行为
        battle_effect_utility.generate_skill_effect_behavior(behavior, client_data, part_data, target_entity.eid, is_last_attack, 
                delay_time, attack_times * data_count)
    end
end
--endregion

--region 分割技能效果
---分割技能效果数据
---@public
---@param server_data battle_effect_data 待分割服务器数据
---@param hp_config skill_effect_hp_data 血量配置数据
---@param is_first boolean 是否值第一个数据
---@param is_last boolean 是否是最后一个数据
---@param is_multiple boolean 是多个数据吗
---@param tmp_server_data battle_effect_data 用于记录已扣除数值
---@return battle_effect_data
function battle_effect_utility.split_skill_effect_data(server_data, hp_config, is_first, is_last, is_multiple, tmp_server_data)
    ---@type battle_effect_data
    local new_data = table_deep_copy(server_data)
    
    local is_hurt_effect = hp_config ~= nil
    local is_damage = new_data.effect.damage ~= nil
    local is_heal = new_data.effect.heal ~= nil
    -- 伤害或治疗才能被分割
    if not is_hurt_effect or (not is_damage and not is_heal) then return new_data end

    ---@type number 百分比
    local ratio = hp_config.DeductRatio / 100
    
    if is_damage then
        -- 伤害
        if not is_last then
            new_data.effect.damage.display_val = math_floor(new_data.effect.damage.display_val * ratio)
            new_data.effect.damage.hp_change = math_floor(new_data.effect.damage.hp_change * ratio)
            -- 记录
            tmp_server_data.effect.damage.display_val = tmp_server_data.effect.damage.display_val + new_data.effect.damage.display_val
            tmp_server_data.effect.damage.hp_change = tmp_server_data.effect.damage.hp_change + new_data.effect.damage.hp_change
        else
            new_data.effect.damage.display_val = new_data.effect.damage.display_val - tmp_server_data.effect.damage.display_val
            new_data.effect.damage.hp_change = new_data.effect.damage.hp_change - tmp_server_data.effect.damage.hp_change
        end

        -- 护盾
        local shield_change = new_data.effect.damage.shield_change
        local tmp_shield_change = tmp_server_data.effect.damage.shield_change
        if shield_change ~= nil then
            if not is_last then
                shield_change.shield_change = math_floor(shield_change.shield_change * ratio)
                tmp_shield_change.shield_change = math_floor(tmp_shield_change.shield_change * ratio)
            else
                shield_change.shield_change = shield_change.shield_change - tmp_shield_change.shield_change
            end
        end
    elseif is_heal then
        -- 治疗
        if not is_last then
            new_data.effect.heal.display_val = math_floor(new_data.effect.heal.display_val * ratio)
            new_data.effect.heal.hp_change = math_floor(new_data.effect.heal.hp_change * ratio)
            -- 记录
            tmp_server_data.effect.heal.display_val = tmp_server_data.effect.heal.display_val + new_data.effect.heal.display_val
            tmp_server_data.effect.heal.hp_change = tmp_server_data.effect.heal.hp_change + new_data.effect.heal.hp_change
        else
            new_data.effect.heal.display_val = new_data.effect.heal.display_val - tmp_server_data.effect.heal.display_val
            new_data.effect.heal.hp_change = new_data.effect.heal.hp_change - tmp_server_data.effect.heal.hp_change
        end
    end
    
    if is_multiple then
        if is_first then
            -- 第一个效果数据，保留前置效果
            helper.clear_array(new_data.post_idx_list)
        elseif is_last then
            -- 最后的效果数据，保留后置效果
            helper.clear_array(new_data.pre_idx_list)
        else
            -- 中间部分的效果数据，没有前后置效果
            helper.clear_array(new_data.pre_idx_list)
            helper.clear_array(new_data.post_idx_list)
        end
    end

    return new_data
end

---获取一个干净技能效果数据，用于计算血量
---@public
---@param effect_data battle_effect_data 
---@return battle_effect_data 
function battle_effect_utility.get_cleanly_skill_effect_data(effect_data)
    local is_damage = effect_data.effect.damage ~= nil
    local is_heal = effect_data.effect.heal ~= nil
    -- 伤害或治疗才能被分割
    if not is_damage and not is_heal then return effect_data end

    if is_damage then
        -- 伤害
        effect_data.effect.damage.display_val = 0
        effect_data.effect.damage.hp_change = 0

        -- 护盾
        local shield_change = effect_data.effect.damage.shield_change
        if shield_change ~= nil then
            shield_change.shield_change = 0
        end
    elseif is_heal then
        -- 治疗
        effect_data.effect.heal.display_val = 0
        effect_data.effect.heal.hp_change = 0
    end
    
    return effect_data
end
--endregion

--region 最后一击
---检测是否要执行最后一击
---@public
---@param context context
---@return boolean
function battle_effect_utility.check_battle_final_attack(context)
    -- 是否跳过最后一击
    local skip_final_attack = context.database:check_skip_final_attack()
    if skip_final_attack then return false end

    -- 检测检测过最后一击
    local has_final_attack = context.database:get_has_final_attack()
    if has_final_attack then return true end

    -- 检测是否有战斗结果数据
    local result_data = context.database:get_battle_result_data()
    if result_data == nil then return false end

    -- 非击杀类不表现最后一击
    if result_data.end_by_kill ~= 1 then return end

    ---@type battle_unit_info
    local target_info = context.database:get_unit_info_by_uid(result_data.victory_entity_id)
    if target_info == nil then return false end

    ---@type battle_unit_info[]
    local unit_info_list = context:get_free_table("behavior_battle_final_attack.unit_info_list")
    context.database:get_unit_info_list_by_condition(unit_info_list, function(info)
        return info.team_type ~= target_info.team_type
    end)

    ---@type boolean 是否是最后一击
    local is_final_attack = true
    local unit_count = #unit_info_list
    if unit_count > 0 then
        for i = 1, unit_count do
            local unit_info = unit_info_list[i]
            if unit_info.hp_value > 0 then
                is_final_attack = false
                break
            end
        end
    else
        is_final_attack = false
    end
    context:recycle_free_table(unit_info_list)
    if not is_final_attack then return false end

    -- 设置最后一击标识，避免重复执行
    context.database:set_has_final_attack(true)
    
    return true
end

---执行最后技表现
---@public
---@param context context
function battle_effect_utility.execute_battle_final_attack(context)
    if not battle_effect_utility.check_battle_final_attack(context) then return end
    
    -- 最后一击处理
    ---@type entity
    local skill_entity = context:get_unique_component(battle_components.skill_entity)
    if not skill_entity:has_component(battle_components.final_attack) then
        skill_entity:add_component(battle_components.final_attack)
    end
end
--endregion

return battle_effect_utility