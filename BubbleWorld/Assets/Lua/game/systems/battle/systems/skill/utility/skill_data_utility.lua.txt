---
--- Generated by wuhaijun
--- File name : skill_data_utility.lua.txt
--- DateTime : 2022/03/12
--- Description : 
---

---@type battle_helper
local helper = battle_helper
local data_mgr = data
local table_names = tables
local table_remove = table.remove
---@type enum_battle
local enum_battle = enum.battle
local skill_data_type = enum_battle.skill_data_type
local buff_trigger_event_type = enum_battle.buff_trigger_event_type
local buff_perform_state = enum_battle.buff_perform_state
local is_nil_or_empty = string.is_nil_or_empty

---@type state_utility
local state_utility = require(helper.path.battle_fsm .. 'state_utility')
---@type ident
local ident = require(helper.path.battle_utils .. 'ident')
---@type battle_effect_utility
local battle_effect_utility = require(helper.path.battle_skill .. 'utility/battle_effect_utility')
---@type battle_constant
local battle_constant = require(helper.path.battle_utils .. 'battle_constant')
---@type battle_components
local battle_components = require(helper.path.battle_components)

---@class skill_data_utility
local skill_data_utility = { cname = 'skill_data_utility' }

--region 生成技能数据
---检测是否有新技能数据根据索引区间，并添加到堆栈中
---@public
---@param context context
---@param idx_list number[] 索引值列表
---@param effect_mid string 技能效果id
---@param queue_stack stack 技能数据堆栈
function skill_data_utility.check_new_skill_stack_data(context, idx_list, effect_mid, queue_stack)
    ---@type entity
    local skill_entity
    ---@type skill_entity_component_data
    local effects_comp
    skill_entity, effects_comp = context:get_unique_component(battle_components.skill_entity)

    -- 根据索引列表，获取下一个效果数据组
    ---@type queue battle_skill_data 队列
    local skill_queue = skill_data_utility.get_skill_data_queue(context, effects_comp.effect_list, idx_list, effect_mid)
    if skill_queue:count() > 0 then
        queue_stack:push(skill_queue)
    else
        context:recycle_free_queue(skill_queue)
        if not helper.is_debug then
            helper.error_skill('failed to parse the effect_list, effect_mid = ', effect_mid)
        else
            local rapid = require 'rapidjson'
            helper.error_skill('failed to parse the effect_list, effect_mid = ', effect_mid,
                    ', idx_list = ', table.concat(idx_list, ', '),
                    ', effect_list = ', rapid.encode(effects_comp.effect_list))
        end
    end
end

---获取技能数据队列
---@private
---@param context context
---@param server_effect_list BTLEffect[] 服务器效果数据列表
---@param idx_list number[] 索引值列表
---@param effect_mid string 来源mid
---@return queue battle_skill_data 队列
function skill_data_utility.get_skill_data_queue(context, server_effect_list, idx_list, effect_mid)
    ---@type battle_effect_data[][] 临时技能数据列表
    local tmp_skill_list = context:get_free_table("get_skill_data_queue.tmp_skill_list")
    ---@type number[] 临时索引列表
    local tmp_pre_idx_list = context:get_free_table("get_skill_data_queue.tmp_pre_idx_list")
    ---@type number[] 临时索引列表
    local tmp_post_idx_list = context:get_free_table("get_skill_data_queue.tmp_post_idx_list")
    ---@type number 索引个数
    local idx_list_count = #idx_list
    ---@type string 系统1的id
    local system_1_id = context.database:get_battle_uid()
    ---@type string 系统2的id
    local system_2_id = data_mgr.get(table_names.ConstComm.name, table_names.ConstComm.ids.KW_DOT_COMBINE_ID, table_names.ConstComm.properties.String)
  
    -- 包装GUID
    for i = idx_list_count, 1, -1 do
        local cur_effect = server_effect_list[i]
        if cur_effect ~= nil then
            cur_effect.guid = ident.wrap(cur_effect.guid)
            cur_effect.caster_id = ident.wrap(cur_effect.caster_id)
            cur_effect.target_id = ident.wrap(cur_effect.target_id)
        else
            helper.error_skill('not found effect in effect_list, i = ', i, ', list count = ', #server_effect_list)
            table_remove(server_effect_list, i)
        end
    end

    local tmp_i = 0
    while tmp_i < idx_list_count do
        tmp_i = tmp_i + 1
        ---@type number 索引值
        local idx = idx_list[tmp_i]
        ---@type BTLEffect
        local cur_effect = server_effect_list[idx]
        ---@type string 当前效果元表id，buff或技能表id
        local cur_mid = cur_effect.mid
        helper.assert_skill(cur_mid ~= nil, "Invalid BTLEffect.mid")

        -- 找出指定来源的效果数据
        if cur_effect.source_mid == effect_mid then
            -- 相同mid的效果数据是同一个技能触发的，将放到同一个数组中
            ---@type battle_effect_data[] 技能效果数据列表
            local skill_effect_list
            -- 查找存储该mid的效果数据列表
            for j = 1, #tmp_skill_list do
                local tmp_skill = tmp_skill_list[j]
                if #tmp_skill > 0 then
                    local tmp_btl_effect = tmp_skill[1].effect
                    if tmp_btl_effect.mid ~= system_1_id and tmp_btl_effect.mid ~= system_2_id and
                            tmp_btl_effect.mid == cur_mid and tmp_btl_effect.guid == cur_effect.guid then
                        skill_effect_list = tmp_skill
                        break
                    end
                end
            end
            -- 没有找到效果数据列表，则主动创建一个
            if skill_effect_list == nil then
                skill_effect_list = context:get_free_table("get_skill_data_queue.tmp_effects_list.skill_effect_list")
                tmp_skill_list[#tmp_skill_list + 1] = skill_effect_list
            end

            -- 生成战斗效果数据
            ---@type battle_effect_data
            local effect_data = context:get_free_table("get_skill_data_queue.effect_data")
            effect_data.effect = cur_effect

            -- 设置待触发的前置效果索引值列表
            local tmp_idx_list_count = #tmp_pre_idx_list
            if tmp_idx_list_count > 0 then
                ---@type number[]
                local pre_idx_list = context:get_free_table("get_skill_data_queue.effect_data.pre_idx_list")
                for j = 1, tmp_idx_list_count do
                    local tmp_index = tmp_pre_idx_list[j]
                    if server_effect_list[tmp_index].source_mid == cur_effect.mid then
                        pre_idx_list[#pre_idx_list + 1] = tmp_index
                    end
                    tmp_pre_idx_list[j] = nil
                end
                if #pre_idx_list > 0 then
                    effect_data.pre_idx_list = pre_idx_list
                else
                    context:recycle_free_table(pre_idx_list)
                end
            end

            -- 查找并设置待触发的后置效果索引值列表
            for j = idx + 1, idx_list[idx_list_count] do
                local after_effect = server_effect_list[j]
                if after_effect.source_mid == cur_mid then
                    tmp_post_idx_list[#tmp_post_idx_list + 1] = j
                    tmp_i = tmp_i + 1
                else
                    break
                end
            end
            tmp_idx_list_count = #tmp_post_idx_list
            if tmp_idx_list_count > 0 then
                local post_idx_list = context:get_free_table("get_skill_data_queue.effect_data.post_idx_list")
                for j = 1, tmp_idx_list_count do
                    post_idx_list[j] = tmp_post_idx_list[j]
                    tmp_post_idx_list[j] = nil
                end
                effect_data.post_idx_list = post_idx_list
            end

            -- 将战斗效果数据添加到列表中
            skill_effect_list[#skill_effect_list + 1] = effect_data
        else
            -- 当来源不一致，说明当前不是该效果执行的正确时机，将该效果索引记录到数组中，等待正确时机再执行它
            tmp_pre_idx_list[#tmp_pre_idx_list + 1] = idx
        end
    end

    -- 生成效果数据组栈
    ---@type queue battle_skill_data[]
    local skill_queue = context:get_free_queue("get_skill_data_queue.skill_queue")
    for i = 1, #tmp_skill_list do
        ---@type battle_effect_data[] 效果数据列表
        local effect_data_list = tmp_skill_list[i]
        -- 技能数据
        skill_queue:enqueue(skill_data_utility.generate_skill_data(context, effect_data_list))
        
        -- 回收临时容器
        context:recycle_free_table(effect_data_list)
    end

    -- 回收临时容器
    context:recycle_free_table(tmp_skill_list)
    context:recycle_free_table(tmp_pre_idx_list)
    context:recycle_free_table(tmp_post_idx_list)

    return skill_queue
end

---生成效果数据组
---@private
---@param context context
---@param effect_data_list battle_effect_data[]
---@return battle_skill_data
function skill_data_utility.generate_skill_data(context, effect_data_list)
    -- 取得第1个效果数据，它记录了施法者和技能目标信息
    local first_effect_data = effect_data_list[1]

    ---@type string 系统2的id
    local system_2_id = data_mgr.get(table_names.ConstComm.name, table_names.ConstComm.ids.KW_DOT_COMBINE_ID, table_names.ConstComm.properties.String)

    -- 生成技能数据
    ---@type battle_skill_data
    local skill_data = context:get_free_battle_skill_data()
    skill_data.mid = first_effect_data.effect.mid
    if first_effect_data.effect.guid ~= nil then
        skill_data.guid = first_effect_data.effect.guid
    else
        skill_data.guid = ident.new(0, 0) 
    end
    skill_data.caster_uid = first_effect_data.effect.caster_id
    skill_data.target_uid = first_effect_data.effect.target_id

    -- 设置客户端效果队列
    for i = 1, #effect_data_list do
        skill_data.effect_list[#skill_data.effect_list + 1] = effect_data_list[i]
    end

    -- 设置数据类型，顺便获取相关配置数据
    if data_mgr.is_name(skill_data.mid, table_names.BTLSkill.name) then
 
        ---@type BTLSkill
        local skill_meta_data = data_mgr.get(table_names.BTLSkill.name, skill_data.mid)
        if skill_meta_data ~= nil and #skill_meta_data.DirectorId > 0 then
            -- 技能类型
            skill_data.type = skill_data_type.SKILL
            
            -- 获取技能导演数据
            local director_flag = first_effect_data.effect._director_flag
            ---@type string
            local director_mid = skill_data_utility.get_director_id_by_flag(skill_meta_data.DirectorId, director_flag)
            ---@type skill_director_data
            local director_data = data_mgr.get(battle_constant.SKILL_DIRECTOR_DATA_NAME, director_mid)
            helper.assert_round(director_data ~= nil, "not found skill's Director data, DirectorId = ", director_mid,
                    ", skill_mid = ", skill_data.mid, ', director_flag = ', director_flag)
            skill_data.skill_director_data = director_data

            ---@type boolean 是否单体攻击
            local is_single_attack = skill_meta_data.TargetNumberData == 1
            if is_single_attack then
                -- 特殊判断，策划设计中，某些单体攻击实际上想表现为群体，根据类型再次判断
                local const = table_names.ConstClient
                ---@type number[]
                local group_attack_type_list = data_mgr.get(const.name, const.ids.KW_SINGLE_TO_AREA, const.properties.Array_Int)
                for i = 1, #group_attack_type_list do
                    for j = 1, #effect_data_list do
                        if effect_data_list[j].effect.type == group_attack_type_list[i] then
                            is_single_attack = false
                            break
                        end
                    end
                    if not is_single_attack then
                        break
                    end
                end
            end
            skill_data.is_single_attack = is_single_attack
            
        else
            -- 没有配置导演id的技能当做系统类型处理
            skill_data.type = skill_data_type.SYSTEM
        end
        
    elseif data_mgr.is_name(skill_data.mid, table_names.BTLBuff.name) then
        -- Buff
        skill_data.type = skill_data_type.BUFF
        ---@type BTLBuff
        local buff_meta_data = data_mgr.get(table_names.BTLBuff.name, skill_data.mid)
        helper.assert_round(buff_meta_data ~= nil, "buff config data not found, buffId = ", skill_data.mid)
        if buff_meta_data ~= nil and not is_nil_or_empty(buff_meta_data.DirectorId) then
            skill_data.buff_director_data = data_mgr.get(battle_constant.BUFF_DIRECTOR_DATA_NAME, buff_meta_data.DirectorId)
        end
        
    elseif skill_data.mid == system_2_id then
        -- 系统2当做buff处理
        skill_data.type = skill_data_type.BUFF
        skill_data.buff_director_data = data_mgr.get(battle_constant.BUFF_DIRECTOR_DATA_NAME, "BuffDirector_Common_Buff_Icon_buff_00")
        skill_data.guid.svrid = battle_constant.BATTLE_EFFECT_SYSTEM_2_ID
        skill_data.guid.index = battle_constant.BATTLE_EFFECT_SYSTEM_2_ID
        
    else
        -- 系统1
        skill_data.type = skill_data_type.SYSTEM
        skill_data.guid.svrid = battle_constant.BATTLE_EFFECT_SYSTEM_1_ID
        skill_data.guid.index = battle_constant.BATTLE_EFFECT_SYSTEM_1_ID
        
    end
    
    return skill_data
end

---获取导演id根据标记
---@private
---@param director_arr array2_string[] 战斗环境
---@param flag string 标识
---@return string
function skill_data_utility.get_director_id_by_flag(director_arr, flag)
    ---@type string 导演id
    local director_mid
    for i = 1, #director_arr do
        local str_arr = director_arr[i].Array
        if str_arr[2] == nil or str_arr[2] == flag then
            director_mid = str_arr[1]
            break
        end
    end
    
    return director_mid
end
--endregion

--region 执行技能数据
---处理被触发的技能数据
---@public
---@param context context 战斗环境
---@param idx_list number[] 索引区间
---@param effect_mid string 技能效果id
function skill_data_utility.process_trigger_skill_data(context, idx_list, effect_mid)
    ---@type stack queue<battle_skill_data>技能数据队列
    local queue_stack = context:get_free_stack("skill_data_utility.process_trigger_skill_data")
    -- 根据索引列表生成新的技能数据
    skill_data_utility.check_new_skill_stack_data(context, idx_list, effect_mid, queue_stack)
    
    -- 尝试执行新的技能数据
    local is_run = true
    while is_run do
        if not queue_stack:is_empty() then
            if not skill_data_utility.try_to_execute_skill_queue(context, queue_stack:peek(), true) then
                context:recycle_free_queue(queue_stack:pop())
            end
        else
            is_run = false
            break
        end
    end

    -- 回收容器
    context:recycle_free_stack(queue_stack)
end

---尝试执行技能队列数据
---@private
---@param context context 战斗环境
---@param data_queue queue battle_skill_data 队列
---@param is_trigger_skill boolean 是否是执行被触发的技能（前置或后置技能效果）
---@return boolean
function skill_data_utility.try_to_execute_skill_queue(context, data_queue, is_trigger_skill)
    ---@type boolean 执行结果
    local result = true

    -- 根据当前索引值获取要执行的数据
    ---@type battle_skill_data
    local skill_data = data_queue:dequeue()
    if skill_data ~= nil then
        helper.log_skill("try to execute skill, mid = ", skill_data.mid, ", type = ", helper.get_enum_name(skill_data_type, skill_data.type), 
                ', guid = ', helper.to_string(skill_data.guid))
        
        -- 应用技能效果数据
        if not is_trigger_skill then
            skill_data_utility.apply_server_effect_to_local(context, skill_data.effect_list)
        end

        -- 增加正在执行的技能
        skill_data_utility.set_executed_skill_record(context, skill_data, true)

        -- 根据类型执行对应逻辑
        if skill_data.type == skill_data_type.SKILL then
            -- 尝试执行技能数据
            result = skill_data_utility.try_execute_skill_data(context, skill_data, is_trigger_skill)
            if not result then
                helper.error_skill("try to process skill data failed, mid = ", skill_data.mid, ", caster_id = ", helper.to_string(skill_data.caster_uid))
            end
        elseif skill_data.type == skill_data_type.BUFF then
            -- 尝试执行Buff数据
            result = skill_data_utility.try_execute_buff_data(context, skill_data, is_trigger_skill)
            if not result then
                helper.error_skill("try to process buff data failed, mid = ", skill_data.mid, ", caster_id = ", helper.to_string(skill_data.caster_uid))
            end
        elseif skill_data.type == skill_data_type.SYSTEM then
            -- 尝试执行系统数据
            result = skill_data_utility.try_execute_system_data(context, skill_data, is_trigger_skill)
            if not result then
                helper.error_skill("try to process system data failed, mid = ", skill_data.mid, ", caster_id = ", helper.to_string(skill_data.caster_uid))
            end
        else
            result = false
            helper.error_skill("skill data type error, mid = ", skill_data.mid, ", type = ", skill_data.type)
        end

        if not result then
            -- 执行失败，移除执行的技能
            skill_data_utility.set_executed_skill_record(context, skill_data)
            -- 回收技能数据
            skill_data_utility.recycle_battle_skill_data(context, skill_data)
        end
    else
        result = false
    end

    return result
end

---尝试执行技能数据
---@private
---@param context context 战斗环境
---@param skill_data battle_skill_data
---@param _ boolean 是否是前置技能数据
---@return boolean
function skill_data_utility.try_execute_skill_data(context, skill_data, _)
    ---@type entity 获取技能施法者
    local caster_entity = context:get_entity_by_primary_index(battle_components.uid, skill_data.caster_uid)
    if caster_entity == nil then
        helper.error_skill("execute skill data error, invalid caster_entity, skill_mid = ", skill_data.mid)
        return false
    end

    -- 尝试进入技能状态
    local is_entered, cur_state = state_utility.try_switch_state(caster_entity, table_names.BTLState.ids.BTLState_Skill)
    if not is_entered then
        helper.error_skill("failed to enter Skill_State, cur_state = ", cur_state, ', skill_mid = ', skill_data.mid)
        return false
    end

    helper.log_skill("try execute skill, skill_mid = ", skill_data.mid, ', director_mid = ', skill_data.skill_director_data.Id)

    -- 技能模板配置id列表
    ---@type queue skill_running_data
    local running_queue = context:get_free_queue('try_execute_skill_data.running_queue')
    running_queue:enqueue(context:get_skill_running_data(battle_constant.SKILL_BEHAVIOR_DEFAULT_ID))

    -- 执行技能流程
    caster_entity:replace_component(battle_components.skill_running, skill_data, running_queue)

    return true
end

---尝试执行buff数据
---@private
---@param context context 战斗环境
---@param skill_data battle_skill_data
---@param is_parallel boolean 表演是并行的吗
---@return boolean
function skill_data_utility.try_execute_buff_data(context, skill_data, is_parallel)
    -- 满足如下条件时，则表演完毕后再应用服务器数据
    -- 1. 配置了渲染层数据，并且有表演时间
    -- 2. 是主动buff，而非别的技能触发
    ---@type number 表演状态：0=没有表演，1=有表演，2=没表演但有最后一击
    local perform_state = buff_perform_state.NO_PERFORM
    local trigger_event = buff_trigger_event_type.TRIGGER
    if skill_data.buff_director_data ~= nil then
        local event_data = skill_data.buff_director_data.Map[trigger_event]
        if (event_data ~= nil) and (#event_data.EventDataList > 0) and (event_data.EventDataList[1].ShowTimeType > 0) and (not is_parallel) then
            perform_state = buff_perform_state.HAS_PERFORM
        end
    end
    
    -- 如果没有表演，当有最后一击时，也延迟执行下一个步骤
    if perform_state == buff_perform_state.NO_PERFORM and battle_effect_utility.check_battle_final_attack(context) then
        perform_state = buff_perform_state.FINAL_ATTACK
    end
   
    helper.log_skill("try execute buff data, buff_uid = ", skill_data.guid.index, '_', skill_data.guid.svrid, ', mid = ', skill_data.mid,
            ', perform_state = ', perform_state)

    -- 尝试触发buff
    if not battle_effect_utility.try_to_trigger_buff(context, skill_data, perform_state, trigger_event) then
        -- 未正常执行buff，当做没有表演处理
        perform_state = buff_perform_state.NO_PERFORM
    end
   
    -- 没有表演，则直接应用数据
    if perform_state == buff_perform_state.NO_PERFORM then
        local effect_count = #skill_data.effect_list
        for i = 1, effect_count do
            ---@type battle_effect_data
            local server_data = skill_data.effect_list[i]
            -- 显示技能效果处理
            skill_data_utility.show_skill_effect_handle(context, server_data)
            -- 检测目标单位死亡
            if not is_parallel then
                battle_effect_utility.check_unit_death_by_uid(context, server_data.effect.target_id)
            end
        end

        if not is_parallel then
            -- 触发下一个技能数据
            skill_data_utility.trigger_next_skill_handle(context, skill_data)
        else
            -- 减少正在执行的技能数量
            skill_data_utility.set_executed_skill_record(context, skill_data)
            -- 回收技能数据
            skill_data_utility.recycle_battle_skill_data(context, skill_data)
        end
    end

    return true
end

---尝试执行系统数据
---@private
---@param context context 战斗环境
---@param skill_data battle_skill_data
---@param is_trigger_skill boolean 是否是被触发系统
---@return boolean
function skill_data_utility.try_execute_system_data(context, skill_data, is_trigger_skill)
    helper.log_skill("try execute system data, mid = ", skill_data.mid, ', is_trigger_skill = ', is_trigger_skill)

    -- 显示技能效果处理
    for i = 1, #skill_data.effect_list do
        skill_data_utility.show_skill_effect_handle(context, skill_data.effect_list[i])
    end

    if not is_trigger_skill then
        -- 遍历所有单位，检测是否有死亡
        battle_effect_utility.check_all_units_death_handle(context)
        -- 触发下一个技能数据
        skill_data_utility.trigger_next_skill_handle(context, skill_data)
    else
        -- 减少正在执行的技能数量
        skill_data_utility.set_executed_skill_record(context, skill_data)
        -- 回收技能数据
        skill_data_utility.recycle_battle_skill_data(context, skill_data)
    end
   
    return true
end

---触发下一个技能逻辑
---@private
---@param context context
---@param skill_data battle_skill_data
function skill_data_utility.trigger_next_skill_handle(context, skill_data)
    -- 减少正在执行的技能
    skill_data_utility.set_executed_skill_record(context, skill_data)
    
    -- 回收技能数据
    skill_data_utility.recycle_battle_skill_data(context, skill_data)

    -- 触发skill_handler
    ---@type entity
    local skill_entity, _ = context:get_unique_component(battle_components.skill_entity)
    ---@type skill_handler_component_data
    local handler_comp = skill_entity:get_component(battle_components.skill_handler)
    skill_entity:replace_component(battle_components.skill_handler, handler_comp.queue_stack, handler_comp.skill_hash)
end

---设置正在执行的技能的记录
---@private
---@param context context
---@param skill_data battle_skill_data
---@param is_set boolean
function skill_data_utility.set_executed_skill_record(context, skill_data, is_set)
    -- 触发skill_handler
    ---@type entity
    local skill_entity, _ = context:get_unique_component(battle_components.skill_entity)
    ---@type skill_handler_component_data
    local skill_handler_comp = skill_entity:get_component(battle_components.skill_handler)
    if is_set then
        if not skill_handler_comp.skill_hash:add(skill_data) then
            helper.error_skill("skill has already been executed, why are the records repeated, skill_uid = ", helper.to_string(skill_data.guid))
        end
    else
        skill_handler_comp.skill_hash:remove(skill_data)
    end
end

---回收技能数据
---@public
---@param context context
---@param skill_data battle_skill_data
function skill_data_utility.recycle_battle_skill_data(context, skill_data)
    if skill_data == nil then return end

    if skill_data.effect_list ~= nil then
        for i = 1, #skill_data.effect_list do
            local server_data = skill_data.effect_list[i]
            context:recycle_free_table(server_data.pre_idx_list)
            context:recycle_free_table(server_data.post_idx_list)
            context:recycle_free_table(server_data)
        end
    end
    context:recycle_battle_skill_data(skill_data)
end

--endregion

---应用服务器技能效果数据到本地
---@public
---@param context context 战斗环境
---@param server_list battle_effect_data[] 服务器技能效果数据
function skill_data_utility.apply_server_effect_to_local(context, server_list)
    for i = 1, #server_list do
        ---@type battle_effect_data
        local server_data = server_list[i]
        
        --if not helper.is_debug then
        --    helper.log_skill('set BTLEffect, has_effect_data = ', server_data ~= nil)
        --else
        --    local rapid = require 'rapidjson'
        --    helper.log_skill('set BTLEffect, cur_effect = ', rapid.encode(server_data))
        --end
        
        -- 处理前置效果
        skill_data_utility.apply_trigger_effect_to_local(context, server_data.pre_idx_list, server_data.effect.mid)
        
        -- 1. 更新实体
        battle_effect_utility.update_entities_handle(context, server_data.effect.entities)
        
        -- 处理后置效果
        skill_data_utility.apply_trigger_effect_to_local(context, server_data.post_idx_list, server_data.effect.mid)
    end
end

---应用触发技能效果数据到本地
---@private
---@param context context 战斗环境
---@param idx_list number[] 索引列表
---@param target_mid string 目标id
function skill_data_utility.apply_trigger_effect_to_local(context, idx_list, target_mid)
    if idx_list == nil or #idx_list == 0 then return end
    
    ---@type stack queue<battle_skill_data>技能数据队列
    local queue_stack = context:get_free_stack("skill_data_utility.apply_trigger_effect_to_local")

    skill_data_utility.check_new_skill_stack_data(context, idx_list, target_mid, queue_stack)

    while not queue_stack:is_empty() do
        ---@type queue
        local queue_data = queue_stack:pop()
        while not queue_data:is_empty() do
            ---@type battle_skill_data
            local skill_data = queue_data:dequeue()
            skill_data_utility.apply_server_effect_to_local(context, skill_data.effect_list)
            
            skill_data_utility.recycle_battle_skill_data(context, skill_data)
        end
        
        context:recycle_free_queue(queue_data)
    end

    -- 回收栈
    context:recycle_free_stack(queue_stack)
end

---展示技能效果
---@public
---@param context context 战斗环境
---@param server_data battle_effect_data 服务器技能效果数据
---@param attack_times number 多段攻击次数
---@param is_last_data boolean 是否是最后的数据
function skill_data_utility.show_skill_effect_handle(context, server_data, attack_times, is_last_data)
    if helper.is_debug then
        local rapid = require 'rapidjson'
        helper.log_skill("show skill effect, attack_times = ", attack_times, ", server_data = ", rapid.encode(server_data))
    end

    ---@type BTLEffect 技能效果数据列表
    local btl_effect = server_data.effect
    local pre_idx_list = server_data.pre_idx_list
    local post_idx_list = server_data.post_idx_list

    -- 处理前置效果
    if pre_idx_list ~= nil and #pre_idx_list > 0 then
        skill_data_utility.process_trigger_skill_data(context, pre_idx_list, btl_effect.mid)
    end

    -- 获取当前阶段所有技能效果
    ---@type skill_entity_component_data
    local _, effects_comp = context:get_unique_component(battle_components.skill_entity)
    -- 向UI同步技能效果数据
    context.message:send_show_skill_damage(btl_effect, effects_comp.effect_list, attack_times)

    -- 1. Buff
    battle_effect_utility.skill_buff_data_handle(context, btl_effect)
    -- 2. 召唤
    battle_effect_utility.skill_summon_data_handle(context, btl_effect)
    -- 3. 变身
    battle_effect_utility.skill_transform_data_handle(context, btl_effect)
    -- 4. 复活
    battle_effect_utility.skill_revive_data_handle(context, btl_effect)
    -- 5. 触发器
    battle_effect_utility.trigger_data_handle(context, btl_effect)

    --检测是否最后一击
    if is_last_data then
        battle_effect_utility.execute_battle_final_attack(context)
    end
    -- 处理后置效果
    if post_idx_list ~= nil and #post_idx_list > 0 then
        skill_data_utility.process_trigger_skill_data(context, post_idx_list, btl_effect.mid)
    end
end

return skill_data_utility