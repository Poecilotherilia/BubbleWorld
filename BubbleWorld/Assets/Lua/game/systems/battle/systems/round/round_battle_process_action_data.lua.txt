---
--- Generated by wuhaijun
--- File name : round_battle_process_action_data.lua.txt
--- DateTime : 2021/12/29
--- Description : 处理行动数据
---

---@type battle_helper
local helper = battle_helper
local BTLStage = enum.proto.BTLStage
local data_mgr = data
local table_names = tables

---@type battle_utility
local battle_utility = require(helper.path.battle_utils .. 'battle_utility')
local stack = require 'framework/basic/stack'
local hashset = require 'framework/basic/hashset'
---@type battle_effect_utility
local battle_effect_utility = require(helper.path.battle_skill .. 'utility/battle_effect_utility')
---@type skill_data_utility
local skill_data_utility = require(helper.path.battle_skill .. 'utility/skill_data_utility')
---@type battle_components
local battle_components = require(helper.path.battle_components)
---@type matchers
local matchers = require(helper.path.ecs .. 'matchers')
---@type reactive_system
local super = require(helper.path.ecs .. 'reactive_system')

---@class round_battle_process_action_data : reactive_system
local round_battle_process_action_data = class("round_battle_process_action_data", super)

---构造函数
---@protected
---@param context context
function round_battle_process_action_data:ctor(context)
    super.ctor(self, context)

    ---延迟执行技能回调
    ---@private
    ---@type fun(...)
    self.delay_execute_skill_callback = function(...) self:on_delay_execute_skill_handle(...) end
    
    ---效果索引值列表
    ---@private
    ---@type number[] 
    self.effect_idx_list = {}  
    ---@private
    ---@type number
    self.timer_id = nil
    ---延迟执行时间
    ---@private
    ---@type number 延迟执行时间
    self.delay_execute_time = nil
end

---初始化
---@private
function round_battle_process_action_data:initialize()
    local settings = self.context.database:get_setting_const()
    self.delay_execute_time = settings.KW_BATTLE_CHAGE_ROUND_ANIM
end

---获取触发配置
---@protected
---@param context context
---@return collector
function round_battle_process_action_data:get_trigger(context)
    return context:get_collector(matchers.all(battle_components.action_data))
end

---过滤
---@protected
---@param entity entity
---@return boolean
function round_battle_process_action_data:filter(entity)
    return entity:has_component(battle_components.action_data)
end

---组件变化时执行
---@protected
---@param entity_list entity[]
---@param count number
function round_battle_process_action_data:executes(entity_list, count)
    for i = 1, count do
        self:on_process_action_data(entity_list[i]:get_component(battle_components.action_data).value)
    end
end

---处理行动数据
---@private
---@param action_data BTLAction 行动数据
function round_battle_process_action_data:on_process_action_data(action_data)
    helper.log_round("start process the action data, stage = ", helper.get_enum_name(BTLStage, action_data.stage))

    -- 执行结果
    local result = false
    -- 根据阶段处理行动数据
    if action_data.stage == BTLStage.BS_ROLE_PRE_ACTION then
        -- 处理角色行动后+行动前阶段的行动数据
        if action_data.post_pre_action ~= nil then
            -- 更新能量
            self.context.message:send_pre_action_detail_message(action_data.post_pre_action)
            self:try_to_execute_effect_list(action_data, action_data.post_pre_action.effects)
            result = true
        else
            helper.error_round("action_data.post_pre_action is invalid, round_number = ", action_data.round_number)
        end

    elseif action_data.stage == BTLStage.BS_ROLE_IN_ACTION then
        -- 角色行动中阶段的行动数据
        local in_action = action_data.in_action
        if in_action ~= nil then
            -- 队友施法时，将技能使用结果同步到UI层，以便刷新技能cd等信息
            self.context.message:send_use_skill_result(in_action)
            if not self:try_to_execute_effect_list(action_data, in_action.effects, in_action.magic_hues, in_action.entities) then
                -- 没有效果数据的情况依旧尝试更新魔力色相，避免丢失数据
                self.context.database:set_magic_hues_data(in_action.magic_hues)
                -- 更新实体
                battle_effect_utility.update_entities_handle(self.context, in_action.entities)
            end
            result = true
        else
            helper.error_round("action_data.in_action is invalid, round_number = ", action_data.round_number)
        end

    elseif action_data.stage == BTLStage.BS_START then
        -- 战斗开始阶段的行动数据
        if action_data.start_action ~= nil then
            self:try_to_execute_effect_list(action_data, action_data.start_action.effects)
            result = true
        else
            helper.error_round("action_data.start_action is invalid, round_number = ", action_data.round_number)
        end

    elseif action_data.stage == BTLStage.BS_BEFORE_END then
        -- 战斗结束前 
        if action_data.before_end_action ~= nil then
            self:try_to_execute_effect_list(action_data, action_data.before_end_action.effects)
            result = true
        else
            helper.error_round("action_data.before_end_action is invalid, round_number = ", action_data.round_number)
        end
        
    else
        helper.error_round("action_data.stage is invalid, round_number = ", action_data.round_number, ", stage = ", action_data.stage)
    end
end

---执行效果列表处理
---@private
---@param action_data BTLAction
---@param effect_list BTLEffect[] 效果数据列表
---@param magic_hues table<number, number> 魔力色相，其中key：1=元素，2=灵能，3=以太，4=光，5=暗
---@param entities BTLEntity[] 效果计算结束后发生变化的角色数据
---@return boolean 执行技能效果结果
function round_battle_process_action_data:try_to_execute_effect_list(action_data, effect_list, magic_hues, entities)
    local controller = self.context.controller

    -- 开始设置回合数
    controller.message:send_round_number_change_start(action_data.round_number)
    
    ---@type stack queue<battle_skill_data>
    local queue_stack
    ---@type custom_table t<ident, boolean>
    local skill_hash
    ---@type boolean 检测Effect结果
    local result
    if effect_list ~= nil and #effect_list > 0 then
        -- 以对象的结构重组效果数据
        queue_stack, skill_hash = self:on_reform_effect_data(action_data, effect_list)
        if queue_stack:count() == 0 then
            if not helper.is_debug then
                helper.error_skill("no active skills to execute, please check the effects")
            else
                local rapid = require 'rapidjson'
                helper.error_skill("no active skills to execute, please check the effects = ", rapid.encode(effect_list))
            end
        end
        result = true
    else
        result = false
    end

    ---- 延迟执行技能，给UI表现时间
    --if self.timer_id ~= nil then
    --    controller:remove_timer_unscale(self.timer_id)
    --end
    --self.timer_id = controller:add_timer_unscale(self.delay_execute_time, self.delay_execute_skill_callback, action_data, 
    --        queue_stack, skill_hash, magic_hues, entities)
    
    self:on_delay_execute_skill_handle(action_data, queue_stack, skill_hash, magic_hues, entities)
    
    return result
end

---延迟执行技能
---@private
---@param action_data BTLAction 行动数据
---@param queue_stack stack queue<battle_skill_data>
---@param skill_hash hashset t<battle_skill_data, boolean>
---@param magic_hues table<number, number> 魔力色相，其中key：1=元素，2=灵能，3=以太，4=光，5=暗
---@param entities BTLEntity[] 效果计算结束后发生变化的角色数据
function round_battle_process_action_data:on_delay_execute_skill_handle(action_data, queue_stack, skill_hash, magic_hues, entities)
    self.timer_id = nil

    local context = self.context
    
    -- 结束设置回合数
    context.database:set_round_number(action_data.round_number)
    -- 设置行动队列
    context.database:set_current_action_queue(action_data.action_queue)
    
    if queue_stack ~= nil and queue_stack:count() > 0 then
        -- 执行效果逻辑
        ---@type entity
        local skill_entity, _ = context:get_unique_component(battle_components.skill_entity)

        skill_entity:replace_component(battle_components.skill_handler, queue_stack, skill_hash)
        skill_entity:replace_component(battle_components.skill_after, magic_hues, entities)
    else
        -- 没有可执行效果，跳过执行技能处理步骤，准备执行：检测行动数据所处阶段
        local battlefield = context:get_unique_component(battle_components.battle_field)
        battlefield:replace_component(battle_components.check_action_stage)
    end
end

---重组效果数据
---@private
---@param action_data BTLAction
---@param effect_list BTLEffect[] 效果数据列表
---@return stack, hashset
function round_battle_process_action_data:on_reform_effect_data(action_data, effect_list)
    ---@type entity
    local skill_entity, _ = self.context:get_unique_component(battle_components.skill_entity)
    skill_entity:replace_component(battle_components.skill_entity, effect_list, 0)
    
    ---@type stack 技能堆栈数据
    local queue_stack
    ---@type hashset 正在执行的"技能"
    local skill_hash
    ---@type skill_handler_component_data
    local skill_handler_comp = skill_entity:get_component(battle_components.skill_handler)
    if skill_handler_comp ~= nil then
        queue_stack = skill_handler_comp.queue_stack
        queue_stack:clear()
        skill_hash = skill_handler_comp.skill_hash
        skill_hash:clear()
    else
        queue_stack = stack.new()
        skill_hash = hashset.new()
    end

    -- 索引列表
    local idx_list = self.effect_idx_list
    helper.clear(idx_list)
    for j = 1, #effect_list do
        idx_list[j] = j
        
        -- 用于记录服务器返回的导演id标记数据(skill_result)，根据该数据获取目标导演id
        local in_action = action_data.in_action
        if in_action ~= nil and in_action.active_skill == effect_list[j].mid then
            -- 用于匹配导演id标识
            effect_list[j]._director_flag = in_action.skill_result
        end
    end

    -- 设置新的技能堆栈数据
    skill_data_utility.check_new_skill_stack_data(self.context, idx_list, '', queue_stack)
    -- 预加载技能
    self:preload_target_skill_assets(effect_list)
    
    return queue_stack, skill_hash
end

---预加载目标技能资产
---@private
---@param effect_list BTLEffect[]
function round_battle_process_action_data:preload_target_skill_assets(effect_list)
    if effect_list == nil then return end
    
    local context = self.context
    local utility = battle_utility
    
    for i = 1, #effect_list do
        local btl_effect = effect_list[i]
        if data_mgr.is_name(btl_effect.mid, table_names.BTLSkill.name) or data_mgr.is_name(btl_effect.mid, table_names.BTLBuff.name) then
            ---@type string[]
            local skill_list, caster_entity = utility.get_preload_skill_list(context, btl_effect.caster_id)
            if utility.set_preload_skill_list(btl_effect.mid, skill_list) then
                caster_entity:replace_component(battle_components.preload_skill, skill_list, btl_effect.mid, btl_effect.target_id)
            end
        end
    end
end

---卸载
---@public
function round_battle_process_action_data:tear_down()
    if self.timer_id ~= nil then
        self.context.controller:remove_timer_unscale(self.timer_id)
        self.timer_id = nil
    end
    
    self.effect_idx_list = nil
    self.delay_execute_skill_callback = nil
    self.delay_execute_time = nil
    
    super.tear_down(self)
end

return round_battle_process_action_data