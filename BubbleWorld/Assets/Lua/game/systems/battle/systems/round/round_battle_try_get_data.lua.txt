---
--- Generated by wuhaijun
--- File name : round_battle_try_get_data.lua.txt
--- DateTime : 2021/08/26
--- Description : 尝试获取数据
---

local helper = battle_helper
local enum_battle = enum.battle
local battle_wait_data_type = enum_battle.battle_wait_data_type
local battle_operation_mode = enum_battle.battle_operation_mode
local battle_step_type = enum_battle.battle_step_type

---@type battle_utility
local battle_utility = require(helper.path.battle_utils .. 'battle_utility')
---@type battle_constant
local battle_constant = require(helper.path.battle_utils .. 'battle_constant')
---@type battle_components
local battle_components = require(helper.path.battle_components)

---@class round_battle_try_get_data
local round_battle_try_get_data = class("round_battle_try_get_data")

---构造函数
---@protected
---@param context context
function round_battle_try_get_data:ctor(context)
    self.context = context

    ---时间计数器(毫秒)
    ---@private
    ---@type number
    self.check_timeout_counter = nil
    ---获取数据时间计时器
    ---@private
    ---@type number
    self.get_data_time_counter = nil

    ---要等待的数据类型
    ---@private
    ---@type battle_wait_data_type
    self.wait_data_type = nil
    ---技能施法者uid
    ---@private
    ---@type ident
    self.skill_caster_uid = nil
end

---初始化
---@private
function round_battle_try_get_data:initialize()
    -- 战场实体
    local battlefield, _ = self.context:get_unique_component(battle_components.battle_field)

    -- 监听try_get_data组件变化
    battlefield:add_listener(battle_components.try_get_data, self.on_try_get_data_changed, self)
    -- 监听operation_mode组件变化
    battlefield:add_listener(battle_components.operation_mode, self.on_operation_mode_changed, self)
end

---获取数据组件改变
---@private
---@param _ entity
---@param data_type battle_wait_data_type
---@param caster_uid ident
function round_battle_try_get_data:on_try_get_data_changed(_, data_type, caster_uid)
    helper.log_round('try_get_data component value has changed, data_type = ', helper.get_enum_name(battle_wait_data_type, data_type))

    self.get_data_time_counter = battle_constant.GET_DATA_TIME_INTERVAL
    self.check_timeout_counter = battle_constant.GET_DATA_TIMEOUT_WARNING_INTERVAL
    self.wait_data_type = data_type
    self.skill_caster_uid = caster_uid
end

---战斗操作模式改变
---@private
---@param _ entity
---@param mode battle_operation_mode
function round_battle_try_get_data:on_operation_mode_changed(_, mode)
    helper.log_round('operation_mode component value has changed, data_type = ', helper.get_enum_name(battle_operation_mode, mode))
    
    -- 自动模式且等待我方技能数据的情况下，需要向后端主动请求使用技能消息
    if mode == battle_operation_mode.AUTOMATIC and self.wait_data_type == battle_wait_data_type.WAIT_OWN_DATA then
        self.context.network:request_use_skill(nil, self.skill_caster_uid, nil, 2)
    end
end

---执行(每帧)
---@public
function round_battle_try_get_data:execute()
    if not self.wait_data_type then return end

    self.get_data_time_counter = self.get_data_time_counter - self.context.controller:get_unscaled_time()
    if self.get_data_time_counter > 0 then return end
    
    -- 检测是否已经获取到了数据
    if self:check_has_battle_data() then
        self.wait_data_type = nil
        self.skill_caster_uid = nil
    end

    -- [防御机制]检测获取数据的时间间隔
    local check_time = self.check_timeout_counter
    local time_interval = battle_constant.GET_DATA_TIME_INTERVAL
    check_time = check_time - time_interval + self.get_data_time_counter
    if check_time <= 0 then
        local timeout_interval = battle_constant.GET_DATA_TIMEOUT_WARNING_INTERVAL
        helper.warning_round(timeout_interval / 1000, ' seconds passed and no server action data was received!')
        self.check_timeout_counter = timeout_interval
    else
        self.check_timeout_counter = check_time
    end

    -- 重置获取数据间隔
    self.get_data_time_counter = time_interval
end

---检测数据是否存在
---@private
---@return boolean
function round_battle_try_get_data:check_has_battle_data()
    ---@type boolean 检测结果
    local check_result = false
    
    ---@type AckBTLAction | AckBTLInfo | AckBTLEndInfo
    local data = self.context.database:get_next_battle_data()
    if data ~= nil then
        if helper.is_debug then
            local rapid = require 'rapidjson'
            helper.log_round("battle data detected, start executing it, data = ", rapid.encode(data))
        end
        
        if data.action ~= nil then
            -- 回合内行动数据处理
            self:on_process_action_data(data)
            check_result = true

        elseif data.battle_info ~= nil then
            -- 战斗初始信息数据
            self:on_process_next_battle(data)
            check_result = true

        elseif data.is_victory ~= nil then
            -- 战斗结算数据
            self:on_process_battle_end_data(data)
            check_result = true

        else
            helper.error_round("data not process, data = ", data)
        end
    end
    
    return check_result
end

---处理行动数据
---@private
---@param action_data AckBTLAction
function round_battle_try_get_data:on_process_action_data(action_data)
    local battlefield, _ = self.context:get_unique_component(battle_components.battle_field)
    battlefield:replace_component(battle_components.action_data, action_data.action)
end

---处理下一场战斗数据
---@private
---@param battle_info AckBTLInfo
function round_battle_try_get_data:on_process_next_battle(battle_info)
    local battle_context = self.context
    local database = battle_context.database

    -- 设置下一场战斗数据
    database:init_battle_info(battle_info)
    -- 切换到战斗初始化步骤
    battle_context.controller:set_battle_step(battle_step_type.INIT)

    -- 生成战斗单位
    ---@type string
    local unit_list = database:get_unit_info_list()
    for i = 1, #unit_list do
        local unit_info = unit_list[i]
        if not unit_info.is_init and unit_info.hp_value > 0 then
            battle_utility.generate_unit_entity(battle_context, unit_info, false)
        end
    end
end

---处理战斗结算数据
---@private
---@param end_info AckBTLEndInfo
function round_battle_try_get_data:on_process_battle_end_data(end_info)
    local battlefield, _ = self.context:get_unique_component(battle_components.battle_field)
    battlefield:replace_component(battle_components.over_condition, end_info)
end

---卸载
---@public
function round_battle_try_get_data:tear_down()
    local battlefield, _ = self.context:get_unique_component(battle_components.battle_field)
    battlefield:remove_listener(battle_components.try_get_data, self.on_try_get_data_changed)
    battlefield:remove_listener(battle_components.operation_mode, self.on_operation_mode_changed)
    
    self.check_timeout_counter = nil
    self.get_data_time_counter = nil
    self.wait_data_type = nil
    self.skill_caster_uid = nil
    
    self.context = nil
end

return round_battle_try_get_data