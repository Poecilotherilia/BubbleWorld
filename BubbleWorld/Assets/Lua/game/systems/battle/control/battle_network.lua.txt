---
--- Generated by wuhaijun
--- File name : battle_network.lua.txt
--- DateTime : 2021/04/21
--- Description : 网络层
---

local helper = battle_helper
local net_mgr = network
local enum_proto = enum.proto
local message_names = message_names
local EGameMsgID = enum_proto.EGameMsgID
local EGameEventCode = enum_proto.EGameEventCode
local game_data_manager = game_data_manager
local system_manager = system_manager
local message = message
---@type message_type
local message_type = enum.message_type
local enum_battle = enum.battle
local battle_operation_mode = enum_battle.battle_operation_mode
local battle_mode_type = enum_battle.battle_mode_type

---@class battle_network
local battle_network = class("battle_network")

---构造函数
---@protected
function battle_network:ctor()
    ---战斗控制器
    ---@private
    ---@type battle_controller
    self.controller = nil
    ---战斗回放数据
    ---@private
    ---@type ReqReplayData
    self.req_replay_data = nil
    ---退出战斗类型（0-普通退出；1-特殊退出流程；2-重新挑战；3-跳转（指定场景退出））
    ---@private
    ---@type battle_exit_type
    self.exit_type = nil
    ---消息最新索引值
    ---@private
    ---@type number
    self.msg_latest_index = nil

    self:add_listener()
end

---设置战斗控制器
---@public
---@param ctrl battle_controller
function battle_network:set_controller(ctrl)
    self.controller = ctrl
    self.msg_latest_index = -1
end

---清理上一场战斗
---@public
function battle_network:clear()
    self.controller = nil
    self.req_replay_data = nil
    self.exit_type = nil
    self.msg_latest_index = nil
end

---销毁
---@public
function battle_network:dispose()
    self:remove_listener()
    self:clear()
end

--region 网络层消息监听
---添加网络消息监听
---@private
function battle_network:add_listener()
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_INFO, message_names.AckBTLInfo, self.on_ack_battle_info, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_PK_INFO, message_names.AckBTLPk, self.on_ack_battle_pk_info, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_ACTION, message_names.AckBTLAction, self.on_ack_battle_action, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_END_INFO, message_names.AckBTLEndInfo, self.on_ack_battle_end_info, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_TOGGLE_AUTO_MODE, message_names.AckBTLToggleAutoMode, self.on_ack_battle_toggle_auto_mode, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_UPDATE_ENTITY_AUTO_MODE, message_names.AckBTLUpdateEntityAutoMode, self.on_ack_update_entity_auto_mode, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_BATTLE_SET_PRIO_TARGET, message_names.AckBTLSetPrioTarget, self.on_ack_set_prio_target, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_LEAVE_BATTLE, message_names.AckLeaveBattle, self.on_ack_leave_battle, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_CONTINUOUS_BATTLE, message_names.AckContinuousBattle, self.on_ack_continuous_battle, self)
    net_mgr.add_message_listener(EGameMsgID.ACK_REPLAY_DATA, message_names.AckReplayData, self.on_ack_battle_replay, self)
end

---移除网络消息监听
---@private
function battle_network:remove_listener()
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_INFO, self.on_ack_battle_info, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_PK_INFO, self.on_ack_battle_pk_info, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_ACTION, self.on_ack_battle_action, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_END_INFO, self.on_ack_battle_end_info, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_TOGGLE_AUTO_MODE, self.on_ack_battle_toggle_auto_mode, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_UPDATE_ENTITY_AUTO_MODE, self.on_ack_update_entity_auto_mode, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_BATTLE_SET_PRIO_TARGET, self.on_ack_set_prio_target, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_LEAVE_BATTLE, self.on_ack_leave_battle, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_CONTINUOUS_BATTLE, self.on_ack_continuous_battle, self)
    net_mgr.remove_message_listener(EGameMsgID.ACK_REPLAY_DATA, self.on_ack_battle_replay, self)
end

---战斗信息广播
---@private
---@param ack_info AckBTLInfo
function battle_network:on_ack_battle_info(ack_info)
    local ctrl = self.controller

    if helper.is_debug then
        if ctrl == nil then
            helper.error('The battle is not initialized, AckBTLInfo was received')
        end

        local rapid = require 'rapidjson'
        helper.log("AckBTLInfo message was received, msg = ", rapid.encode(ack_info))
    end

    self.msg_latest_index = ack_info.unique_id
    ctrl:set_battle_info(ack_info)
end

---战力PK广播(时机：1.AckBTLInfo后，2.Boss刷出来后)
---@private
---@param ack_info AckBTLPk
function battle_network:on_ack_battle_pk_info(ack_info)
    local ctrl = self.controller
    
    if helper.is_debug then
        if ctrl == nil then
            helper.error('The battle is not initialized, AckBTLPk was received')
        end

        local rapid = require 'rapidjson'
        helper.log("AckBTLPk message was received, msg = ", rapid.encode(ack_info))
    end

    ctrl.database:set_battle_pk_info(ack_info)
end

---行动指令回复广播(时机：1.请求行动，2.当值角色行动前)
---@private
---@param ack_info AckBTLAction
function battle_network:on_ack_battle_action(ack_info)
    local ctrl = self.controller

    if helper.is_debug then
        if ctrl == nil then
            helper.error('The battle is not initialized, AckBTLAction was received')
        end

        local rapid = require 'rapidjson'
        helper.log("AckBTLAction message was received, msg = ", rapid.encode(ack_info))
    end

    self.msg_latest_index = ack_info.unique_id
    ctrl.database:add_battle_data(ack_info)
end

---战斗结算协议
---@private
---@param ack_info AckBTLEndInfo
function battle_network:on_ack_battle_end_info(ack_info)
    local ctrl = self.controller

    if helper.is_debug then
        if ctrl == nil then
            helper.error('The battle is not initialized, AckBTLEndInfo was received')
        end

        local rapid = require 'rapidjson'
        helper.log("AckBTLEndInfo message was received, msg = ", rapid.encode(ack_info))
    end

    ctrl.database:add_battle_data(ack_info, true)
end

---战斗结算协议
---@private
---@param ack_info AckBTLToggleAutoMode
function battle_network:on_ack_battle_toggle_auto_mode(ack_info)
    local ctrl = self.controller
    if ctrl == nil then
        helper.error('The battle is not initialized, AckBTLToggleAutoMode was received')
        return
    end

    message.broadcast(message_type.BATTLE_TOGGLE_AUTO_MODE_RESULT, ack_info)
    if ack_info.code == EGameEventCode.SUCCESS then
        ctrl.database:set_operation_mode(ack_info.toggle)
    end
end

---魔女战斗类型切换返回协议
---@private
---@param ack_info AckBTLUpdateEntityAutoMode
function battle_network:on_ack_update_entity_auto_mode(ack_info)
    message.broadcast(message_type.BATTLE_UPDATE_ENTITY_AUTO_MODE, ack_info)
end

---响应设置集火/保护目标
---@private
---@param ack_info AckBTLSetPrioTarget
function battle_network:on_ack_set_prio_target(ack_info)
    message.broadcast(message_type.BATTLE_SET_PRIO_TARGET, ack_info)
end

---响应离开战斗
---@private
---@param ack_info AckLeaveBattle
function battle_network:on_ack_leave_battle(ack_info)
    message.broadcast(message_type.BATTLE_ACK_LEAVE_BATTLE, ack_info)

    if ack_info.event_code == EGameEventCode.SUCCESS then
        self:on_end_battle_handle()
    end
end

---响应连战请求
---@private
---@param ack_info AckContinuousBattle
function battle_network:on_ack_continuous_battle(ack_info)
    message.broadcast(message_type.BATTLE_ACK_CONTINUOUS_BATTLE, ack_info)

    if ack_info.event_code == EGameEventCode.SUCCESS then
        self.controller:set_continuous_battle()
    end
end

---响应战斗回放请求
---@private
---@param ack AckReplayData
function battle_network:on_ack_battle_replay(ack)
    if ack.event_code == EGameEventCode.SUCCESS then
        if system_manager.battle:is_in_battle() and self.controller:check_battle_initialized() then
            self.controller:get_replay_battle_data(ack.idx)
        else
            self.req_replay_data.idx = ack.idx
        end
    end
end
--endregion

--region 请求消息
---请求使用技能
---@public
---@param skill_mid number 技能ID
---@param caster_uid Ident 施法者
---@param target_uid Ident 目标ID
---@param op_type number 类型：1=使用技能，2=自动模式，3=跳过行动指令：玩家操控的单位，行动前无可选用的技能（被控制状态）
function battle_network:request_use_skill(skill_mid, caster_uid, target_uid, op_type)
    helper.log("request use skill, op_type = ", op_type, ", skill_mid = ", skill_mid, ", caster_uid = ", helper.to_string(caster_uid),
            ", target_uid = ", helper.to_string(target_uid))

    -- 向远端发送释放技能请求
    ---@type ReqBTLAction
    local action_data = {
        ---@type BTLOperation
        op = { player_id = game_data_manager.player.player_uid, }
    }

    if op_type == 1 then
        action_data.op.manual_op = {
            skill_mid = skill_mid,
            caster_id = caster_uid,
            selected_target_id = target_uid,
        }
    elseif op_type == 2 then
        action_data.op.auto_op = 1
    elseif op_type == 3 then
        action_data.op.skip_op = 1
    end
    net_mgr.send_message_async(EGameMsgID.REQ_BATTLE_ACTION, message_names.ReqBTLAction, action_data)
end

---请求自动战斗
---@public
---@param operation_mode battle_operation_mode
function battle_network:request_toggle_auto_mode(operation_mode)
    helper.log("request toggle auto mode, operation_mode = ", helper.get_enum_name(battle_operation_mode, operation_mode))

    ---@type ReqBTLToggleAutoMode
    local toggle_auto_mode = {
        player_id = game_data_manager.player.player_uid,
        toggle = operation_mode
    }
    net_mgr.send_message_async(EGameMsgID.REQ_BATTLE_TOGGLE_AUTO_MODE, message_names.ReqBTLToggleAutoMode, toggle_auto_mode)
end

---请求切换魔女自动战斗类型
---@public
---@param entity_id Ident
---@param auto_mode BTLAutoMode
function battle_network:request_update_entity_auto_mode(entity_id, auto_mode)
    ---@type ReqBTLUpdateEntityAutoMode
    local msg = {
        player_id = game_data_manager.player.player_uid,
        mode = {
            entity_id = entity_id,
            auto_mode = auto_mode
        }
    }
    net_mgr.send_message_async(EGameMsgID.REQ_BATTLE_UPDATE_ENTITY_AUTO_MODE, message_names.ReqBTLUpdateEntityAutoMode, msg)
end

---请求设置集火/保护目标
---@public
---@param entity_id Ident
function battle_network:request_set_prio_target(entity_id)
    ---@type ReqBTLSetPrioTarget
    local msg = {
        player_id = game_data_manager.player.player_uid,
        entity_id = entity_id
    }
    net_mgr.send_message_async(EGameMsgID.REQ_BATTLE_SET_PRIO_TARGET, message_names.ReqBTLSetPrioTarget, msg)
end

---请求离开战斗
---@public
---@param exit_type battle_exit_type 退出战斗类型（0-普通退出；1-特殊退出流程；2-重新挑战；3-跳转（指定场景退出））
function battle_network:request_exit_battle(exit_type)
    self.exit_type = exit_type
    
    if self.controller.database:get_mode_type() ~= battle_mode_type.PLAYBACK then
        -- 请求服务器退出战斗
        ---@type ReqLeaveBattle
        local msg = { player_id = game_data_manager.player.player_uid, }
        net_mgr.send_message_async(EGameMsgID.REQ_LEAVE_BATTLE, message_names.ReqLeaveBattle, msg)
    else
        -- 回放战斗，无需请求服务器，直接退出战斗
        self:on_end_battle_handle()
    end
end

---请求连续战斗
---@public
function battle_network:request_continuous_battle()
    ---@type ReqContinuousBattle
    local msg = {
        player_id = game_data_manager.player.player_uid,
    }
    net_mgr.send_message_async(EGameMsgID.REQ_CONTINUOUS_BATTLE, message_names.ReqContinuousBattle, msg)
end

---请求战斗回放
---@public
---@param replay_id Ident
---@param index number
function battle_network:request_battle_replay(replay_id, index)
    ---@type ReqReplayData
    local msg = self.req_replay_data
    if msg == nil then
        msg =
        { 
            player_id = game_data_manager.player.player_uid,
            replay_id = replay_id,
            idx = 0,
        }
        self.req_replay_data = msg
    end

    if index ~= nil then
        msg.idx = index
    end
   
    net_mgr.send_message_async(EGameMsgID.REQ_REPLAY_DATA, message_names.ReqReplayData, msg)
end

---获取最新的索引值
---@public
function battle_network:get_latest_index()
    return self.msg_latest_index
end
--endregion

---退出战斗处理
---@private
function battle_network:on_end_battle_handle()
    local exit_type = self.exit_type
    local ctrl = self.controller
    self.exit_type = nil
    system_manager.capture_screen:start(function() ctrl:end_battle(exit_type) end)
end

return battle_network