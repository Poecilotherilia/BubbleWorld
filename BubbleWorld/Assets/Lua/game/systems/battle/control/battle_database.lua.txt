---
--- Generated by wuhaijun
--- File name : battle_database.lua.txt
--- DateTime : 2021/05/19
--- Description : 战斗数据管理
---

local helper = battle_helper
local data_mgr = data
local table_names = tables
local net_mgr = network
local game_data_manager = game_data_manager
local ui_cache_data = game_data_manager.cache

local str_is_nil_or_empty = string.is_nil_or_empty
local enum_battle = enum.battle
local team_type_flag = enum_battle.team_type_flag
local unit_type_flag = enum_battle.unit_type_flag
local battle_mode_type = enum_battle.battle_mode_type
local role_body_type = enum.common.role_body_type
local Setting = cs.Setting
local LuaUtil = cs.LuaUtil
local cache_keys = enum.cache_keys

local exp_cache_data = require "game/windows/battle/battle_result/model/exp_cache_data"
---@type ident
local ident = require(helper.path.battle_utils .. 'ident')
---@type queue
local queue = require 'framework/basic/queue'
---@type battle_constant
local battle_constant = require(helper.path.battle_utils .. 'battle_constant')
---@type vector3
local vector3 = require(battle_helper.path.battle_utils .. 'vector3')
local enum_common = require("game/common/enum_common")
---@type wwise_util
local wwise_util = require 'game/utils/wwise_util/wwise_util'

---@class battle_database
local battle_database = {}
battle_database.__index = battle_database

---new
---@public
---@return battle_database
function battle_database.new()
    ---@type battle_database
    local instance = setmetatable({ cname = 'battle_database' }, battle_database)
    instance:ctor()
    return instance
end

---构造函数
---@protected
function battle_database:ctor()
    ---战斗控制器
    ---@private
    ---@type battle_controller
    self.controller = nil

    ---战斗数据，战斗开始时从远端获得
    ---@private
    ---@type AckBTLInfo
    self.battle_info = nil

    ---战斗场次
    ---@private
    ---@type number
    self.battle_number = nil

    ---战力PK信息，远端获得数据
    ---@private
    ---@type BTLPkInfo
    self.battle_pk_info = nil

    ---获取单位信息列表
    ---@private
    ---@type battle_unit_info[]
    self.unit_info_list = nil

    ---配置名字列表
    ---@private
    ---@type string[]
    self.config_name_list = nil

    ---设置常量
    ---@private
    ---@type table<string, any>
    self.setting_const = nil

    ---战斗中数据队列
    ---@private
    ---@type queue BTLAction[]
    self.battle_data_queue = nil
    ---当前回合数
    ---@private
    ---@type number
    self.round_number = nil
    ---当前行动队列
    ---@private
    ---@type BTLActionQueue
    self.action_queue = nil

    ---战斗单位信息
    ---@private
    ---@type BattleMapInfo
    self.map_point_info = nil

    ---当前战斗模式
    ---@private
    ---@type battle_mode_type
    self.mode_type = nil

    ---战斗操作模式(需要经过服务端验证)
    ---@private
    ---@type battle_operation_mode
    self.operation_mode = nil

    ---是否自动战斗（以客户端记录的数据为准）
    ---@public
    ---@type boolean
    self.is_auto_battle = false

    ---镜头操作模式
    ---@private
    ---@type battle_operation_mode
    self.camera_operation_mode = nil
    ---战斗倍速数值
    ---@private
    ---@type number
    self.speed_up_num = nil

    ---是否跳过大招展示动画
    ---@private
    ---@type boolean
    self.is_jump_big_skill_ue = nil

    ---战斗结算数据
    ---@private
    ---@type AckBTLEndInfo
    self.btl_end_info = nil
    ---已存在最后一击
    ---@private
    ---@type boolean
    self.has_final_attack = nil
    ---是否正在战斗前的触发器
    ---@private
    ---@type boolean
    self.is_execute_trigger = nil
end

--region 初始化
---初始化
---@public
---@param controller battle_controller
function battle_database:initialize(controller)
    self.controller = controller
    self.battle_data_queue = queue.new()

    self.battle_number = 0
    self.round_number = 1
    self.unit_info_list = {}
    self.has_final_attack = nil

    self:init_battle_config_data()
    self:init_battle_setting_const()
end

---初始化战斗信息
---@public
---@param btl_info AckBTLInfo
function battle_database:init_battle_info(btl_info)
    -- 设置当前战斗数据
    self.battle_info = btl_info
    -- 增加战斗场次
    self.battle_number = self.battle_number + 1

    ---@type BTLInfo
    local battle_info = btl_info.battle_info
    self.mode_type = battle_info.battle_mode

    ---@type BTLSettings 战斗设置
    local battle_settings = battle_info.battle_settings
    if battle_settings ~= nil then
        if self.operation_mode == nil then
            self.operation_mode = battle_settings.default_auto_state
            self.camera_operation_mode = battle_settings.default_auto_state
        end
        self.speed_up_num = self:get_speed_up_num(battle_settings.default_speed)
    end

    -- 地图点位数据
    local camera_type = data_mgr.get(table_names.BTLBattle.name, self:get_battle_mid(), table_names.BTLBattle.properties.CameraType) or 1
    ---@type BattleMapInfo
    local map_point_info = data_mgr.get(battle_constant.BATTLE_MAP_INFO_NAME, camera_type)
    helper.assert(map_point_info ~= nil, "not found BattleMapInfo, camera_type = ", camera_type)
    self.map_point_info = map_point_info
    helper.log("init battle map point info, camera_type = ", camera_type)

    -- 初始化单位列表
    self:init_unit_info_list(battle_info.entities)
    -- 设置魔力色相数据
    self:set_magic_hues_data(battle_info.magic_hues)

    if self.mode_type == battle_mode_type.PVE then
        -- 缓存结算前的经验
        self:set_exp_cache_data()
    end
end

---初始化单位信息列表
---@private
---@param entities BTLEntity[]
function battle_database:init_unit_info_list(entities)
    ---@type number 服务器实体数量
    local entity_count = 0

    if entities ~= nil then
        entity_count = #entities
        for i = 1, entity_count do
            local btl_entity = entities[i]
            local net_object = self:set_network_object_data(btl_entity)
            local unit_info = self:get_unit_info_by_uid(btl_entity.entity_id)
            if unit_info == nil then
                self:add_unit_info_by_net_object(net_object)
            end
        end
    end

    helper.log('init battle units finished, entity_count = ', entity_count)
end

---初始化战斗设置常量
---@private
function battle_database:init_battle_setting_const()
    ---@type { Map:table<string, ConstClient> }
    local const_client_data = data_mgr.get_all(table_names.ConstClient.name)
    self.setting_const =
    {
        KW_SKILL_V_CAMERA_BLEND_TIME = const_client_data['KW_SKILL_V_CAMERA_BLEND_TIME'].Int,
        KW_UTLSKILL_BLANK_SCREEN_FADE_IN_TIME = const_client_data['KW_UTLSKILL_BLANK_SCREEN_FADE_IN_TIME'].Int,
        KW_UTLSKILL_BLANK_SCREEN_SHOW_TIME = const_client_data['KW_UTLSKILL_BLANK_SCREEN_SHOW_TIME'].Int,
        KW_FINAL_ATTACK_GLOBAL_TIME_SCALE = const_client_data['KW_FINAL_ATTACK_GLOBAL_TIME_SCALE'].Int,
        KW_FINAL_ATTACK_CASTER_TIME_SCALE = const_client_data['KW_FINAL_ATTACK_CASTER_TIME_SCALE'].Int,
        KW_FINAL_ATTACK_DURACTION_TIME = const_client_data['KW_FINAL_ATTACK_DURACTION_TIME'].Int,
        KW_BATTLE_VIEW_CAMERA_PATH = const_client_data['KW_BATTLE_VIEW_CAMERA_PATH'].String,
        KW_SKILL_CAMERA_NODE_PATH = const_client_data['KW_SKILL_CAMERA_NODE_PATH'].String,
        KW_APPEAR_CAMERA_NODE_PATH = const_client_data['KW_APPEAR_CAMERA_NODE_PATH'].String,
        KW_ENEMY_APPEAR_CLIP_PATH = const_client_data['KW_ENEMY_APPEAR_CLIP_PATH'].String,
        KW_OWN_APPEAR_CLIP_PATH = const_client_data['KW_OWN_APPEAR_CLIP_PATH'].String,
        KW_OWN_TEAM_APPEAR_CAMERA_ACTION_TIME = const_client_data['KW_OWN_TEAM_APPEAR_CAMERA_ACTION_TIME'].Int,
        KW_ENEMY_TEAM_APPEAR_CAMERA_ACTION_TIME = const_client_data['KW_ENEMY_TEAM_APPEAR_CAMERA_ACTION_TIME'].Int,
        KW_BATTLE_CHAGE_ROUND_ANIM = const_client_data['KW_BATTLE_CHAGE_ROUND_ANIM'].Int,
    }

    helper.log('init battle setting const finished')
end

---初始化战斗配置文件
---@private
function battle_database:init_battle_config_data()
    -- 将战斗中使用到的配表名加入列表以便做加载和卸载
    self.config_name_list = 
    {
        battle_constant.BATTLE_MAP_INFO_NAME,
        battle_constant.BATTLE_OFFSET_DATA_NAME,
        table_names.BTLState.name,
    }
    
    -- 加载配置文件
    for _, config_name in ipairs(self.config_name_list) do
        data_mgr.load(config_name)
    end
    
    helper.log('init config data finished')
end
--endregion

--region 添加数据
---添加新单位
---@public
---@param btl_entity BTLEntity
---@return battle_unit_info
function battle_database:add_unit_info(btl_entity)
    local net_object = self:set_network_object_data(btl_entity)
    return self:add_unit_info_by_net_object(net_object)
end

---添加战斗数据
---@public
---@param net_object net_object
---@return battle_unit_info
function battle_database:add_unit_info_by_net_object(net_object)
    ---@type string RoleRes表id
    local role_res_mid
    ---@type string Enemy表id
    local enemy_mid
    ---@type number 角色稀有度
    local role_rare
    ---@type unit_type_flag 单位类型
    local unit_type = unit_type_flag.NONE
    ---@type string 位置索引属性名
    local pos_index_property_name
    ---@type string 队伍属性名
    local team_property_name
    ---@type string 血量
    local hp_property_name
    ---@type string 最大血量
    local max_hp_property_name

    ---@type string 表名字
    local class_name = net_object:get_property_value(table_names.IObject.properties.ClassName)
    ---@type string 配置id
    local config_id = net_object:get_property_value(table_names.Witch.properties.NpcId)
    if not str_is_nil_or_empty(config_id) then
        class_name = table_names.BattleNpc.name
    else
        config_id = net_object:get_property_value(table_names.IObject.properties.ConfigID)
    end
    if class_name == table_names.Witch.name then
        unit_type = unit_type_flag.WITCH

        role_res_mid = net_object:get_property_value(table_names.Witch.properties.RoleResId)
        pos_index_property_name = table_names.Witch.properties.Pos
        team_property_name = table_names.Witch.properties.Team
        hp_property_name = table_names.Witch.properties.Hp
        max_hp_property_name = table_names.Witch.properties.HpMax

        ---@type Witch 女巫
        local witch_data = data_mgr.get(class_name, config_id)
        helper.assert(witch_data ~= nil, 'not found Witch data, config_id = ', config_id)
        role_rare = witch_data.Rare
    elseif class_name == table_names.Monster.name then
        unit_type = unit_type_flag.MONSTER

        ---@type Monster 怪物
        local monster_data = data_mgr.get(class_name, config_id)
        helper.assert(monster_data ~= nil, 'not found Monster data, config_id = ', config_id)
        role_res_mid = monster_data.RoleResIdData
        enemy_mid = net_object:get_property_value(table_names.Monster.properties.EnemyId)
        role_rare = net_object:get_property_value(table_names.Monster.properties.Rare)

        pos_index_property_name = table_names.Monster.properties.Pos
        team_property_name = table_names.Monster.properties.Team
        hp_property_name = table_names.Monster.properties.Hp
        max_hp_property_name = table_names.Monster.properties.HpMax
    elseif class_name == table_names.BattleNpc.name then
        unit_type = unit_type_flag.NPC

        role_res_mid = net_object:get_property_value(table_names.Witch.properties.RoleResId)
        pos_index_property_name = table_names.Witch.properties.Pos
        team_property_name = table_names.Witch.properties.Team
        hp_property_name = table_names.Witch.properties.Hp
        max_hp_property_name = table_names.Witch.properties.HpMax

        ---@type BattleNpc NPC数据
        local npc_data = data_mgr.get(class_name, config_id)
        helper.assert(npc_data ~= nil, 'not found BattleNpc data, config_id = ', config_id)
        role_rare = npc_data.Rare
    end

    ---@type number 位置索引
    local pos_index = net_object:get_property_value(pos_index_property_name)
    ---@type Ident 服务器数据和MainRole配表数据结合获取Team
    local team_uid = net_object:get_property_value(team_property_name)
    ---@type team_type_flag
    local team_type = self:check_same_team_with_player(team_uid)
    ---@type number 血量值
    local hp_value = net_object:get_property_value(hp_property_name)

    -- 单位索引点位数据
    local unit_index_point = self:get_unit_index_point(team_type, pos_index)
    local point_info = unit_index_point.StandingPoint
    local unit_pos_x, unit_pos_y, unit_pos_z, p_offset_x, p_offset_y, p_offset_z = self:get_unit_position_offset(point_info, role_res_mid)
   
    ---@type RoleRes RoleRes表数据
    local role_res_data = data_mgr.get(table_names.RoleRes.name, role_res_mid)
    helper.assert(role_res_data ~= nil, 'not found RoleRes, role_res_mid = ', role_res_mid, ', unit_type = ',
            helper.get_enum_name(unit_type_flag, unit_type))
    ---@type number 缩放值
    local scale_value = role_res_data.Scale / 10000

    ---@type battle_unit_info
    local unit_info = 
    {
        uid = ident.wrap(net_object.id),
        unit_type = unit_type,
        team_type = team_type,
        res_path = role_res_data.ModelPath,
        body_type = role_res_data.BodyType,
        role_res_mid = role_res_mid,
        config_id = config_id,
        enemy_mid = enemy_mid,
        role_rare = role_rare,
        pos_index = pos_index,
        position = vector3.new(unit_pos_x, unit_pos_y, unit_pos_z),
        rotation = vector3.new(point_info.Rotation.X, point_info.Rotation.Y, point_info.Rotation.Z),
        scale = vector3.new(scale_value, scale_value, scale_value),
        pos_offset = vector3.new(p_offset_x, p_offset_y, p_offset_z),
        index_point_info = unit_index_point,
        hp_value = hp_value,
        is_death = hp_value <= 0,
        is_init = false,
    }
    self.unit_info_list[#self.unit_info_list + 1] = unit_info

    return unit_info
end

---添加战斗消息到数据队列中
---@public
---@param ack_battle AckBTLAction | AckBTLInfo | AckBTLEndInfo
---@param is_end_info boolean 是否是AckBTLEndInfo
function battle_database:add_battle_data(ack_battle, is_end_info)
    if ack_battle == nil then
        helper.error("Invalid ack_battle data")
        return
    end

    self.battle_data_queue:enqueue(ack_battle)

    if is_end_info then
        self:set_battle_end_info(ack_battle)
    end
end
--endregion

--region 设置数据
---设置当前回合数
---@public
---@param round_number number
function battle_database:set_round_number(round_number)
    if self.round_number == round_number then return end

    self.round_number = round_number
    self.controller.message:send_round_number_change(round_number)
end

---设置行动队列
---@public
---@param action_queue BTLActionQueue
function battle_database:set_current_action_queue(action_queue)
    if action_queue ~= nil and action_queue.elements ~= nil then
        self.action_queue = action_queue
        self.controller.message:send_action_queue_change(action_queue)
    end
end

---设置操作模式
---@public
---@param operation_mode battle_operation_mode
function battle_database:set_operation_mode(operation_mode)
    if self.operation_mode == operation_mode then
        return
    end

    self.operation_mode = operation_mode
    self.controller:operation_mode_changed()
end

---设置镜头操作模式
---@public
---@param mode battle_operation_mode
function battle_database:set_camera_operation_mode(mode)
    self.camera_operation_mode = mode
end

---设置倍速值
---@public
---@param speed_up number
function battle_database:set_speed_up_num(speed_up)
    self.speed_up_num = speed_up
    self.controller:set_time_scale(speed_up)
    wwise_util.set_audio_pitch(speed_up)

    ---@type BTLBattle
    local battle_data = data_mgr.get(table_names.BTLBattle.name, self:get_battle_mid())
    if nil ~= speed_up then
        local account_key = game_data_manager.player:get_string_account()
        local final_key = battle_constant.BATTLE_SPEED_UP_NUMBER_KEY..account_key
        
        Setting.SetFloat(final_key, speed_up, tostring(battle_data.Type))
    end
end

---设置PK战力值信息
---@public
---@param btl_pk AckBTLPk
function battle_database:set_battle_pk_info(btl_pk)
    self.battle_pk_info = btl_pk.pk
end

---设置是否跳过大招动画
---@public
---@param value boolean
function battle_database:set_is_jump_big_skill_ue(value)
    self.is_jump_big_skill_ue = value
end

---设置魔力色相数据
---@public
---@param magic_hues table<number, number>
function battle_database:set_magic_hues_data(magic_hues)
    if magic_hues == nil then
        return
    end

    self.controller.message:send_magic_hues_change(magic_hues)
end

---设置战斗结束结算消息
---@private
---@param ack_info AckBTLEndInfo
function battle_database:set_battle_end_info(ack_info)
    self.btl_end_info = ack_info

    -- 连战时缓存连战奖励数据
    local continuous_count = self:get_remain_continuous_count()
    if continuous_count > 0 or continuous_count == -1 then
        game_data_manager.battle_record:cache_continue_battle_reward(ack_info)
    end
end

---设置是否有最后一击
---@public
---@param value boolean
function battle_database:set_has_final_attack(value)
    self.has_final_attack = value
end

---设置网络层对象数据
---@public
---@param data BTLEntity
---@return net_object
function battle_database:set_network_object_data(data)
    if data == nil then
        return
    end

    net_mgr.sync_object(data)

    ---@type net_object
    local net_object = self:get_net_object(data.entity_id)

    -- 监听血量变化
    net_object:remove_property_listener(table_names.Witch.properties.Hp, self.set_new_unit_hp_change_value, self)
    net_object:add_property_listener(table_names.Witch.properties.Hp, self.set_new_unit_hp_change_value, self)

    return net_object
end

---设置单位血量变化值
---@private
---@param uid Ident
---@param _ string
---@param _ number
---@param new_value number
function battle_database:set_new_unit_hp_change_value(uid, _, _, new_value)
    local unit_info = self:get_unit_info_by_uid(uid)
    if unit_info ~= nil then
        helper.log('unit hp value changed, uid = ', helper.to_string(unit_info.uid), ', hp_value = ', unit_info.hp_value,
                ', new_value = ', new_value)

        unit_info.hp_value = new_value
    else
        helper.log("No unit data found in database, uid = ", helper.to_string(uid))
    end
end

---设置是否正在战斗前的触发器
---@public
---@param trigger_id string
function battle_database:set_is_execute_trigger(trigger_id)
    if str_is_nil_or_empty(trigger_id) then return end
    
    ---@type BTLBattle
    local battle_data = data_mgr.get(table_names.BTLBattle.name, self:get_battle_mid())
    ---@type array2_string[]
    local trigger_list = battle_data.BattleTrigger
    for i = 1, #trigger_list do
        local trigger = trigger_list[i]
        if #trigger.Array >= 2 then
            if trigger.Array[2] == trigger_id and trigger.Array[1] == '3' then
                self.is_execute_trigger = true
                break
            end
        end
    end
end

---战斗开始时，缓存玩家和魔女当前等级和经验，用于结算表现
---@private
function battle_database:set_exp_cache_data()
    local player_net_obj = game_data_manager.player.player_net_obj
    if player_net_obj then
        local exp_data = exp_cache_data.new()
        local player_level = player_net_obj:get_property_number(table_names.Player.properties.Level)
        local player_exp = player_net_obj:get_property_number(table_names.Player.properties.Exp)
        exp_data:add_player_data(player_level, player_exp)
        local own_unit_list = self:get_own_unit_info_list()
        if own_unit_list then
            local unit, level, exp
            local count = #own_unit_list
            for i = 1, count do
                ---@type battle_unit_info
                unit = own_unit_list[i]
                if unit.unit_type == unit_type_flag.WITCH then
                    local witch_mid = unit.config_id
                    ---@type witch_info
                    local info = game_data_manager.witch:get_witch_info(witch_mid)
                    if nil ~= info then
                        level = info.level
                        exp = info.exp
                        exp_data:add_witch_data(witch_mid, level, exp, unit.uid)
                    end
                elseif unit.unit_type == unit_type_flag.NPC then
                    exp_data:add_witch_data(nil, nil, nil, unit.uid)
                end
            end
            if ui_cache_data:get_cache_data(cache_keys.battle_data_for_result) then
                ui_cache_data:del_cache_data(cache_keys.battle_data_for_result)
            end
            ui_cache_data:add_cache_data(cache_keys.battle_data_for_result, exp_data)
        end
    end
end
--endregion

--region 获取数据
---获取当前战斗场次
---@public
---@type AckBTLInfo
function battle_database:get_battle_number()
    return self.battle_number
end

---获取战斗类型
---@public
---@return EBattleType
function battle_database:get_battle_type()
    if self.battle_info ~= nil then
        return self.battle_info.battle_info.battle_type
    else
        return enum.proto.EBattleType.BATTLE_TYPE_NONE
    end
end

---获取本局战斗uid
---@public
---@return string
function battle_database:get_battle_uid()
    return self.battle_info.battle_info.battle_id
end

---获得本局战斗mid
---@public
---@return string
function battle_database:get_battle_mid()
    return self.battle_info.battle_info.battle_mid
end

---获得本局玩法ID
---@public
---@return string
function battle_database:get_game_id()
    return self.battle_info.battle_info.game_play_id
end


---获取剩余连续战斗数量
---@public
---@return number
function battle_database:get_remain_continuous_count()
    return self.battle_info.battle_info.remain_continuous_count
end

---获取战力PK信息
---@public
---@return BTLPkInfo
function battle_database:get_battle_pk_info()
    return self.battle_pk_info
end

---获取当前战斗模式
---@public
---@return battle_mode_type
function battle_database:get_mode_type()
    return self.mode_type
end

---获取操作模式
---@public
---@return battle_operation_mode
function battle_database:get_operation_mode()
    return self.operation_mode
end

---获取镜头操作模式
---@public
---@return battle_operation_mode
function battle_database:get_camera_operation_mode()
    return self.camera_operation_mode
end

---设置倍速数值
---@public
---@param default_speed number
---@return number
function battle_database:get_speed_up_num(default_speed)
    local speed = default_speed or 1
    ---@type BTLBattle
    local battle_data = data_mgr.get(table_names.BTLBattle.name, self:get_battle_mid())
    if nil ~= battle_data then
        local key_prefix = tostring(battle_data.Type)
        local account_key = game_data_manager.player:get_string_account()
        local final_key = battle_constant.BATTLE_SPEED_UP_NUMBER_KEY..account_key
        if Setting.HasKey(final_key, key_prefix) then
            self.speed_up_num = Setting.GetFloat(final_key, key_prefix)
        else
            self.speed_up_num = speed
        end
    end
    return self.speed_up_num
end

---获取当前回合数
---@public
---@return number
function battle_database:get_round_number()
    return self.round_number
end

---获取单位信息列表
---@public
---@return battle_unit_info[]
function battle_database:get_unit_info_list()
    return self.unit_info_list
end

---获取战斗单位数量(活着的)
---@public
---@return number
function battle_database:get_unit_info_list_count()
    local list = self:get_unit_info_list()
    local count = 0
    if list ~= nil then
        for i = 1, #list do
            if not list[i].is_death then
                count = count + 1
            end
        end
    end

    return count
end

---获取网络数据对象
---@public
---@param uid Ident
---@return net_object
function battle_database:get_net_object(uid)
    return net_mgr.get_object(uid)
end

---获取战斗单位信息根据站位
---@public
---@param uid Ident 单位id
---@return battle_unit_info
function battle_database:get_unit_info_by_uid(uid)
    local info_list = self.unit_info_list
    for i = 1, #info_list do
        local info = info_list[i]
        if info.uid == uid then
            return info
        end
    end

    return nil
end

---获得战斗初始魔力色相
---@public
---@return table<number, number>
function battle_database:get_default_magic_hues()
    return self.battle_info.battle_info.magic_hues
end

---获取敌人列表条件
---@private
---@param info battle_unit_info
---@return boolean
local our_unit_info_condition = function(info)
    return info.team_type == team_type_flag.OWN
end

---获取敌人列表条件
---@private
---@param info battle_unit_info
---@return boolean
local enemy_unit_info_condition = function(info)
    return info.team_type == team_type_flag.ENEMY
end

---获取己方的战斗单位列表
---@public
---@param buff_list battle_unit_info[]
---@return battle_unit_info[]
function battle_database:get_own_unit_info_list(buff_list)
    buff_list = buff_list or {}
    self:get_unit_info_list_by_condition(buff_list, our_unit_info_condition)

    return buff_list
end

---获取敌方战斗单位列表
---@public
---@param buff_list battle_unit_info[]
---@return battle_unit_info[]
function battle_database:get_enemy_unit_info_list(buff_list)
    buff_list = buff_list or {}
    self:get_unit_info_list_by_condition(buff_list, enemy_unit_info_condition)

    return buff_list
end

---获取战斗单位信息列表根据条件
---@public
---@param buff_list battle_unit_info[]
---@param filter_func fun(info:battle_unit_info)
function battle_database:get_unit_info_list_by_condition(buff_list, filter_func)
    helper.assert(filter_func ~= nil, "filter function is invalid")

    buff_list = buff_list or {}
    local count = #buff_list

    ---@type battle_unit_info[]
    local unit_info_list = self:get_unit_info_list()
    for i = 1, #unit_info_list do
        local unit_info = unit_info_list[i]
        if filter_func(unit_info) then
            count = count + 1
            buff_list[count] = unit_info
        end
    end

    return buff_list
end

---获取下一个战斗数据
---@public
---@return AckBTLAction | AckBTLInfo | AckBTLEndInfo
function battle_database:get_next_battle_data()
    return self.battle_data_queue:dequeue()
end

---获取战斗数据数量
---@public
---@return number
function battle_database:get_battle_data_count()
    return self.battle_data_queue:count()
end

---获得是否跳过大招动画设置
---@public
---@param caster_uid Ident
---@return boolean ture=跳过必杀，false=不跳过
function battle_database:get_is_jump_big_skill_ue(caster_uid)
    self.is_jump_big_skill_ue = game_data_manager.player.player_settings.kill_animation == enum_common.kill_animation_type.CLOSE

    --如果跳过必杀，则再判断每个角色每天是不是第一次(仅PVE模式)
    if self.is_jump_big_skill_ue and self.mode_type == battle_mode_type.PVE then
        local is_first = game_data_manager.battle_record:role_everyday_is_first_play_super_skill(caster_uid)
        if is_first then
            --每天第一次播放，强制正常播放
            self.is_jump_big_skill_ue = false
        end
    end

    local unit_info = self:get_unit_info_by_uid(caster_uid)
    return unit_info.unit_type ~= unit_type_flag.MONSTER and self.is_jump_big_skill_ue
end

---获取单位站位点位数据
---@private
---@param team team_type_flag 队伍
---@param pos_index number 位置索引
---@return BattleUnitIndexPoint
function battle_database:get_unit_index_point(team, pos_index)
    ---@type BattleUnitPoint
    local unit_point
    if team == team_type_flag.OWN then
        unit_point = self.map_point_info.OwnUnitPoint
    elseif team == team_type_flag.ENEMY then
        unit_point = self.map_point_info.EnemyUnitPoint
    end

    helper.assert(unit_point ~= nil, 'invalid unit_point, team = ', helper.get_enum_name(team_type_flag, team))

    ---@type BattleUnitIndexPoint
    local index_point = unit_point.Map[pos_index]
    helper.assert(index_point ~= nil, 'invalid BattleUnitIndexPoint, pos_index = ', pos_index)

    return index_point
end

---获取战场观察镜头信息
---@public
---@return MapCameraInfo
function battle_database:get_battlefield_camera_viewpoint()
    ---@type boolean 是否有大体形的单位
    local is_boss_fight = false
    ---@type battle_unit_info[]
    local unit_info_list = self:get_unit_info_list()
    for i = 1, #unit_info_list do
        local unit_info = unit_info_list[i]
        if unit_info.body_type == role_body_type.LARGE or unit_info.body_type == role_body_type.HUGE then
            is_boss_fight = true
            break
        end
    end

    ---@type MapCameraInfo
    local camera_info
    if not is_boss_fight then
        camera_info = self.map_point_info.BattlefieldViewingPointCommon
    else
        camera_info = self.map_point_info.BattlefieldViewingPointBoss
    end

    return camera_info
end

---获取出场点位信息
---@public
---@param team_type team_type_flag
---@return MapCameraInfo
function battle_database:get_battle_appear_camera_point(team_type)
    ---@type MapPoint
    local appear_point
    if team_type == team_type_flag.OWN then
        appear_point = self.map_point_info.OwnGroupAttack.AppearPoint
    elseif team_type == team_type_flag.ENEMY then
        appear_point = self.map_point_info.EnemyGroupAttack.AppearPoint
    else
        helper.error("team error, team = ", helper.get_enum_name(team_type_flag, team_type))
    end

    return appear_point
end

---获取群攻点位
---@public
---@param team_type team_type_flag
---@return BattleTeamPointData
function battle_database:get_team_group_point(team_type)
    local point
    if team_type == team_type_flag.OWN then
        point = self.map_point_info.OwnGroupAttack
    elseif team_type == team_type_flag.ENEMY then
        point = self.map_point_info.EnemyGroupAttack
    else
        helper.error("team error, team = ", helper.get_enum_name(team_type_flag, team_type))
    end

    return point
end

---获取战斗结果数据
---@public
---@return AckBTLEndInfo
function battle_database:get_battle_result_data()
    return self.btl_end_info
end

---检测检测过最后一击
---@public
---@return boolean
function battle_database:get_has_final_attack()
    return self.has_final_attack
end

---获取战斗常量设置
---@public
---@return table<string, any>
function battle_database:get_setting_const()
    return self.setting_const
end

---获取是否正在战斗结束前的触发器
---@public
---@return boolean
function battle_database:get_is_execute_trigger()
    return self.is_execute_trigger
end

---获取单位技能列表
---@public
---@param uid Ident
---@param skill_list string[]
---@return string[]
function battle_database:get_unit_skill_list(uid, skill_list)
    skill_list = skill_list or {}
    
    local net_object = self:get_net_object(uid)
    if net_object == nil then return skill_list end
    
    local unit_info = self:get_unit_info_by_uid(uid)

    ---@type record
    local skill_record
    ---@type number
    local skill_id_column
    if unit_info.unit_type == unit_type_flag.WITCH then
        skill_record = net_object:get_record(table_names.Witch.records.Skill.name)
        skill_id_column = table_names.Witch.records.Skill.columns.SkillId
    elseif unit_info.unit_type == unit_type_flag.MONSTER then
        skill_record = net_object:get_record(table_names.Monster.records.Skill.name)
        skill_id_column = table_names.Monster.records.Skill.columns.SkillId
    elseif unit_info.unit_type == unit_type_flag.NPC then
        skill_record = net_object:get_record(table_names.Witch.records.Skill.name)
        skill_id_column = table_names.Witch.records.Skill.columns.SkillId
    else
        helper.error('Unit type error, type = ', unit_info.unit_type)
    end
    
    if skill_record ~= nil then
        ---@type table<number, record_row>
        local record_rows = skill_record:get_rows()
        if record_rows ~= nil then
            for _, record_row in pairs(record_rows) do
                local skill_id = record_row:get_value(skill_id_column)
                if not str_is_nil_or_empty(skill_id) then
                    skill_list[#skill_list + 1] = skill_id
                end
            end
        end
    end

    return skill_list
end

---获取音量设置
---@public
---@return number, number
function battle_database:get_sound_volume_setting()
    local settings = game_data_manager.player.player_settings
    return (settings.role_sound_volume or 0) / 100, (settings.env_sound_volume or 0) / 100
end

---获取单位站位偏移
---@protected
---@param point_info MapPoint RoleRes表id
---@param role_res_mid string RoleRes表id
---@return number, number, number, number, number, number
function battle_database:get_unit_position_offset(point_info, role_res_mid)
    local unit_pos_x = point_info.Position.X
    local unit_pos_y = point_info.Position.Y
    local unit_pos_z = point_info.Position.Z

    local pos_offset_x, pos_offset_y, pos_offset_z = 0, 0, 0
    
    -- 单位点位偏移数据
    ---@type table<string, BattleOffsetInfo>
    local offset_data_map = data_mgr.get_all(battle_constant.BATTLE_OFFSET_DATA_NAME)
    local offset_data = offset_data_map[role_res_mid]
    if offset_data ~= nil then
        pos_offset_x, pos_offset_y, pos_offset_z = LuaUtil.RotationVector(point_info.Rotation.X,
                point_info.Rotation.Y, point_info.Rotation.Z, offset_data.PosOffset.X, offset_data.PosOffset.Y,
                offset_data.PosOffset.Z)
    end

    unit_pos_x = unit_pos_x + pos_offset_x
    unit_pos_y = unit_pos_y + pos_offset_y
    unit_pos_z = unit_pos_z + pos_offset_z
    
    return unit_pos_x, unit_pos_y, unit_pos_z, pos_offset_x, pos_offset_y, pos_offset_z
end

---获取技能偏移数据
---@public
---@param role_res_mid string RoleRes表id
---@param director_id string 技能导演id
---@return number, number, number
function battle_database:get_skill_offset_data(role_res_mid, director_id)
    ---@type table<string, BattleOffsetInfo>
    local offset_data_map = data_mgr.get_all(battle_constant.BATTLE_OFFSET_DATA_NAME)
    ---@type BattleOffsetInfo
    local offset_info = offset_data_map[role_res_mid]
    if offset_info ~= nil then
        for i = 1, #offset_info.OffsetDataList do
            local offset_data = offset_info.OffsetDataList[i]
            if offset_data.DirectorId == director_id then
                return offset_data.Offset.X, offset_data.Offset.Y, offset_data.Offset.Z
            end
        end
    end
    
    return 0, 0, 0
end
--endregion

--region 检测数据
---检测是否存在战斗信息
---@public
---@return boolean
function battle_database:check_has_battle_info()
    return self.battle_info ~= nil
end

---检测单位是己方队伍的
---@public
---@param uid Ident
---@return boolean
function battle_database:check_unit_own_team(uid)
    if uid == nil then
        helper.error('invalid uid when check if it is own team')
        return false
    end

    local unit_info = self:get_unit_info_by_uid(uid)
    if unit_info ~= nil then
        return unit_info.team_type == team_type_flag.OWN
    else
        helper.error('not found battle info, uid = ', helper.to_string(uid))
    end
end

---检测是否与当前玩家是同一个队伍
---@public
---@param team_uid Ident
---@return team_type_flag
function battle_database:check_same_team_with_player(team_uid)
    if team_uid == nil then
        helper.error('invalid team_uid when check same team')
        return team_type_flag.OWN
    end

    ---@type Ident 己方队伍id
    local team_id = self.battle_info.battle_info.team_id
    helper.assert(team_id ~= nil, "not found battle_info team_id")

    local team_type = team_type_flag.OWN
    if team_uid.svrid == team_id.svrid and team_uid.index == team_id.index then
        team_type = team_type_flag.OWN
    else
        team_type = team_type_flag.ENEMY
    end

    return team_type
end

---检测是否是第一场战斗
---@public
---@return boolean
function battle_database:check_is_first_battle()
    return self:get_battle_number() == 1
end

---根据配置判断是否要跳过最后一击
---@public
---@return boolean
function battle_database:check_skip_final_attack()
    ---@type BTLBattle
    local battle_data = data_mgr.get(table_names.BTLBattle.name, self:get_battle_mid())
    local skip_flag = (battle_data.BattleSetData >> 1) & 1 -- 右数第2位
    return skip_flag == 1
end

---根据配置判断是否跳过结算演出
---@public
---@return boolean
function battle_database:check_skip_battle_settlement()
    ---@type BTLBattle
    local battle_data = data_mgr.get(table_names.BTLBattle.name, self:get_battle_mid())
    local skip_flag = (battle_data.BattleSetData >> 0) & 1 -- 右数第1位
    return skip_flag == 1
end
--endregion

---清理
---@public
function battle_database:clear()
    local clear_array = helper.clear_array

    local unit_info_list = self.unit_info_list
    if unit_info_list ~= nil then
        for i = 1, #unit_info_list do
            local uid = unit_info_list[i].uid
            local net_object = self:get_net_object(uid)
            if net_object ~= nil then
                net_object:remove_property_listener(table_names.Witch.properties.Hp, self.set_new_unit_hp_change_value, self)
                net_mgr.remove_object(uid)
            end
        end
        clear_array(unit_info_list)
    end

    -- 卸载配置文件
    local config_list = self.config_name_list
    for key, config_name in ipairs(config_list) do
        data_mgr.unload(config_name)
        config_list[key] = nil
    end

    self.is_execute_trigger = nil
    self.setting_const = nil
    self.has_final_attack = nil
    self.btl_end_info = nil
    self.is_jump_big_skill_ue = nil
    self.speed_up_num = nil
    self.operation_mode = nil
    self.camera_operation_mode = nil
    self.mode_type = nil
    self.action_queue = nil
    self.round_number = nil
    self.battle_data_queue:clear()
    self.battle_pk_info = nil
    self.battle_number = 1
    self.battle_info = nil
    self.controller = nil
end

---销毁
---@public
function battle_database:dispose()
    self:clear()

    self.config_name_list = nil
    self.unit_info_list = nil
    self.battle_data_queue = nil
    self.battle_number = nil
end

return battle_database