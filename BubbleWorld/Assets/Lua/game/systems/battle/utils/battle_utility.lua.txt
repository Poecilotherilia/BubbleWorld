---
--- Generated by wuhaijun
--- File name : battle_utility.lua.txt
--- DateTime : 2021/09/15
--- Description : 战斗常用工具
---

local helper = battle_helper
local data_mgr = data
local table_names = tables
local is_nil_or_empty = string.is_nil_or_empty
local camera_mgr = camera_manager
local df_asset_type = df.enum.asset_type
local enum = enum
local enum_battle = enum.battle
local team_type_flag = enum_battle.team_type_flag
local unit_type_flag = enum_battle.unit_type_flag
local damage_number_type = enum_battle.damage_number_type
local battle_exit_type = enum_battle.battle_exit_type
local role_body_type = enum.common.role_body_type
local EBattleType = enum.proto.EBattleType
local enemy_type_flag = enum.common.enemy_type_flag
local game_util = require "game/utils/game_util"

---@type stack
local stack = require 'framework/basic/stack'
---@type hashset
local hashset = require 'framework/basic/hashset'
---@type ident
local ident = require(helper.path.battle_utils .. 'ident')
---@type battle_constant
local battle_constant = require(helper.path.battle_utils .. 'battle_constant')

---@type queue
local queue = require 'framework/basic/queue'
---@type battle_components
local battle_components = require(helper.path.battle_components)

---@class battle_utility
local battle_utility = { cname = "battle_utility" }

--region 生成实体
---生成队伍实体
---@public
---@param context context
---@param team_flag team_type_flag
---@return table<number, number>
function battle_utility.generate_group_entity(context, team_flag)
    local group_dict = {}
    ---@type BattleTeamPointData
    local team_point_data = context.database:get_team_group_point(team_flag)
    
    for index, point_data in pairs(team_point_data.MeleeGroupAttackDict) do
        local entity = context:create_entity()
        
        entity:add_component(battle_components.eid, entity.eid)
        entity:add_component(battle_components.team_flag, team_flag)
        entity:add_component(battle_components.asset_data, '', battle_constant.RENDER_BATTLE_TEAM)

        local team_uid
        if team_flag == team_type_flag.OWN then
            team_uid = ident.new(team_flag + -10000, index)
        elseif team_flag == team_type_flag.ENEMY then
            team_uid = ident.new(team_flag + -10000, index)
        end
        ---@type battle_unit_info
        local unit_info =
        {
            uid = team_uid,
            unit_type = unit_type_flag.OBJECT,
            team_type = team_flag,
            index_point_info = point_data,
            is_death = false,
            is_init = true,
        }
        entity:add_component(battle_components.unit_info, unit_info)

        group_dict[index] = entity.eid
    end
    
    return group_dict
end

---生成单位实体
---@public
---@param context context
---@param unit_info battle_unit_info
---@param is_active boolean 是否激活
---@param state_mid string 单位状态
---@return entity
function battle_utility.generate_unit_entity(context, unit_info, is_active, state_mid)
    -- 生成单位实体
    local unit_entity = context:create_entity()
    unit_entity:add_component(battle_components.eid, unit_entity.eid)
    unit_entity:add_component(battle_components.uid, unit_info.uid)
    unit_entity:add_component(battle_components.unit_info, unit_info)

    unit_entity:add_component(battle_components.position, unit_info.position:clone())
    unit_entity:add_component(battle_components.rotation, unit_info.rotation:clone())
    unit_entity:add_component(battle_components.scale, unit_info.scale:clone())
    unit_entity:add_component(battle_components.asset_data, unit_info.res_path, battle_constant.RENDER_BATTLE_UNIT)
    
    -- 预加载技能资源
    if is_active == nil or is_active then
        unit_entity:add_component(battle_components.unit_active, true)
        unit_entity:add_component(battle_components.preload_skill, context.database:get_unit_skill_list(unit_info.uid))
    else
        unit_entity:add_component(battle_components.unit_active, false)
    end

    -- 单位状态
    local idle_state = table_names.BTLState.ids.BTLState_Idle
    if state_mid == nil then
        unit_entity:add_component(battle_components.unit_state, idle_state, stack.new(), hashset.new(), idle_state)
    else
        local history_state = stack.new()
        history_state:push(idle_state)
        unit_entity:add_component(battle_components.unit_state, state_mid, history_state, hashset.new(), state_mid)
    end
    
    -- 初始化
    unit_info.is_death = false
    unit_info.death_type = nil
    unit_info.is_init = true
    
    helper.log("generate unit entity, roleResId = ", unit_info.role_res_mid, ", unit_eid = ", unit_entity.eid)
    
    return unit_entity
end

---生成子弹
---@public
---@param context context
---@param res_path string 资源路径
---@param bullet_data generate_bullet_data 子弹配置数据
---@param is_hiding boolean 是否是隐形子弹，true=隐形，不创建渲染层，false=创建渲染层
---@return entity 子弹实体
function battle_utility.generate_bullet_entity(context, res_path, bullet_data, is_hiding)
    local entity = context:create_entity()
    entity:add_component(battle_components.eid, entity.eid)
    entity:add_component(battle_components.bullet_info, bullet_data)
    if not is_hiding then
        entity:add_component(battle_components.asset_data, res_path, battle_constant.RENDER_BATTLE_BULLET)
    end

    return entity
end
--endregion

---检测目标位置对象是否存活
---@private
---@param index number
---@param unit_list battle_unit_info[]
---@return boolean
local check_unit_is_live = function(index, unit_list)
    for i = 1, #unit_list do
        if unit_list[i].pos_index == index then
            return not unit_list[i].is_death
        end
    end
    return false
end

---获取小组索引
---@private
---@param context context
---@param team_type team_type_flag 目标方法名字
---@return number
function battle_utility.get_team_group_index(context, team_type)
    local unit_list = context:get_free_table("behavior_move_to_position.get_team_group_index")
    if team_type == team_type_flag.ENEMY then
        context.database:get_enemy_unit_info_list(unit_list)
    elseif team_type == team_type_flag.OWN then
        context.database:get_own_unit_info_list(unit_list)
    end

    local group_index = -1
    if check_unit_is_live(3, unit_list) and check_unit_is_live(4, unit_list) then
        group_index = 1
    elseif check_unit_is_live(1, unit_list) and check_unit_is_live(4, unit_list) then
        group_index = 2
    elseif check_unit_is_live(2, unit_list) and check_unit_is_live(3, unit_list) then
        group_index = 3
    elseif check_unit_is_live(1, unit_list) and check_unit_is_live(2, unit_list) then
        group_index = 1
    elseif check_unit_is_live(1, unit_list) and check_unit_is_live(3, unit_list) then
        group_index = 3
    elseif check_unit_is_live(2, unit_list) and check_unit_is_live(4, unit_list) then
        group_index = 2
    end

    context:recycle_free_table(unit_list)

    return group_index
end

---获取队伍组实体id
---@public
---@param context context
---@param team_type team_type_flag
---@param group_index number
function battle_utility.get_team_group_eid(context, team_type, group_index)
    if team_type == nil or group_index == -1 then return end
    
    local battle_field = context:get_unique_component(battle_components.battle_field)
    ---@type table<team_type_flag, table<number, number>>
    local team_eid_dict = battle_field:get_component(battle_components.team_group).value
    return team_eid_dict[team_type][group_index]
end

---设置虚拟相机信息
---@public
---@param v_camera Cinemachine.CinemachineVirtualCamera
---@param camera_info MapCameraInfo
function battle_utility.set_virtual_camera_info(v_camera, camera_info)
    if v_camera == nil or camera_info == nil then return end
    
    local pos = camera_info.Point.Position
    v_camera:SetPosition(pos.X, pos.Y, pos.Z)
    local rot = camera_info.Point.Rotation
    v_camera:SetRotation(rot.X, rot.Y, rot.Z)
    local sca = camera_info.Point.Scale
    v_camera:SetLocalScale(sca.X, sca.Y, sca.Z)

    local new_Lens = v_camera.m_Lens
    new_Lens.FieldOfView = camera_info.FieldOfView
    new_Lens.FarClipPlane = camera_info.FarClipPlane
    v_camera.m_Lens = new_Lens
end

---播放单位动作
---@public
---@param context context
---@param entity entity
---@param action_mid string
---@param finish_callback fun(eid:number) 播放完成回调
---@param is_loop boolean 是否循环
---@param fade_time number 融合时间
---@return boolean 是否正常播放
function battle_utility.unit_play_action(context, entity, action_mid, finish_callback, is_loop, fade_time)
    ---@type Action
    local action_data = data_mgr.get(table_names.Action.name, action_mid)
    if action_data == nil then
        helper.error("没有找到Action数据, id = ", action_mid)
        if finish_callback ~= nil then finish_callback() end
    end

    ---@type battle_renderer
    local render_world = context.renderer
    
    ---@type number 播放速度
    local time_scale = context.controller:get_time_scale()
    ---@type base_render
    local unit_render = render_world:get_render_unit(entity.eid)
    if unit_render == nil then
        helper.error("not found base_render, eid = ", entity.eid)
        if finish_callback ~= nil then finish_callback() end
        return false
    end

    -- 移除掉上次动作的关联内容
    battle_utility.remove_pre_action_content(context, entity, unit_render.current_action_mid)
    -- 设置当前动作id
    unit_render.current_action_mid = action_mid
    
    helper.log("unit(", helper.to_string(entity.eid), "), play animation clip, clip_path = ", action_data.Name)
    
    -- 播放动画片段
    if not is_nil_or_empty(action_data.Name) then
        unit_render:play_animation(action_data.Name, time_scale, fade_time, is_loop, finish_callback)
    else
        helper.error("动画片段路径无效, Action表id = ", action_data.Id)
        if finish_callback ~= nil then finish_callback() end
    end

    -- 播放特效
    for i = 1, #action_data.EffectId do
        battle_utility.show_effect(context, entity, action_data.EffectId[i])
    end

    -- 播放语音
    if not is_nil_or_empty(action_data.TalkAudioId) then
        unit_render:play_sound(action_data.TalkAudioId, true)
    end
    
    -- 播放音效
    if not is_nil_or_empty(action_data.AudioId) then
        unit_render:play_sound(action_data.AudioId)
    end
    
    return true
end

---移除掉动作的关联内容
---@public
---@param context context
---@param entity entity
---@param action_mid string
function battle_utility.remove_pre_action_content(context, entity, action_mid)
    if is_nil_or_empty(action_mid) then return end

    helper.log("unit(", helper.to_string(entity.eid), "), remove action associated content, action_mid = ", action_mid)

    ---@type Action
    local action_data = data_mgr.get(table_names.Action.name, action_mid)
    if action_data == nil then return end
    
    -- 移除特效
    for i = 1, #action_data.EffectId do
        battle_utility.remove_effect(entity, action_data.EffectId[i])
    end
    
    ---@type base_render 渲染单位
    -- local render_unit = context.renderer:get_render_unit(entity.eid)

    -- 移除语音
    --if not is_nil_or_empty(action_data.TalkAudioId) then
    --    render_unit:remove_sound_handle(action_data.TalkAudioId)
    --end

    -- 移除音效
    --if not is_nil_or_empty(action_data.AudioId) then
    --    render_unit:remove_sound_handle(action_data.AudioId)
    --end
end

---显示特效
---@public
---@param context context
---@param entity entity
---@param effect_mid string 特效配置id
---@param is_sub_obj boolean 是否称为子物体
---@param pos_x number x坐标
---@param pos_y number y坐标
---@param pos_z number z坐标
---@param point_name string 挂点名字
function battle_utility.show_effect(context, entity, effect_mid, is_sub_obj, pos_x, pos_y, pos_z, point_name)
    if is_nil_or_empty(effect_mid) or effect_mid == "--" then
        helper.error("invalid show effect id, effect_mid = ", effect_mid)
        return
    end

    if is_sub_obj == nil then
        is_sub_obj = true
    end

    ---@type queue
    local effect_data_queue
    -- 获取特效组件
    local comp = entity:get_component(battle_components.show_effect)
    if comp ~= nil then
        effect_data_queue = comp.value
    else
        effect_data_queue = queue.new()
    end

    -- 特效数据
    ---@type render_effect_data
    local effect_data = context:get_free_table("battle_utility.show_effect_data")
    effect_data.effect_mid = effect_mid
    effect_data.is_sub_obj = is_sub_obj
    effect_data.position_x = pos_x or 0
    effect_data.position_y = pos_y or 0
    effect_data.position_z = pos_z or 0
    effect_data.point_name = point_name
    effect_data_queue:enqueue(effect_data)

    entity:replace_component(battle_components.show_effect, effect_data_queue)
end

---移除特效
---@public
---@param entity entity
function battle_utility.remove_effect(entity, effect_mid)
    if is_nil_or_empty(effect_mid) or effect_mid == "--" then
        helper.error("invalid remove effect id, effect_mid = ", effect_mid)
        return
    end

    ---@type queue
    local effect_queue
    ---@type { value:queue } string 特效表ID队列
    local comp = entity:get_component(battle_components.remove_effect)
    if comp ~= nil then
        effect_queue = comp.value
    else
        effect_queue = queue.new()
    end

    effect_queue:enqueue(effect_mid)
    entity:replace_component(battle_components.remove_effect, effect_queue)
end

---显示材质球操作
---@public
---@param entity entity 目标实体
---@param operation battle_material_operation_config 材质球操作数据
function battle_utility.show_material_operation(entity, operation)
    if operation == nil then return end

    ---@type queue battle_material_operation_config 队列
    local data_queue
    local comp = entity:get_component(battle_components.material_data)
    if comp ~= nil then
        data_queue = comp.value
    else
        data_queue = queue.new()
    end
    
    data_queue:enqueue(operation)
    
    entity:replace_component(battle_components.material_data, data_queue)
end

---播放镜头动画
---@public
---@param context context
---@param uid Ident
---@param acton_mid string
---@param finish_callback fun() 结束回调
---@param enter_blend_type camera_blend_type 相机进入融合类型
---@param enter_blend_time number 相机进入融合时间
---@param has_exit boolean 是否有退出融合
---@param exit_blend_type camera_blend_type 相机退出融合类型
---@param exit_blend_time number 相机退出融合时间
---@return number 相机ID
function battle_utility.show_camera_animation(context, uid, acton_mid, finish_callback, enter_blend_type, enter_blend_time,
                                              has_exit, exit_blend_type, exit_blend_time)
    local renderer = context.renderer
    local controller = context.controller
    local res_loader, res_pool = renderer:get_res_loader_and_pool()
    local behavior, camera_id = renderer:get_skill_camera_behavior_and_id()
    local pool_transform = renderer:get_pool_transform()
    local time_scale = controller:get_time_scale()
    exit_blend_time = exit_blend_time or 0

    ---@type Action
    local action_data = data_mgr.get(table_names.Action.name, acton_mid)
    if action_data == nil then
        helper.error("not found Action data, acton_mid = ", acton_mid)
        return
    end
    local clip_path = action_data.Name
    if clip_path == nil then
        helper.error("not found boss_clip_path, ActionId = ", action_data.Id)
        return
    end

    -- 将技能相机节点放入战斗单位根节点下
    local entity = context:get_entity_by_primary_index(battle_components.uid, uid)
    local render_unit = renderer:get_render_unit(entity.eid)
    behavior:SetParent(render_unit.gameobject)

    -- 完成回调
    local on_finished_callback = function()
        if finish_callback ~= nil then
            finish_callback()
        end
    end
    
    ---回收处理
    local recycle_handle = function()
        behavior:SetParent(pool_transform)
        on_finished_callback()
    end
    
    -- 隐藏处理
    local exit_handle = function()
        if not has_exit then
            on_finished_callback()
            return
        end
        
        camera_mgr.hide_virtual_camera(camera_id, exit_blend_type, exit_blend_time)
        if exit_blend_time > 0 then
            -- 延迟回调
            controller:add_timer(exit_blend_time * 1000, recycle_handle)
        else
            recycle_handle()
        end
    end

    -- 重置相机位置
    local v_camera =  camera_mgr.get_virtual_camera(camera_id)
    v_camera:SetLocalPosition(0, 0, 0)

    -- 播放相机动画
    behavior:PlayAnimation(clip_path, time_scale, exit_handle, res_loader, res_pool, 0)
    -- 显示技能虚拟相机
    camera_mgr.show_virtual_camera(camera_id, enter_blend_type, enter_blend_time)
    
    return camera_id
end

---设置技能镜头起始流程
---@public
---@param context context
---@param caster_uid Ident 施法者uid
---@param skill_type skill_camera_skill_type 技能类型
---@param flow_type skill_camera_flow_type 流程类型
---@param event_type skill_camera_event_type 事件类型
---@param target_uid Ident 技能目标uid
---@param blend_time number 镜头融合时间
---@param action_name string 相机动画名字
function battle_utility.set_skill_camera_starting_flow(context, caster_uid, skill_type, flow_type, event_type,
                                                       target_uid, blend_time, action_name)
    ---@type entity 施法者实体
    local caster_entity = context:get_entity_by_primary_index(battle_components.uid, caster_uid)
    ---@type number 技能目标实体id
    local target_eid
    if target_uid ~= nil then
        ---@type entity 技能目标实体
        local target_entity = context:get_entity_by_primary_index(battle_components.uid, target_uid)
        if target_entity ~= nil then
            target_eid = target_entity.eid
        end
    end

    battle_utility.set_skill_camera_component_data(caster_entity, skill_type, event_type, flow_type, target_eid, blend_time, action_name)
end

---设置技能镜头后续流程
---@public
---@param context context
---@param caster_uid Ident
---@param target_eid number
---@param event_type skill_camera_event_type 事件点
---@param blend_time number 镜头融合时间
---@param action_name string 相机动画名字
---@param look_at_time_ratio number 相机看向目标时间占比
function battle_utility.set_skill_camera_following_flow(context, caster_uid, target_eid, event_type, blend_time, action_name, 
                                                        look_at_time_ratio)
    ---@type entity 施法者实体
    local caster_entity = context:get_entity_by_primary_index(battle_components.uid, caster_uid)

    -- 技能相机组件
    local skill_camera_comp = caster_entity:get_component(battle_components.skill_camera)
    if skill_camera_comp == nil then return end

    ---@type skill_camera_component_data
    local component_data = skill_camera_comp.value
    if component_data == nil then return end

    if component_data.event_type == nil or component_data.event_type < event_type then
        battle_utility.set_skill_camera_component_data(caster_entity, component_data.skill_type, event_type, component_data.flow_type, 
                target_eid, blend_time, action_name, look_at_time_ratio)
    end
end

---设置技能镜头组件数据
---@public
---@param entity entity
---@param skill_type skill_camera_skill_type
---@param event_type skill_camera_event_type 事件点
---@param flow_type skill_camera_flow_type
---@param target_eid number
---@param blend_time number 镜头融合时间
---@param action_name string 相机动画名字
---@param look_at_time_ratio number 相机看向目标时间占比
function battle_utility.set_skill_camera_component_data(entity, skill_type, event_type, flow_type, target_eid, blend_time,
                                                        action_name, look_at_time_ratio)
    helper.log_skill('set skill_camera_component data, skill_type = ', skill_type, ', event_type = ', event_type, ', flow_type = ', flow_type)
    
    local skill_camera_comp = entity:get_component(battle_components.skill_camera)

    ---@type skill_camera_component_data
    local component_data
    if skill_camera_comp ~= nil then
        component_data = skill_camera_comp.value
    else
        component_data = {}
    end
    
    component_data.skill_type = skill_type
    component_data.event_type = event_type
    component_data.flow_type = flow_type
    component_data.target_eid = target_eid
    component_data.blend_time = blend_time
    component_data.action_name = action_name
    component_data.look_at_time_ratio = look_at_time_ratio

    entity:replace_component(battle_components.skill_camera, component_data)
end

---设置技能镜头其他流程
---@public
---@param context context
---@param caster_uid Ident
---@param action_name string 相机动画名字
function battle_utility.set_skill_camera_other_flow(context, caster_uid, action_name)
    local other_type = enum_battle.skill_camera_skill_type.OTHER
    local prepare_type = enum_battle.skill_camera_event_type.PREPARE_SKILL
    local blend_time = context.database:get_setting_const().KW_SKILL_V_CAMERA_BLEND_TIME

    -- 设置镜头
    battle_utility.set_skill_camera_starting_flow(context, caster_uid, other_type, nil,
            prepare_type, nil, blend_time, action_name)
end

--region 技能预加载相关
---设置预加载技能列表
---@public
---@param skill_mid string
---@param skill_list[] string
---@return boolean
function battle_utility.set_preload_skill_list(skill_mid, skill_list)
    local is_changed = true
    if skill_list ~= nil then
        for i = 1, #skill_list do
            if skill_list[i] == skill_mid then
                is_changed = false
                break
            end
        end

        if is_changed then
            skill_list[#skill_list + 1] = skill_mid
        end
    else
        is_changed = false
    end
    
    return is_changed
end

---获取预加载技能列表
---@public
---@param context context
---@param uid Ident
---@return string[], entity
function battle_utility.get_preload_skill_list(context, uid)
    ---@type string[]
    local skill_list

    ---@type entity
    local entity = context:get_entity_by_primary_index(battle_components.uid, uid)
    -- 单位实体有可能不存在，比如加了buff后单位死亡，当buff生效时，会出现这种数据
    if entity == nil then return end
    
    ---@type preload_skill_component_data
    local preload_skill_comp = entity:get_component(battle_components.preload_skill)
    if preload_skill_comp ~= nil then
        skill_list = preload_skill_comp.skill_list
    else
        skill_list = {}
    end
    
    return skill_list, entity
end

---预加载全部技能特效
---@public
---@param database battle_database
---@param renderer battle_renderer
function battle_utility.preload_all_skill_effect_handle(database, renderer)
    ---@type battle_unit_info[]
    local unit_info_list = database:get_unit_info_list()
    ---@type string[]
    local skill_mid_list = {}
    
    for i = 1, #unit_info_list do
        local unit_info = unit_info_list[i]

        helper.clear_array(skill_mid_list)
        database:get_unit_skill_list(unit_info.uid, skill_mid_list)

        ---@type RoleRes
        local role_res_data = data_mgr.get(table_names.RoleRes.name, unit_info.role_res_mid)

        for j = 1, #skill_mid_list do
            ---@type BTLSkill
            local skill_data = data_mgr.get(table_names.BTLSkill.name, skill_mid_list[j])
            ---@type array2_string[]
            local director_array = skill_data.DirectorId
            for z = 1, #director_array do
                ---@type string 
                local director_id = director_array[z].Array[1]
                ---@type skill_director_data
                local director_data = data_mgr.get(battle_constant.SKILL_DIRECTOR_DATA_NAME, director_id)
                if director_data ~= nil then
                    for _, config_data in pairs(director_data.Map) do
                        -- 加载动作里的特效
                        for _, property_name in ipairs(config_data.RoleResList) do
                            local action_mid = role_res_data[property_name]
                            if not is_nil_or_empty(action_mid) then
                                ---@type Action
                                local action_data = data_mgr.get(table_names.Action.name, action_mid)
                                if action_data ~= nil then
                                    battle_utility.preload_skill_effect_assets(renderer, action_data.EffectId, false, true)
                                end
                            end
                        end

                        -- 加载受击特效
                        battle_utility.preload_skill_effect_assets(renderer, config_data.EffectIdList, false, true)
                    end
                end
            end
        end
    end
end

---预加载技能Actoin资源
---@public
---@param renderer battle_renderer
---@param action_mid string 动作表id
---@param is_sync boolean 是否同步加载
function battle_utility.preload_skill_action_handle(renderer, action_mid, is_sync)
    if is_nil_or_empty(action_mid) then return end

    ---@type Action
    local action_data = data_mgr.get(table_names.Action.name, action_mid)
    if action_data == nil then return end

    -- 动作
    if not is_nil_or_empty(action_data.Name) then
        if is_sync then
            renderer:preload_asset(action_data.Name, df_asset_type.animation_clip)
        else
            renderer:preload_asset_async(action_data.Name, df_asset_type.animation_clip)
        end
    end

    -- 特效
    battle_utility.preload_skill_effect_assets(renderer, action_data.EffectId, true)

    -- 音效
    battle_utility.preload_skill_audio_assets(renderer, action_data.TalkAudioId)
    battle_utility.preload_skill_audio_assets(renderer, action_data.AudioId)
end

---预加载特效资源
---@private
---@param renderer battle_renderer
---@param effect_list string[] 特效id列表
---@param load_audio boolean 是否加载关联的音效
---@param is_sync boolean 是否同步加载
---@param load_count number 加载特效数量
function battle_utility.preload_skill_effect_assets(renderer, effect_list, load_audio, is_sync, load_count)
    if effect_list == nil then return end

    for i = 1, #effect_list do
        local effect_mid = effect_list[i]
        if not is_nil_or_empty(effect_mid) then
            ---@type Effect
            local effect_data = data_mgr.get(table_names.Effect.name, effect_mid)
            if effect_data ~= nil then
                if not is_nil_or_empty(effect_data.Path) then
                    if is_sync then
                        renderer:preload_instance(effect_data.Path, load_count)
                    else
                        renderer:preload_instance_async(effect_data.Path, load_count)
                    end
                end

                -- 音效
                if load_audio then
                    battle_utility.preload_skill_audio_assets(renderer, effect_data.AudioId, is_sync)
                end
            end
        end
    end
end

---预加载Audio资源
---@private
---@param renderer battle_renderer
---@param mid string 表id
---@param is_sync boolean 是否同步加载
function battle_utility.preload_skill_audio_assets(renderer, mid, is_sync)
    if is_nil_or_empty(mid) then return end
    wwise_manager.preload_audio(mid)
    
    --
    ----wwise音频预加载
    ----if is_sync then
    ----    renderer:preload_asset(mid, df_asset_type.audio_clip)
    ----else
    ----    renderer:preload_asset_async(mid, df_asset_type.audio_clip)
    ----end
    --
    ----TODO: Obsolete Logic
    -----@type Audio
    --local audio_data = data_mgr.get(table_names.Audio.name, mid)
    --if audio_data == nil then return end
    --
    --if not is_nil_or_empty(audio_data.Path) then
    --    if is_sync then
    --        renderer:preload_asset(audio_data.Path, df_asset_type.audio_clip)
    --    else
    --        renderer:preload_asset_async(audio_data.Path, df_asset_type.audio_clip)
    --    end
    --end
end
--endregion

---退出战斗
---@public
function battle_utility.exit_battle()
    local database = system_manager.battle:get_data()
    ---@type EBattleType 战斗类型
    local battle_type = database:get_battle_type() or EBattleType.BATTLE_TYPE_NONE
    -- 主线剧情、支线剧情、探索战斗、探索副本战斗
    local is_special_flow = battle_type == EBattleType.BATTLE_TYPE_STORY or battle_type == EBattleType.BATTLE_TYPE_STORY_BRANCH
            or battle_type == EBattleType.BATTLE_TYPE_EXPLORE or battle_type == EBattleType.BATTLE_TYPE_EXPLORE_DUNGEON
            or battle_type == EBattleType.BATTLE_TYPE_EXPLORE_RAID
            or battle_type == EBattleType.BATTLE_TYPE_EXPLORE_TASK
    local exit_type = is_special_flow and battle_exit_type.SPECIAL or battle_exit_type.DEFAULT
    system_manager.battle:request_exit_battle(exit_type)
end

---重新挑战战斗
---@public
function battle_utility.rechallenge_battle()
    system_manager.battle:request_exit_battle(battle_exit_type.RECHALLENGE)
end

---战斗失败跳转退出战斗
---@public
function battle_utility.jump_out_of_battle()
    system_manager.battle:request_exit_battle(battle_exit_type.JUMP)
end

---获取近战相机点位信息
---@public
---@param unit_info battle_unit_info
---@return MapCameraInfo
function battle_utility.get_melee_camera_point_info(unit_info)
    local camera_info
    
    if unit_info.body_type == role_body_type.LARGE then
        camera_info = unit_info.index_point_info.MeleeCameraLargeInfo
    elseif unit_info.body_type == role_body_type.HUGE then
        camera_info = unit_info.index_point_info.MeleeCameraHugeInfo
    else
        camera_info = unit_info.index_point_info.MeleeCameraMediumInfo
    end
    
    return camera_info
end

---检测是否是boss
---@public
---@param unit_info battle_unit_info
---@return boolean
function battle_utility.check_boss_unit_info(unit_info)
    return not unit_info.is_death and unit_info.unit_type == unit_type_flag.MONSTER and unit_info.role_rare == enemy_type_flag.BOSS
end

---获得伤害类型
---@public
---@param damage BTLDamageInfo
---@return damage_number_type
function battle_utility.get_damage_number_type(damage)
    --暴击>克制>普通

    --暴击
    if game_util.is_bit_flag(damage.flags, 1) then
        return damage_number_type.CRIT_DAMAGE
    end

    --克制
    if game_util.is_bit_flag(damage.flags, 0) then
        return damage_number_type.RESTRAIN_DAMAGE
    end

    return damage_number_type.COMMON_DAMAGE
end

--region 助战

---是否是助战魔女 
---@public
---@param uid number
---@return number, ident
function battle_utility.get_is_assist_witch(uid)
    ---@type net_object
    local net_object = network.get_object(uid)
    if net_object then
        ---@type Ident
        local opt_player = ident.wrap(net_object:get_property_value(table_names.Witch.properties.AssociatedPlayer))
        ---@type Ident
        local have_player = ident.wrap(net_object:get_property_value(table_names.Witch.properties.PossessionPlayer))
        if not (opt_player == have_player) then
            return 1, have_player
        end
    end
end
--endregion

return battle_utility