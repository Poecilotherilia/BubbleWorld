---
--- Generated by wuhaijun
--- File name : quaternion.lua.txt
--- DateTime : 2021/11/29
--- Description : 
---

local helper = battle_helper

---@type vector3
local vector3 = require (helper.path.battle_utils .. 'vector3')

local math = math
local sin = math.sin
local cos = math.cos
local sqrt = math.sqrt
local asin = math.asin
local atan2 = math.atan
local rad2Deg = math.deg(1)
local pi = math.pi
local half_pi = pi * 0.5
local two_pi = 2 * pi
local negative_flip = -0.0001
local positive_flip = two_pi - 0.0001
local _next = { 2, 3, 1 }

---@class quaternion
local quaternion = {}
quaternion.__index = quaternion

---New
---@public
---@param x number
---@param y number
---@param z number
---@param w number
---@return quaternion
function quaternion.new(x, y, z, w)
    local t = {
        cname = 'quaternion',
        x = x or 0,
        y = y or 0,
        z = z or 0,
        w = w or 0,
    }
    return setmetatable(t, quaternion)
end

local new = quaternion.new

---克隆
---@public
---@return quaternion
function quaternion:clone()
    return new(self.x, self.y, self.z, self.w)
end

---拷贝
---@public
---@param t quaternion
function quaternion:copy(t)
    self.x = t.x
    self.y = t.y
    self.z = t.z
    self.w = t.w
end

---设置值
---@public
---@param x number
---@param y number
---@param z number
---@param w number
function quaternion:set(x, y, z, w)
    self.x = x or 0
    self.y = y or 0
    self.z = z or 0
    self.w = w or 0
end

---获取值
---@public
---@return number, number, number
function quaternion:get()
    return self.x, self.y, self.z, self.w
end

---获取归一化后的新四元数
---@public
---@return quaternion
function quaternion:normalize()
    local quat = self:Clone()
    quat:SetNormalize()
    return quat
end

---设置归一化
---@public
function quaternion:set_normalize()
    local n = self.x * self.x + self.y * self.y + self.z * self.z + self.w * self.w

    if n ~= 1 and n > 0 then
        n = 1 / sqrt(n)
        self.x = self.x * n
        self.y = self.y * n
        self.z = self.z * n
        self.w = self.w * n
    end
end

local function sanitize_euler(x, y, z)
    if x < negative_flip then
        x = x + two_pi
    elseif x > positive_flip then
        x = x - two_pi
    end

    if y < negative_flip then
        y = y + two_pi
    elseif y > positive_flip then
        y = y - two_pi
    end

    if z < negative_flip then
        z = z + two_pi
    elseif z > positive_flip then
        z = z + two_pi
    end

    return x * rad2Deg, y * rad2Deg, z * rad2Deg
end

---from http://www.geometrictools.com/Documentation/EulerAngles.pdf
---转欧拉角
---@public
---@return number, number, number
function quaternion:to_euler()
    local x = self.x
    local y = self.y
    local z = self.z
    local w = self.w

    local check = 2 * (y * z - w * x)

    local xx, yy, zz

    if check < 0.999 then
        if check > -0.999 then
            xx, yy, zz = sanitize_euler(-asin(check),
                    atan2(2 * (x * z + w * y), 1 - 2 * (x * x + y * y)),
                    atan2(2 * (x * y + w * z), 1 - 2 * (x * x + z * z)))
        else
            xx, yy, zz = sanitize_euler(half_pi, atan2(2 * (x * y - w * z), 1 - 2 * (y * y + z * z)), 0)
        end
    else
        xx, yy, zz = sanitize_euler(-half_pi, atan2(-2 * (x * y - w * z), 1 - 2 * (y * y + z * z)), 0)
    end

    return xx, yy, zz
end

---转欧拉角
---@public
---@return vector3
function quaternion:to_euler_angle()
    local x, y, z = self:to_euler()
    return vector3.new(x, y, z)
end

--region 静态方法
---@param a quaternion
---@param a quaternion
---@return quaternion
function quaternion.dot(a, b)
    return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w
end

---产生一个新的从from到to的四元数
---@public
---@param to vector3
---@param from vector3
---@param result quaternion
---@return quaternion
function quaternion.from_2_rotation(from, to, result)
    local quat = result or quaternion.new()
    quat:set_from_2_rotation1(from, to)
    return quat
end

---设置当前四元数为 from 到 to的旋转, 注意from和to同 forward平行会同unity不一致
---@public
---@param from vector3
---@param to vector3
---@return quaternion
function quaternion:set_from_2_rotation1(from, to)
    local v0 = from:set_normalize()
    local v1 = to:set_normalize()
    local vector_3 = vector3
    local d = vector_3.dot(v0, v1)

    if d > -1 + 1e-6 then
        local s = sqrt((1 + d) * 2)
        local invs = 1 / s
        local c = vector_3.cross(v0, v1) * invs
        self:set(c.x, c.y, c.z, s * 0.5)
    elseif d > 1 - 1e-6 then
        return new(0, 0, 0, 1)
    else
        local axis = vector_3.cross(vector_3.right, v0)

        if axis:sqr_magnitude() < 1e-6 then
            axis = vector_3.cross(vector_3.forward, v0)
        end

        self:set(axis.x, axis.y, axis.z, 0)
        return self
    end

    return self
end

---欧拉角转四元数
---@public
---@param x number
---@param y number
---@param z number
---@param result quaternion
---@return quaternion
function quaternion.euler(x, y, z, result)
    if y == nil and z == nil then
        y = x.y
        z = x.z
        x = x.x
    end

    x = x * 0.0087266462599716
    y = y * 0.0087266462599716
    z = z * 0.0087266462599716

    local sin_x = sin(x)
    x = cos(x)
    local sin_y = sin(y)
    y = cos(y)
    local sin_z = sin(z)
    z = cos(z)

    local xx = y * sin_x * z + sin_y * x * sin_z
    local yy = sin_y * x * z - y * sin_x * sin_z
    local zz = y * x * sin_z - sin_y * sin_x * z
    local ww = y * x * z + sin_y * sin_x * sin_z

    local q = result or new()
    q:set(xx, yy, zz, ww)

    return q
end

---插值
---@public
---@param q1 quaternion
---@param q2 quaternion
---@param t number
---@param result quaternion
---@return quaternion
function quaternion.lerp(q1, q2, t, result)
    t = quaternion.clamp(t, 0, 1)
    local q = result or new(0, 0, 0, 1)

    if quaternion.dot(q1, q2) < 0 then
        q.x = q1.x + t * (-q2.x - q1.x)
        q.y = q1.y + t * (-q2.y - q1.y)
        q.z = q1.z + t * (-q2.z - q1.z)
        q.w = q1.w + t * (-q2.w - q1.w)
    else
        q.x = q1.x + (q2.x - q1.x) * t
        q.y = q1.y + (q2.y - q1.y) * t
        q.z = q1.z + (q2.z - q1.z) * t
        q.w = q1.w + (q2.w - q1.w) * t
    end

    quaternion.set_normalize(q)

    return q
end

---限定值
---@private
---@param value number
---@param min number
---@param max number
---@return number
function quaternion.clamp(value, min, max)
    if value < min then
        value = min
    elseif value > max then
        value = max
    end

    return value
end

local tmp_forward_v3 = vector3.new()
local tmp_right_v3 = vector3.new()
local tmp_up_v3 = vector3.new()

---看向旋转
---@public
---@param forward vector3
---@param up vector3
---@param result quaternion
---@return quaternion
function quaternion.look_rotation(forward, up, result)
    ---@type vector3
    local tmp_forward = tmp_forward_v3
    tmp_forward:copy(forward)
    
    local mag = tmp_forward:magnitude()
    if mag < 1e-6 then
        log.error("input forward error,  forward = ", forward)
        return nil
    end
    tmp_forward:div(mag)

    ---@type vector3
    local tmp_up = tmp_up_v3
    tmp_up:copy(up or vector3.up)

    ---@type vector3
    local tmp_right = tmp_right_v3
    local right_x, right_y, right_z = vector3.cross_value(tmp_up, tmp_forward)
    tmp_right:set(right_x, right_y, right_z)
    tmp_right:set_normalize()

    local up_x, up_y, up_z = vector3.cross_value(tmp_forward, tmp_right)
    tmp_up:set(up_x, up_y, up_z)

    right_x, right_y, right_z = vector3.cross_value(tmp_up, tmp_forward)
    tmp_right:set(right_x, right_y, right_z)

    local t = tmp_right.x + tmp_up.y + tmp_forward.z
    if t > 0 then
        local x, y, z, w
        t = t + 1
        local s = 0.5 / sqrt(t)
        w = s * t
        x = (tmp_up.z - tmp_forward.y) * s
        y = (tmp_forward.x - tmp_right.z) * s
        z = (tmp_right.y - tmp_up.x) * s

        local ret = result or new()
        ret:set(x, y, z, w)
        ret:set_normalize()
        return ret
    else
        local rot = 
        {
            { tmp_right.x, tmp_up.x, tmp_forward.x },
            { tmp_right.y, tmp_up.y, tmp_forward.y },
            { tmp_right.z, tmp_up.z, tmp_forward.z },
        }

        local q = { 0, 0, 0 }
        local i = 1

        if tmp_up.y > tmp_right.x then
            i = 2
        end

        if tmp_forward.z > rot[i][i] then
            i = 3
        end

        local j = _next[i]
        local k = _next[j]

        local tt = rot[i][i] - rot[j][j] - rot[k][k] + 1
        local s = 0.5 / sqrt(tt)
        q[i] = s * tt
        local w = (rot[k][j] - rot[j][k]) * s
        q[j] = (rot[j][i] + rot[i][j]) * s
        q[k] = (rot[k][i] + rot[i][k]) * s

        local ret = result or new()
        ret:set(q[1], q[2], q[3], w)
        ret:set_normalize()
        return ret
    end
end

---乘以vector3
---@public
---@param q quaternion
---@param point vector3
---@param result vector3
---@return vector3
function quaternion.mul_vec3(q, point, result)
    local vec = result or vector3.new()

    local num = q.x * 2
    local num2 = q.y * 2
    local num3 = q.z * 2
    local num4 = q.x * num
    local num5 = q.y * num2
    local num6 = q.z * num3
    local num7 = q.x * num2
    local num8 = q.x * num3
    local num9 = q.y * num3
    local num10 = q.w * num
    local num11 = q.w * num2
    local num12 = q.w * num3

    vec.x = (((1 - (num5 + num6)) * point.x) + ((num7 - num12) * point.y)) + ((num8 + num11) * point.z)
    vec.y = (((num7 + num12) * point.x) + ((1 - (num4 + num6)) * point.y)) + ((num9 - num10) * point.z)
    vec.z = (((num8 - num11) * point.x) + ((num9 + num10) * point.y)) + ((1 - (num4 + num5)) * point.z)

    return vec
end

---比较
---@public
function quaternion.equals(a, b)
    return a.x == b.x and a.y == b.y and a.z == b.z and a.w == b.w
end
--endregion


--region 操作符重载
---乘法
---@param lhs quaternion
---@param rhs quaternion
---@return quaternion
quaternion.__mul = function(lhs, rhs)
    if lhs.cname == 'quaternion' then
        return quaternion.new((((lhs.w * rhs.x) + (lhs.x * rhs.w)) + (lhs.y * rhs.z)) - (lhs.z * rhs.y),
                (((lhs.w * rhs.y) + (lhs.y * rhs.w)) + (lhs.z * rhs.x)) - (lhs.x * rhs.z),
                (((lhs.w * rhs.z) + (lhs.z * rhs.w)) + (lhs.x * rhs.y)) - (lhs.y * rhs.x),
                (((lhs.w * rhs.w) - (lhs.x * rhs.x)) - (lhs.y * rhs.y)) - (lhs.z * rhs.z))
    elseif lhs.cname == 'vector3' then
        return lhs:mul_vec3(rhs)
    else
        log.error('multiplication parameter error, rhs = ', rhs)
    end
end

quaternion.__unm = function(q)
    return quaternion.new(-q.x, -q.y, -q.z, -q.w)
end

quaternion.__eq = function(lhs, rhs)
    return quaternion.dot(lhs, rhs) > 0.999999
end

quaternion.__tostring = function(t)
    return string.format("[%f, %f, %f, %f]", t.x, t.y, t.z, t.w)
end
--endregion

return quaternion