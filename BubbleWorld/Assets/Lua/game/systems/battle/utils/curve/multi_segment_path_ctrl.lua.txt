---
--- Generated by wuhaijun
--- File name : multi_segment_path_ctrl.lua.txt
--- DateTime : 2022/08/29
--- Description : 多段路径
---

local log = log
local math_sqrt = math.sqrt
local table_deep_copy = table.deep_copy
local data_mgr = data
local is_nil_or_empty = string.is_nil_or_empty
local LuaUtil = cs.LuaUtil
local GameObject = cs.GameObject

---@type curve_utility
local curve_utility = require 'game/systems/battle/utils/curve_utility'

---@class multi_segment_path_ctrl
local multi_segment_path_ctrl = 
{
    cname = 'multi_segment_path_ctrl',
    ---@type table<number, multi_segment_path_ctrl>
    path_script_dict = {},
}

---路径点位类型
local path_point_type =
{
    NONE = 1 << 0,  -- 1
    START = 1 << 1, -- 2
    TARGET = 1 << 2,-- 4
    END = 1 << 3,   -- 8
}

---@public
---@return multi_segment_path_ctrl
function multi_segment_path_ctrl.new(...)
    ---@type multi_segment_path_ctrl
    local instance = setmetatable({}, { __index = multi_segment_path_ctrl })
    instance:ctor(...)
    return instance
end

---构造函数
---@protected
---@param path_data skill_path_data
function multi_segment_path_ctrl:ctor(path_data)
    if #path_data.PointDataList < 2 then
        log.error("segment_path length cannot be less than 2")
    end

    ---路径配置数据
    ---@private
    ---@type skill_path_data
    self.path_data = path_data
    
    ---路径控制点列表
    ---@private
    ---@type skill_path_point_data[]
    self.point_list = nil
    ---持续时间(毫秒)
    ---@private
    ---@type number
    self.duration_time = nil
    ---已运行时间(毫秒)
    ---@private
    ---@type number
    self.elapsed_time = nil
end

---获取多段路径控制器
---@public
---@param path_mid string 路径id
---@param duration_time number 持续时间(秒)
---@return multi_segment_path_ctrl
function multi_segment_path_ctrl.get_segment_path(path_mid, duration_time)
    if is_nil_or_empty(path_mid) then
        log.error("Invalid bullet path config ID")
        return
    end

    ---@type skill_path_data
    local path_data = data_mgr.get('SkillPathData', path_mid)
    if path_data == nil then
        return
    end

    local path_script = multi_segment_path_ctrl.path_script_dict[path_data.PathType]
    if path_script == nil then
        if path_data.PathType == 0 then
            path_script = require 'game/systems/battle/utils/curve/straight_line_path'
        else
            path_script = require 'game/systems/battle/utils/curve/cubic_bezier_curve'
        end 
        multi_segment_path_ctrl.path_script_dict[path_data.PathType] = path_script
    end

    ---@type multi_segment_path_ctrl
    local segment_path = path_script.new(path_data)
    segment_path:init(duration_time)

    return segment_path
end

---初始化
---@public
---@param duration_time number 持续时间
function multi_segment_path_ctrl:init(duration_time)
    self.duration_time = duration_time
    self.elapsed_time = 0
    
    self.point_list = table_deep_copy(self.path_data.PointDataList)
end

---设置路径位置变换信息
---@private
---@param scale_value number 缩放值
---@param rot_x number 旋转x
---@param rot_y number 旋转y
---@param rot_z number 旋转z
---@param offset_x number 偏移x
---@param offset_y number 偏移y
---@param offset_z number 偏移z
function multi_segment_path_ctrl:set_path_transform_info(scale_value, rot_x, rot_y, rot_z, offset_x, offset_y, offset_z)
    if scale_value == nil or scale_value <= 0 then
        scale_value = 1
    end
    
    local list = self.point_list
    for i = 1, #list do
        local point = list[i]
        
        -- 设置旋转
        if rot_x ~= nil and rot_y ~= nil and rot_z ~= nil then
            point.Position.X, point.Position.Y, point.Position.Z = LuaUtil.RotationVector(
                    rot_x, rot_y, rot_z, 
                    point.Position.X, point.Position.Y, point.Position.Z)
            point.LeftHandlePosition.X, point.LeftHandlePosition.Y, point.LeftHandlePosition.Z = LuaUtil.RotationVector(
                    rot_x, rot_y, rot_z,
                    point.LeftHandlePosition.X, point.LeftHandlePosition.Y, point.LeftHandlePosition.Z)
            point.RightHandlePosition.X, point.RightHandlePosition.Y, point.RightHandlePosition.Z = LuaUtil.RotationVector(
                    rot_x, rot_y, rot_z,
                    point.RightHandlePosition.X, point.RightHandlePosition.Y, point.RightHandlePosition.Z)
        end
       
        -- 设置缩放
        if scale_value ~= nil then
            point.Position.X = point.Position.X * scale_value
            point.Position.Y = point.Position.Y * scale_value
            point.Position.Z = point.Position.Z * scale_value
            point.LeftHandlePosition.X = point.LeftHandlePosition.X * scale_value
            point.LeftHandlePosition.Y = point.LeftHandlePosition.Y * scale_value
            point.LeftHandlePosition.Z = point.LeftHandlePosition.Z * scale_value
            point.RightHandlePosition.X = point.RightHandlePosition.X * scale_value
            point.RightHandlePosition.Y = point.RightHandlePosition.Y * scale_value
            point.RightHandlePosition.Z = point.RightHandlePosition.Z * scale_value
        end

        -- 设置位置
        if offset_x ~= nil and offset_y ~= nil and offset_z ~= nil then
            point.Position.X = point.Position.X + offset_x
            point.Position.Y = point.Position.Y + offset_y
            point.Position.Z = point.Position.Z + offset_z
            point.LeftHandlePosition.X = point.LeftHandlePosition.X + offset_x
            point.LeftHandlePosition.Y = point.LeftHandlePosition.Y + offset_y
            point.LeftHandlePosition.Z = point.LeftHandlePosition.Z + offset_z
            point.RightHandlePosition.X = point.RightHandlePosition.X + offset_x
            point.RightHandlePosition.Y = point.RightHandlePosition.Y + offset_y
            point.RightHandlePosition.Z = point.RightHandlePosition.Z + offset_z
        end
    end
end

---设置目标点位位置
---@public
---@param xx number x坐标
---@param yy number y坐标
---@param zz number z坐标
function multi_segment_path_ctrl:set_target_point_position(xx, yy, zz)
    local point_list = self.point_list
    for i = 1, #point_list do
        local point = point_list[i]
        if (point.PointType & path_point_type.TARGET) ~= 0 then
            local offset_x = xx - point.Position.X
            local offset_y = yy - point.Position.Y
            local offset_z = zz - point.Position.Z

            point.Position.X = point.Position.X + offset_x
            point.Position.Y = point.Position.Y + offset_y
            point.Position.Z = point.Position.Z + offset_z
            point.LeftHandlePosition.X = point.LeftHandlePosition.X + offset_x
            point.LeftHandlePosition.Y = point.LeftHandlePosition.Y + offset_y
            point.LeftHandlePosition.Z = point.LeftHandlePosition.Z + offset_z
            point.RightHandlePosition.X = point.RightHandlePosition.X + offset_x
            point.RightHandlePosition.Y = point.RightHandlePosition.Y + offset_y
            point.RightHandlePosition.Z = point.RightHandlePosition.Z + offset_z
            
            break
        end
    end
end

---获取方向类型
---@public
---@return number 方向类型：0=自动转向，1=保持方向
function multi_segment_path_ctrl:get_direction_type()
    return self.path_data.DirectionType
end

---获取点位总数量
---@public
---@return number 点位总数量
function multi_segment_path_ctrl:get_point_count()
    return #self.point_list
end

---获取点位置
---@public
---@param delta_time number 帧间隔时间（毫秒）
---@return number, number, number
function multi_segment_path_ctrl:get_point_position(delta_time)
    self.elapsed_time = self.elapsed_time + delta_time
    local t = self.elapsed_time / self.duration_time
    return self:evaluate(t)
end

---根据时间t计算在曲线上的点
---@public
---@param t number 时间值[0 ~ 1]
---@return number, number, number
function multi_segment_path_ctrl:evaluate(t)
    t = curve_utility.animation_curve_evaluate(self.path_data.SpeedKeyframes, self:clamp_value(t))
    local tt, start_point, end_point = self:get_target_segment_data(self:clamp_value(t))
    return self:calculate_path_point_by_data(tt, start_point, end_point)
end

---获取目标线段上的数据
---@private
---@param t number 时间值[0 ~ 1]
---@return number, skill_path_point_data, skill_path_point_data
function multi_segment_path_ctrl:get_target_segment_data(t)
    local segment_time = 0
    local segment_start_point
    local segment_end_point

    local point_list = self.point_list
    local point_count = #point_list
    local sub_percent = 0
    local total_percent = 0
    local approximate_length = self:get_approximate_length()
    local sub_sampling = self.path_data.Sampling / (point_count - 1) + 1

    for i = 1, point_count - 1 do
        local start_point = point_list[i]
        local end_point = point_list[i + 1]
        sub_percent = self:get_approximate_length_of_path(start_point, end_point, sub_sampling) / approximate_length
        if sub_percent + total_percent > t then
            segment_start_point = start_point
            segment_end_point = end_point
            break
        end
        total_percent = total_percent + sub_percent
    end
    
    if segment_end_point == nil then
        -- 如果评估点非常接近曲线的末端，则当前处于最后一段
        segment_start_point = point_list[point_count - 1]
        segment_end_point = point_list[point_count]
        -- 删除最后一个子路径的百分比
        total_percent = total_percent - sub_percent
    end
    
    segment_time = (t - total_percent) / sub_percent
    
    return segment_time, segment_start_point, segment_end_point
end

---获取路径总长度的近似值
---@private
---@return number
function multi_segment_path_ctrl:get_approximate_length()
    local length = 0.001
    local point_list = self.point_list
    local point_count = #point_list
    local sub_sampling = self.path_data.Sampling / (point_count - 1) + 1

    for i = 1, point_count - 1 do
        length = length + self:get_approximate_length_of_path(point_list[i], point_list[i + 1], sub_sampling)
    end
    
    return length
end

---获取路径长度近似值
---@private
---@param start_point skill_path_point_data
---@param end_point skill_path_point_data
---@param sample number
---@return number
function multi_segment_path_ctrl:get_approximate_length_of_path(start_point, end_point, sample)
    local length = 0
    local from_x, from_y, from_z = self:calculate_path_point_by_data(0, start_point, end_point)

    for i = 1, sample do
        local time = i / sample
        local to_x, to_y, to_z = self:calculate_path_point_by_data(time, start_point, end_point)
        length = length + math_sqrt((from_x - to_x) ^ 2 + (from_y - to_y) ^ 2 + (from_z - to_z) ^ 2)
        -- length = length + (from_x - to_x) ^ 2 + (from_y - to_y) ^ 2 + (from_z - to_z) ^ 2
        from_x, from_y, from_z = to_x, to_y, to_z
    end

    return length
end

---计算路径点根据数据
---@private
---@param t number 时间值[0 ~ 1]
---@param start_point skill_path_point_data 开始位置
---@param end_point skill_path_point_data 结束位置
---@return number, number, number
function multi_segment_path_ctrl:calculate_path_point_by_data(t, start_point, end_point)
    t = self:clamp_value(t)
    return self:calculate_path_point(t, start_point.Position, end_point.Position, 
            start_point.RightHandlePosition, end_point.LeftHandlePosition)
end

---计算路径点
---@protected
---@param t number 时间值[0 ~ 1]
---@param start_position skill_pos_info 开始位置
---@param end_position skill_pos_info 结束位置
---@param start_tangent skill_pos_info 开始切线位置
---@param end_tangent skill_pos_info 结束切线位置
---@return number, number, number
function multi_segment_path_ctrl:calculate_path_point(t, start_position, end_position, start_tangent, end_tangent)
    log.error('Subclass implementation interface, CalculatePathPoint, t = ', t, start_position, end_position, 
            start_tangent, end_tangent)
end

---归一化
---@protected
---@return number
function multi_segment_path_ctrl:clamp_value(time)
    if time < 0 then
        time = 0
    elseif time > 1 then
        time = 1
    end
    
    return time
end

---[DEBUG]用于画路径点位物体，方便可视化
---@public
---@param parent UnityEngine.Transform
function multi_segment_path_ctrl:draw_path_point(parent)
    local tmp_scale_value = 0.2
    
    local point_object_list = {}
    local list = self.point_list
    
    -- 0=直线，1=贝塞尔
    if self.path_data.PathType == 0 then
        for i = 1, #list do
            local point = list[i]

            local obj1 = GameObject.CreatePrimitive(cs.PrimitiveType.Sphere)
            obj1.name = "PathPosition" .. i
            obj1:SetParent(parent)
            obj1:SetLocalScale(tmp_scale_value, tmp_scale_value, tmp_scale_value)
            obj1:SetPosition(point.Position.X, point.Position.Y, point.Position.Z)
            point_object_list[#point_object_list +1] = obj1
        end
    else
        for i = 1, #list do
            local point = list[i]

            local obj1 = GameObject.CreatePrimitive(cs.PrimitiveType.Sphere)
            obj1.name = "PathPosition" .. i
            obj1:SetLocalScale(tmp_scale_value, tmp_scale_value, tmp_scale_value)
            obj1:SetPosition(point.Position.X, point.Position.Y, point.Position.Z)
            point_object_list[#point_object_list +1] = obj1

            local obj2 = GameObject.CreatePrimitive(cs.PrimitiveType.Sphere)
            obj2.name = "PathLeftHandle" .. i
            obj2:SetLocalScale(tmp_scale_value, tmp_scale_value, tmp_scale_value)
            obj2:SetPosition(point.LeftHandlePosition.X, point.LeftHandlePosition.Y, point.LeftHandlePosition.Z)
            point_object_list[#point_object_list +1] = obj2
            
            local obj3 = GameObject.CreatePrimitive(cs.PrimitiveType.Sphere)
            obj3.name = "PathRightHandle" .. i
            obj3:SetLocalScale(tmp_scale_value, tmp_scale_value, tmp_scale_value)
            obj3:SetPosition(point.RightHandlePosition.X, point.RightHandlePosition.Y, point.RightHandlePosition.Z)
            point_object_list[#point_object_list +1] = obj3
        end
    end
    
    self._point_object_list = point_object_list
end

---销毁
---@public
function multi_segment_path_ctrl:dispose()
    if self._point_object_list ~= nil then
        for i = 1, #self._point_object_list do
            GameObject.Destroy(self._point_object_list[i])
        end
        self._point_object_list = nil
    end

    self.duration_time = nil
    self.elapsed_time = nil
    self.point_list = nil
end

return multi_segment_path_ctrl