---
--- Generated by libin
--- File name : explore_system.lua.txt
--- DataTime : 2022/07/05
--- Description : 探索系统
---

local enum = enum
local data = data
local tables = tables
local game_scene_mgr = game_scene_manager
local res = res
local string = string
local explore_data = game_data_manager.explore
local explore_scene_render = require "game/systems/explore/scene/explore_scene_render"
local explore_dungeon_scene_render = require "game/systems/explore/scene/explore_dungeon_scene_render"
local window = window
local timer_mgr = timer_manager
local explore_player = require "game/systems/explore/player/explore_player"
local explore_net = require "game/systems/explore/network/explore_network"
local explore_guide_net = require "game/systems/explore/network/explore_guide_network"
local explore_anim_type = enum.experience.explore_anim_type
local explore_prepare_play_anima = require "game/game_data/explore/explore_prepare_play_anima"
local explore_camera_state_type = enum.experience.explore_camera_state_type
local message = message
---@type message_type
local message_type = enum.message_type
local experience_sys = system_manager.experience
local experience_play_type = enum.experience.experience_play_type
local game_data_manager = game_data_manager
local effect = effect
local setting = setting
local game_network = game_network
local message_box = message_box
local map_anim_ctrl = require "game/systems/explore/scene/explore_map_anim_controller"
local change_ctrl = require "game/systems/explore/change/explore_change_controller"
local explore_story_controller = require "game/systems/explore/story/explore_story_controller"
local rare_cool_down_logic = require "game/systems/explore/rare/explore_rare_cool_down_logic"
local explore_node_extend_type = enum.experience.explore_node_extend_type
local explore_node_event_type = enum.experience.explore_node_event_type
local EBattleType = enum.proto.EBattleType
local guide_trigger_type = enum.guide.guide_trigger_type
local explore_util = require "game/windows/explore/explore_util"
local ui_cache_data = game_data_manager.cache
local cache_keys = enum.cache_keys

---@class explore_system
local explore_system = class("explore_system")

--region base api

---构造函数
---@protected
function explore_system:ctor()

    self:add_event()
    
    --explore
    ---@type string
    self.cur_chapter_id = nil
    ---@type string
    self.last_chapter_id = nil

    ---@type string
    self.cur_area_id = nil

    ---@type explore_map_anim_controller
    self.map_anim_ctrl = map_anim_ctrl.new()

    ---@type explore_scene_render
    self.scene_render = explore_scene_render.new()

    ---@type explore_dungeon_scene_render
    self.dungeon_scene_render = explore_dungeon_scene_render.new()

    ---@public
    ---@type DeusFramework.Res.DfResLoader
    self.res_loader = res.create_res_loader()
    ---@type UnityEngine.GameObject
    self.player_obj = nil
    ---@type explore_player
    self.player = nil
    --玩家移动回调
    ---@type function
    self.move_finished = nil

    ---@type explore_network
    self.network = explore_net.new()

    ---@type explore_camera_state_type
    self.cur_camera_state = explore_camera_state_type.NORMAL

    --change layer
    ---@type number
    self.cache_timer_id = nil

    ---@type number
    self.cur_layer_index = nil

    ---@type number
    self.jump_enable_false_timer_id = nil

    ---@type number
    self.jump_enable_true_timer_id = nil

    ---@type number
    self.jump_enable_false_effect_uid = nil

    ---@type number
    self.jump_enable_true_effect_uid = nil

    --guide
    ---@type explore_guide_network
    self.guide_network = explore_guide_net.new()

    --dungeon
    ---@type UnityEngine.GameObject
    self.hero_obj = nil
    ---@type number
    self.hero_camera_id = nil

    --story
    ---@type explore_story_controller
    self.story_ctrl = explore_story_controller.new()
    
    --rare monster
    ---@type table<string, explore_rare_cool_down_logic>  key: node_id
    self.rare_cool_down_dict = {}

    --dynamic change
    self.dynamic_change_ctrl = change_ctrl.new()
    
    -- 添加退出战斗消息监听
    
    ---@type boolean
    self.is_can_select_area = true
    
    ---@type boolean
    self.is_can_btn = true
    
    ---@type boolean
    self.is_jump = false
end

---销毁
---@public
function explore_system:dispose()
    self:del_event()
    self.player_obj = nil
    if self.player ~= nil then
        self.player:dispose()
        self.player = nil
    end
    self.res_loader:Dispose()
    self.res_loader = nil
    self.cur_chapter_id = nil;
    self.last_chapter_id = nil

    self.scene_render:dispose()
    self.scene_render = nil
    self.dungeon_scene_render:dispose()
    self.dungeon_scene_render = nil
    self:clear_prepare_play_anim()
    self.move_finished = nil
    self.network:dispose()
    self.network = nil
    self.guide_network:dispose()
    self.guide_network = nil
    self.cur_camera_state = nil
    self.cur_layer_index = nil
    if nil ~= self.cache_timer_id then
        timer_mgr.remove_timer(self.cache_timer_id)
    end
    self.cache_timer_id = nil
    self.cur_area_id = nil

    if nil ~= self.jump_enable_false_timer_id then
        timer_mgr.remove_timer(self.jump_enable_false_timer_id)
    end
    self.jump_enable_false_timer_id = nil
    if nil ~= self.jump_enable_true_timer_id then
        timer_mgr.remove_timer(self.jump_enable_true_timer_id)
    end
    self.jump_enable_true_timer_id = nil

    if nil ~= self.jump_enable_false_effect_uid then
        effect.manual_unload_effect(self.jump_enable_false_effect_uid)
    end
    self.jump_enable_false_effect_uid = nil
    if nil ~= self.jump_enable_true_effect_uid then
        effect.manual_unload_effect(self.jump_enable_true_effect_uid)
    end
    self.jump_enable_true_effect_uid = nil

    self.hero_obj = nil
    self.hero_camera_id = nil
    self.story_ctrl:dispose()
    self.story_ctrl = nil

    for i, v in pairs(self.rare_cool_down_dict) do
        v:dispose()
    end
    self.rare_cool_down_dict = nil

    self.dynamic_change_ctrl:dispose()
    self.dynamic_change_ctrl = nil

    self.is_can_select_area = nil
    self.is_can_btn = nil
    self.is_jump = nil
end

---退出
---@public
function explore_system:on_application_quit()
    --动画保存
    explore_data:save_explore_chapter_ue()
    explore_data:save_explore_scene_anim()
    explore_data:save_explore_node_anim()
    explore_data:save_explore_area_ue()
    explore_data:save_sort_mission()
end


--endregion

--region event

---添加事件
---@private
function explore_system:add_event()
    message.add_listener(message_type.BATTLE_CUSTOM_EXIT_BATTLE_FLOW, self.on_exit_battle, self)
    message.add_listener(message_type.STORY_AVG_CLIP_PAUSE_OR_SKIP_FOR_EXPLORE, self.on_story_avg_clip_pause_or_skip_for_explore, self)
    message.add_listener(message_type.ITEM_ACCESS_CLOSE_PANEL, self.after_item_access, self)
    message.add_listener(message_type.AFTER_CHECK_CONDITION, self.on_after_check_condition, self)
end

---删除事件
---@private
function explore_system:del_event()
    message.remove_listener(message_type.BATTLE_CUSTOM_EXIT_BATTLE_FLOW, self.on_exit_battle, self)
    message.remove_listener(message_type.STORY_AVG_CLIP_PAUSE_OR_SKIP_FOR_EXPLORE, self.on_story_avg_clip_pause_or_skip_for_explore, self)
    message.remove_listener(message_type.ITEM_ACCESS_CLOSE_PANEL, self.after_item_access, self)
    message.remove_listener(message_type.AFTER_CHECK_CONDITION, self.on_after_check_condition, self)
end

---当条件检查之后
---@private
---@param ack_info AckCheckCondition
function explore_system:on_after_check_condition(ack_info)
    local node_id = ack_info.custom_value
    if data.is_name(node_id, tables.ExploreNode.name) then
        ---@type explore_node_data
        local node_data = explore_data:get_explore_node_data_by_id(node_id)
        window.open(tables.Window.ids.ExploreNodeLock, node_data)
    end
end

---当领取奖励后
---@private
function explore_system:after_item_access()
    local flag = self:is_in_explore_sys()
    if flag then
        --宝箱路点生成后端剧情
        local node_id = game_data_manager.explore:get_cur_map_pos(self.cur_chapter_id)
        ---@type explore_node_data
        local node_data = game_data_manager.explore:get_explore_node_data_by_id(node_id)
        if node_data.node.EventType == explore_node_event_type.BOX then
            self.story_ctrl:try_generate_end_story_data(self.cur_chapter_id)
            self:check_node_end_story(nil)
        end
    end
end

---通知探索功能暂停或跳过AVG幕
---@private
function explore_system:on_story_avg_clip_pause_or_skip_for_explore(param)
    if param.is_skip then
        --动态变换执行跳过处理
        self:do_dynamic_change_immediately()
    else
        --正常执行动态变换
        self:do_dynamic_change(param.data[1], param.data[2])
    end
end

--endregion

--region logic

---@public
function explore_system:start()
end

---设置探索相机状态
---@public
---@param type explore_camera_state_type
function explore_system:set_cur_camera_state(type)
    self.cur_camera_state = type
    if type == explore_camera_state_type.NORMAL then
        self.is_can_btn = true        
    else
        self.is_can_btn = false
    end
end

---退出系统
---@public
function explore_system:exit_explore()
    self.last_chapter_id = self.cur_chapter_id
    self.cur_chapter_id = nil
    --self.cur_area_id = nil
    self.scene_render:clear()
    self.player:dispose()
    self:set_cur_camera_state(explore_camera_state_type.NORMAL)
    experience_sys:set_cur_play_type(experience_play_type.NONE)
    experience_sys:clear_close_type()

    --指引者
    window.close_by_id(tables.Window.ids.ExploreGuide, true)
    window.close_by_id(tables.Window.ids.ExploreGuideBack, true)
    window.close_by_id(tables.Window.ids.ExploreGuideCommit, true)
    
    --清理稀有怪倒计时
    self:clear_rare_cool_down_logic()

    --动画保存
    explore_data:save_explore_chapter_ue()
    explore_data:save_explore_scene_anim()
    explore_data:save_explore_node_anim()
    explore_data:save_explore_area_ue()
    explore_data:save_sort_mission()
    
    self.res_loader:Dispose()
    self.res_loader = res.create_res_loader()
end

---是否开启探索系统
---@public
---@return boolean
function explore_system:is_open_system()
    return game_data_manager.player:check_system_function_open(tables.SystemFunction.ids.SystemFunction_Explorer)
end

---是否开启魔灵岛系统
---@public
---@return boolean
function explore_system:is_pneuma_island_system_open()
    return game_data_manager.player:check_system_function_open(tables.SystemFunction.ids.SystemFunction_Pneumaland)
end

---是否开启爬塔系统
---@public
---@return boolean
function explore_system:is_climb_tower_system_open()
    return game_data_manager.player:check_system_function_open(tables.SystemFunction.ids.SystemFunction_Tower)
end

function explore_system:is_climb_tower_system_swept_open()
    return game_data_manager.player:check_system_function_open(tables.SystemFunction.ids.SystemFunction_Tower_Sweep)
end

---退出战斗时
---@private
---@param exit_type battle_exit_type 退出战斗类型（0-普通退出；1-特殊退出流程；2-重新挑战；3-跳转（指定场景退出））
---@param battle_type table
---@param is_victory boolean
---@param game_id string
function explore_system:on_exit_battle(exit_type, battle_type, is_victory, game_id)
    if exit_type ~= 1 then return end

    -- 探索战斗
    if battle_type == EBattleType.BATTLE_TYPE_EXPLORE or battle_type == EBattleType.BATTLE_TYPE_EXPLORE_RAID then
        self:try_generate_end_story_data()
        game_scene_manager.go_back()
    elseif battle_type == EBattleType.BATTLE_TYPE_EXPLORE_TASK then
        --任务路点战斗
        if data.is_name(game_id, tables.ExploreTask.name) then
            self.is_jump = true
        end
        game_scene_manager.go_back()
    elseif battle_type == EBattleType.BATTLE_TYPE_EXPLORE_DUNGEON then  -- 探索副本战斗
        --探索材料副本退出
        local dungeon_id =  game_data_manager.explore_dungeon.dungeon_data.Id
        local last_index = game_data_manager.explore_dungeon.last_battle_index
        if last_index == 10 then
            local chapter_id = self.last_chapter_id
            --材料副本后段剧情
            self:try_generate_end_story_data()
            self:switch_scene(chapter_id)
            --删除主角位置
            game_data_manager.explore_dungeon:del_born_point_info(dungeon_id)
        else
            game_scene_manager.go_back()
        end
        
        --检测怪物表现流程死亡
        game_data_manager.explore_dungeon:check_monster_real_dead(dungeon_id)
    end
end

---是否在探索系统
---@public
---@return boolean
function explore_system:is_in_explore_sys()
    ---@type experience_play_type
    local type = system_manager.experience:get_cur_play_type()
    if type == experience_play_type.EXPLORE then
        return true
    end
    return false
end

---探索点击屏蔽
---@public
function explore_system:explore_is_can_btn()
    local flag = self:is_in_explore_sys()
    if flag then
        if not self.is_can_btn then
            message_box.show_tip_by_id(tables.Prompt.ids.Prompt_Explore_Move)
            return false
        end        
    end
    
    return true
end


--endregion

--region scene

---@public
function explore_system:init_scene_render()
    if nil == self.cur_chapter_id then
        self.cur_chapter_id = self.last_chapter_id
    end
    local node_id = explore_data:get_cur_map_pos(self.cur_chapter_id)
    local layer_index = explore_data:get_explore_layer_by_node_id(node_id)
    self.cur_layer_index = layer_index
    self.scene_render:init(layer_index)
end

---加载探索场景
---@public
---@param chapter_id string
function explore_system:switch_scene(chapter_id)
    ---@type explore_chapter_data
    local chapter_data = game_data_manager.explore:get_explore_chapter_data_by_id(chapter_id)
    self.cur_area_id = chapter_data.area.Id
    if self.cur_chapter_id ~= chapter_id then
        self.cur_chapter_id = chapter_id
        self.scene_render:clear()
        local scene_id = data.get(tables.ExploreMap.name, chapter_id, tables.ExploreMap.properties.ExploreSceneID)
        if not string.is_nil_or_empty(scene_id) then
            game_scene_mgr.switch_scene(scene_id)
        end
    else
        local win1 = window.get_window(tables.Window.ids.Adventure)
        local win2 = window.get_window(tables.Window.ids.ExploreMap)
        if win1 ~= nil and nil == win2 then
            timer_manager.add_timer(0.1, function()
                message.broadcast(message_type.UI_BOTTOM_BAR_SHOW_WINDOW)
            end)
        end
       
        if nil == win1 and win2 ~= nil then
            timer_manager.add_timer(0.1, function()
                win2.view_model:btn_return()
            end)
        end

        if nil ~= win1 and nil ~= win2 then
            timer_manager.add_timer(0.1, function()
                win2.view_model:btn_return()
                message.broadcast(message_type.UI_BOTTOM_BAR_SHOW_WINDOW)
            end)
        end
    end
end

---默认场景位置
---@public
---@param immediately boolean
function explore_system:do_default_location(immediately)
    self.scene_render:do_default_location(self.cur_chapter_id, immediately)
end

---返回探索场景
---@public
function explore_system:go_back_to_explore_scene()
    --TODO 正常这里需要和战斗通关数据配合实现， 但是目前没有逻辑
    local scene_id = data.get(tables.ExploreMap.name, self.last_chapter_id, tables.ExploreMap.properties.ExploreSceneID)
    if not string.is_nil_or_empty(scene_id) then
        game_scene_mgr.switch_scene(scene_id)
    end
end

--endregion

--region camera

---查看目标
---@public
---@param node_name string
---@param immediately boolean
---@param callback function
function explore_system:look_at_target(node_name, immediately, callback)
    message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.explore_camera_move_start)
    self.scene_render:look_at_target(node_name, immediately, function()
        message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.explore_camera_move_end)
        callback()
    end)
end

---查看目标
---@public
---@param x number
---@param z number
---@param callback function
function explore_system:look_at_pos(x, z, callback)
    self.scene_render:look_at_pos(x, z, callback)
end

---是否能拖拽相机
---@public
---@param is_can boolean
function explore_system:set_can_drag_camera(is_can)
    self.scene_render:set_can_drag_camera(is_can)
end


--endregion

--region chapter

---获得当前章节数据
---@public
---@return explore_chapter_data
function explore_system:get_cur_chapter()
    return explore_data:get_explore_chapter_data_by_id(self.cur_chapter_id)
end

--endregion

--region node

---设置指定路点显/隐藏
---@public
---@param name string
---@param is_active boolean
function explore_system:set_node_active(name, is_active)
    self.scene_render:set_node_active(name, is_active)
end

---获得指定节点渲染器
---@public
---@param node_name string
---@return explore_node_render_unit
function explore_system:get_node_render_unit(node_name)
    return self.scene_render:get_node_render_unit(node_name)
end

---播放新路点激活动画
---@public
---@param node_id string
function explore_system:play_node_active_effect(node_id)
    local node_name = explore_data:get_explore_node_name_by_id(node_id)
    self.scene_render:play_node_active_effect(node_name)
end

---检查到达状态
---@public
---@param node_data explore_node_data
function explore_system:check_node_arrived_state(node_data)
    local node_name = node_data:get_node_name()
    ---@type explore_node_render_unit
    local render = self:get_node_render_unit(node_name)
    if nil ~= render then
        render:update_arrived_stata()
    end
end

---路点到达后处理
---@public
---@param node_id
function explore_system:on_ack_update_node(node_id)
    --章内传送路点在这里做刷新，并检测路点动画
    ---@type explore_node_data
    local node_data = explore_data:get_explore_node_data_by_id(node_id)
    if nil ~= node_data and node_data.node.EventType == explore_node_event_type.TRANSMIT_SELF then
        local node_name = node_data:get_node_name()
        ---@type explore_node_render_unit
        local render = self:get_node_render_unit(node_name)
        render:update_item()
        
        --检测新动画
        self:check_node_and_mask_render_unit()
        self:check_new_node_anim()
        
        --触发器更换数据
        message.broadcast(message_type.UI_EXPLORE_UPDATE_NODE_BUBBLE)
    end
end

---当路点状态改变
---@public
---@param node_data explore_node_data
function explore_system:on_node_state_change(node_data)
    local node_name = node_data:get_node_name()
    ---@type explore_node_render_unit
    local render = self:get_node_render_unit(node_name)
    if nil ~= render then
        render:update_item()
    end
end

---准备前往下一路点
---@public
function explore_system:try_go_next_node()
    ---@type battle_result_data
    local result_data = ui_cache_data:get_cache_data(cache_keys.battle_result)
    if nil ~= result_data then
        ui_cache_data:del_cache_data(cache_keys.battle_result)
        ---@type explore_node_data
        local node_data = explore_data:get_explore_node_data_by_id(result_data.param)
        if nil ~= node_data then
            ---@type explore_node_data
            local next_data = node_data.next_node
            if nil ~= next_data then
                local next_id = next_data.node.Id
                self:player_move(next_id, function()
                    message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.explore_player_move_end, next_id)
                    self.is_can_btn = true
                    self:prepare_battle(next_id)
                end)
            end
        end
    end
end

--endregion

--region line

---获得连线渲染器
---@public
---@param line_name string
---@return explore_line_render_unit
function explore_system:get_line_render_unit(line_name)
    return self.scene_render:get_line_render_unit(line_name)
end

---刷新所以连线进度
---@public
function explore_system:update_all_line_progress()
    self.scene_render:update_all_line_progress()
end

---获得默认跟随组件
---@public
---@return Dreamteck.Splines.SplineComputer
function explore_system:get_default_follow()
    if nil == self.cur_chapter_id then
        self.cur_chapter_id = self.last_chapter_id
    end

    local cur_pos = explore_data:get_cur_map_pos(self.cur_chapter_id)
    ---@type explore_node_data
    local node_data = explore_data:get_explore_node_data_by_id(cur_pos)
    if nil == node_data then
        return nil
    end

    local layer_index = node_data.node.LayerIndex
    ---@type explore_line_data[]
    local lst = explore_data:get_explore_line_data_by_node_id(cur_pos)
    for i = 1, #lst do
        ---@type explore_line_data
        local line_data = lst[i]
        if line_data.layer_index == layer_index then
            local line_name = line_data:get_line_name()
            local render = self.scene_render:get_line_render_unit(line_name)
            if nil ~= render then
                return render:get_spline_computer()
            end
        end
    end

    return nil
end

--endregion

--region explore anima

---添加准备播放的动画
---@public
---@param type explore_anim_type
---@param anim explore_prepare_play_anima
function explore_system:add_prepare_play_anim(type, anim)
    self.map_anim_ctrl:add_prepare_play_anim(type, anim)
end

--删除准备播放的动画（完成后调用）
---@public
---@param type explore_anim_type
---@param id string
---@param anim explore_prepare_play_anima
function explore_system:del_prepare_play_anim(type, id, anim)
    self.map_anim_ctrl:del_prepare_play_anim(type, id, anim)
end

---清理
---@public
function explore_system:clear_prepare_play_anim()
    self.map_anim_ctrl:dispose()
    self.map_anim_ctrl = nil
end

---获得准备播放动画
---@public
---@param type explore_anim_type
---@param id
---@return explore_prepare_play_anima
function explore_system:get_prepare_play_anim(type, id)
    return self.map_anim_ctrl:get_prepare_play_anim(type, id)
end

---是否包含准备播放动画
---@public
---@param type explore_anim_type
---@param id string
---@return boolean
function explore_system:is_has_prepare_play_anim(type, id)
    return self.map_anim_ctrl:is_has_prepare_play_anim(type, id)
end

---检测准备动画
---@public
---@param node_data explore_node_data
function explore_system:check_prepare_anim(node_data)
    --新章节解锁动画
    self:add_play_anim_new_chapter(node_data)
    --新节点更新动画
    self:add_play_anim_new_node(node_data)
end

---播放新节点动画
---@public
function explore_system:play_new_node_anim()
    local is_has_main = self.map_anim_ctrl:is_has_main_node_anim(self.cur_chapter_id)
    local is_has_branch = self.map_anim_ctrl:is_has_branch_node_anim(self.cur_chapter_id)
    if is_has_main or is_has_branch then
        self:set_cur_camera_state(explore_camera_state_type.FOLLOW)
        self.map_anim_ctrl:play_node_anim(self.cur_chapter_id, function()
            self:set_cur_camera_state(explore_camera_state_type.NORMAL)
            message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.explore_chapter_node_show_over)
            --TODO:自动前往下一关
            self:try_go_next_node()
        end)
    else
        message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.explore_chapter_node_show_over)
    end
end

--endregion

--region new node anim

---添加新节点更动画
---@private
---@param node_data explore_node_data
function explore_system:add_play_anim_new_node(node_data)
    if node_data.state ~= 1 or node_data.node.Type == 3 or node_data.node.EventType == explore_node_event_type.TRANSMIT_SELF then
        return
    end
    --判断节点是否解锁过
    local node_id = node_data.node.Id
    local node_flag = explore_data:get_explore_node_anim_flag_by_id(node_id)
    if node_flag == 0 then
        if node_data:is_main_node() then
            if not self:is_has_prepare_play_anim(explore_anim_type.NEW_MAIN_NODE, node_id) then
                local play_anim = explore_prepare_play_anima.new()
                play_anim.anim_type = explore_anim_type.NEW_MAIN_NODE
                play_anim.node_data = node_data
                self:add_prepare_play_anim(explore_anim_type.NEW_MAIN_NODE, play_anim)

                log.info("[Explore] add_main_node_anim Node ID : " .. node_id)
            end
        else
            if not self:is_has_prepare_play_anim(explore_anim_type.NEW_BRANCH_NODE, node_id) then
                local play_anim = explore_prepare_play_anima.new()
                play_anim.anim_type = explore_anim_type.NEW_BRANCH_NODE
                play_anim.node_data = node_data
                self:add_prepare_play_anim(explore_anim_type.NEW_BRANCH_NODE, play_anim)

                log.info("[Explore] add_branch_node_anim Node ID : " .. node_id)
            end
        end
    end
end

---指引者完成检查下一路点和连线
---@public
function explore_system:check_node_and_mask_render_unit()
    local is_has_main = self.map_anim_ctrl:is_has_main_node_anim(self.cur_chapter_id)
    local is_has_branch = self.map_anim_ctrl:is_has_branch_node_anim(self.cur_chapter_id)
    if is_has_main then
        ---@type explore_prepare_play_anima[]
        local prepare_anim_arr = self.map_anim_ctrl:get_main_node_anim(self.cur_chapter_id)
        local count = #prepare_anim_arr
        for i = 1, count do
            ---@type explore_prepare_play_anima
            local prepare_anim = prepare_anim_arr[i]
            ---@type explore_node_data
            local node_data = prepare_anim.node_data
            local node_name = node_data:get_node_name()
            
            ---路点检查
            ---@type explore_node_render_unit
            local node_render_unit = self.scene_render:get_node_render_unit(node_name)
            if nil ~= node_render_unit then
                node_render_unit:set_active(true)
            end
            
            --连线检查
            ---@type explore_fade_mask_render_unit
            local mask_render_unit = self.scene_render:get_mask_render_unit(node_name)
            if nil ~= mask_render_unit then
                mask_render_unit:update_render_unit()
            end
        end
    end

    if is_has_branch then
        ---@type explore_prepare_play_anima[]
        local prepare_anim_arr = self.map_anim_ctrl:get_branch_node_main(self.cur_chapter_id)
        local count = #prepare_anim_arr
        for i = 1, count do
            ---@type explore_prepare_play_anima
            local prepare_anim = prepare_anim_arr[i]
            ---@type explore_node_data
            local node_data = prepare_anim.node_data
            local node_name = node_data:get_node_name()

            ---路点检查
            ---@type explore_node_render_unit
            local node_render_unit = self.scene_render:get_node_render_unit(node_name)
            if nil ~= node_render_unit then
                node_render_unit:set_active(true)
            end

            --连线检查
            ---@type explore_fade_mask_render_unit
            local mask_render_unit = self.scene_render:get_mask_render_unit(node_name)
            if nil ~= mask_render_unit then
                mask_render_unit:update_render_unit()
            end
        end
    end
end

---检测新节点更新动画
---@public
function explore_system:check_new_node_anim()
    self:check_node_end_story(function()
        self:play_new_node_anim()
        self:play_rare_monster_anim()
    end)
end

--endregion

--region new chapter anim

---添加新章节激活动画
---@private
---@param node_data explore_node_data
function explore_system:add_play_anim_new_chapter(node_data)
    --判断章节是否解锁过
    local new_chapter_id = node_data.map.Id
    local chapter_flag = explore_data:get_explore_chapter_ue_flag_by_id(new_chapter_id)
    if chapter_flag <= 0 then
        if not self:is_has_prepare_play_anim(explore_anim_type.NEW_CHAPTER, new_chapter_id) then
            local chapter_play_anim = explore_prepare_play_anima.new()
            chapter_play_anim.anim_type = explore_anim_type.NEW_CHAPTER
            chapter_play_anim.chapter_data = node_data.map
            self:add_prepare_play_anim(explore_anim_type.NEW_CHAPTER, chapter_play_anim)
        end
    end

    --是否解锁下个章节
    if node_data.state == 2 and node_data.node.FogUnlock == 1 then
        local next_chapter_id = node_data.node.FogUnlockChapterID
        local next_chapter_flag = explore_data:get_explore_chapter_ue_flag_by_id(next_chapter_id)
        if next_chapter_flag <= 0 then
            if not self:is_has_prepare_play_anim(explore_anim_type.NEW_CHAPTER, next_chapter_id) then
                ---@type ExploreMap
                local explore_map = data.get(tables.ExploreMap.name, next_chapter_id)
                if nil ~= explore_map then
                    local chapter_play_anim = explore_prepare_play_anima.new()
                    chapter_play_anim.anim_type = explore_anim_type.NEW_CHAPTER
                    chapter_play_anim.chapter_data = explore_map
                    self:add_prepare_play_anim(explore_anim_type.NEW_CHAPTER, chapter_play_anim)
                end
            end
        end
    end
end

--endregion

--region  player

---@public
function explore_system:load_player()
    lua.start_coroutine(function()
        self:load_player_sync()
    end)
end

---@private
function explore_system:load_player_sync()
    local asset_path = data.get(tables.ConstClient.name, tables.ConstClient.ids.KW_EXPLORE_PLAYER, tables.ConstClient.properties.String)
    if not string.is_nil_or_empty(asset_path) then
        --加载角色
        self.player_obj = res.load_instance_sync(asset_path,
                "ExplorePlayer",
                nil,
                nil,
                self.res_loader,
                nil
        )
        local x, y, z = self.scene_render:get_cur_node_position(self.cur_chapter_id)
        self.player_obj:SetPosition(x, y, z)

        self.player = explore_player.new()
        self.player:init(self.player_obj)
    end
end

---玩家移动
---@private
---@param target_id string
---@param finished function
function explore_system:player_move(target_id, finished)
    local start_id = explore_data:get_cur_map_pos(self.cur_chapter_id)
    if nil == start_id then
        start_id = explore_data:get_last_map_pos(self.cur_chapter_id)
        explore_data:set_last_map_pos(self.cur_chapter_id, start_id)
    end

    local end_id = target_id
    self.move_finished = finished

    ---@type explore_move_data[]
    local lst = explore_data:get_prepare_move_line(start_id, end_id)

    --TODO 传送效果追加
    local count = #lst
    ---@type explore_move_data
    local first_data = lst[1]
    if count == 1 and first_data.is_jump then
        --跳转传送
        --step1播放消失特效
        ---@type string
        local start_node_name = explore_data:get_explore_node_name_by_id(start_id)
        ---@type explore_node_render_unit
        local start_node_render_unit = self.scene_render:get_node_render_unit(start_node_name)
        ---@type UnityEngine.GameObject
        local start_obj = start_node_render_unit:get_obj()
        self.jump_enable_false_effect_uid = effect.play_effect_async("Ui_Effect_Scene_Chuansong01", self.scene_render.node_root, 1,
                function()
                    self.jump_enable_false_effect_uid = nil
                    if first_data.direction > 0 then
                        middle_node_name = first_data.start_node_name
                    else
                        middle_node_name = first_data.end_node_name
                    end
                    --step3相机平滑到中间点
                    self:look_at_target(middle_node_name, false,
                            function()
                                ---@type explore_node_render_unit
                                local end_node_render_unit = self.scene_render:get_node_render_unit(middle_node_name)
                                ---@type UnityEngine.GameObject
                                local end_obj = end_node_render_unit:get_obj()
                                --step4播放出现特效
                                self.jump_enable_true_effect_uid = effect.play_effect_async("Ui_Effect_Scene_Chuansong01", self.scene_render.node_root, 1,
                                        function(base_effect)
                                            self.jump_enable_true_effect_uid = nil
                                        end,
                                        function(base_effect)
                                            local x, y, z = end_obj:GetPosition()
                                            base_effect:set_world_position(x, y, z)
                                        end
                                )

                                self.jump_enable_true_timer_id = timer_mgr.add_timer(0.5,
                                        function()
                                            self.jump_enable_true_timer_id = nil

                                            --step5 人物显示
                                            self.player:set_active(true)

                                            --step4正常跟随
                                            self.player:play_hero_follow_anim()
                                            self:do_player_move(lst, 1)
                                        end
                                )
                            end
                    )
                end,
                function(base_effect)
                    local x, y, z = start_obj:GetPosition()
                    base_effect:set_world_position(x, y, z)
                end
        )

        --step2 人物消失
        self.jump_enable_false_timer_id = timer_mgr.add_timer(0.5, function()
            self.jump_enable_false_timer_id = nil
            self.player:set_active(false)
        end)
    else
        --正常跟随
        self.player:play_hero_follow_anim()
        self:do_player_move(lst, 1)
    end
end

---执行玩家移动
---@private
---@param lst explore_move_data[]
---@param index number
function explore_system:do_player_move(lst, index)
    ---@type explore_move_data
    local move_data = lst[index]
    if nil == move_data then
        --已经到达
        if nil ~= self.move_finished then
            self.move_finished()
            self.move_finished = nil
        end
        self.player:follow_done()
        self.scene_render:reset_camera_follow_line()
        self:set_cur_camera_state(explore_camera_state_type.NORMAL)
        return
    end

    self.player:player_follow_line(move_data.computer, move_data.from, move_data.to, move_data.time, move_data.direction)
    self.scene_render:camera_follow_line(move_data.computer, move_data.from, move_data.to, move_data.time, move_data.direction)
    self:set_cur_camera_state(explore_camera_state_type.FOLLOW)

    self.cache_timer_id = nil
    timer_mgr.add_timer(move_data.time, function()
        index = index + 1
        self.cache_timer_id = nil
        self:do_player_move(lst, index)
    end)
end

---玩家移动并战斗
---@public
---@param target_id string
function explore_system:player_move_and_battle(target_id)
    ---@type explore_node_data
    local target_node = explore_data:get_explore_node_data_by_id(target_id)
    --设置准备位置
    ---@type explore_chapter_data
    local chapter_data = explore_data:get_explore_chapter_data_by_id(self.cur_chapter_id)
    chapter_data:update_pre_pos(target_node.node.Id)
    --章内传送
    local layer_index = target_node.node.LayerIndex
    --切换分层判断
    if layer_index ~= self.cur_layer_index then
        self:change_layer(target_node)
    else
        self.is_can_btn = false
        local chapter_id = self.cur_chapter_id
        local cur_pos = explore_data:get_cur_map_pos(chapter_id)
        message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.req_explore_to_pos, target_id)
        if target_id ~= cur_pos then
            --TODO 虽然两点在同一层，检测两点之间是否跨过层
            local flag = explore_data:check_two_point_has_diff_layer(chapter_id, cur_pos, target_id)
            if flag then
                --直接传送
                self:change_layer(target_node)
            else
                ---@type explore_node_data
                local cur_node = explore_data:get_explore_node_data_by_id(cur_pos)
                local cur_name = cur_node:get_node_name()
                --引导点击探索路点
                self:look_at_target(cur_name, false, function()
                    self:player_move(target_id, function()
                        message.broadcast(message_type.GUIDE_TRY_TRIGGER, guide_trigger_type.explore_player_move_end, target_id)
                        self.is_can_btn = true
                        self:prepare_battle(target_id)
                    end)
                    explore_data:set_last_map_pos(chapter_id, target_id)
                end)
            end
        else
            self.is_can_btn = true
            self:prepare_battle(target_id)
        end
    end
end

---准备战斗
---@public
function explore_system:prepare_battle(target_id)
    self:check_node_start_story(target_id, function()
        --设置路点到达
        self.network:req_explore_update_node_pos(target_id)
        
        --任务路点完成之后不打开事件界面
        ---@type explore_node_data
        local node_data = explore_data:get_explore_node_data_by_id(target_id)
        if node_data.node.EventType == explore_node_event_type.TASK then
            ---@type ExploreTask
            local task_data = data.get(tables.ExploreTask.name, node_data.node.EventParam)
            local task_state = game_data_manager.explore_task:get_explore_task_status(task_data.MissionID)
            if task_state ~= 2 then
                --显示事件面板
                explore_util.show_explore_level_panel(target_id)
            end
        else
            --显示事件面板
            explore_util.show_explore_level_panel(target_id)
        end
    end)
end

--endregion

--region mask

---获得擦除Unit
---@public
---@param name string
---@return explore_fade_mask_render_unit
function explore_system:get_mask_render_unit(name)
    return self.scene_render:get_mask_render_unit(name)
end

--endregion

--region change layer

---切换分层
---@public
---@param node_data explore_node_data
function explore_system:change_layer(node_data)
    local layer_index = node_data.node.LayerIndex
    self.cur_layer_index = layer_index
    ---@type explore_node_data
    local target_node = node_data

    local time_1 = data.get(tables.ConstClient.name, tables.ConstClient.ids.KW_EXPLORE_TRANSPORT_TIME_CHANGE_EFFECT, tables.ConstClient.properties.Int)
    local time_2 = data.get(tables.ConstClient.name, tables.ConstClient.ids.KW_EXPLORE_TRANSPORT_TIME_APPEAR_EFFECT, tables.ConstClient.properties.Int)
    local total_time = (time_1 + time_2) / 1000

    --播放切换分层特效
    ---@type base_window
    local explore_play_win = window.get_window(tables.Window.ids.ExplorePlaying)
    ---@type UnityEngine.GameObject
    local effect_root = explore_play_win.view.change_layer_root
    self.is_can_btn = false

    effect.play_effect_async("Ui_Effect_Com_Zc02", effect_root, 1, function()
        explore_play_win.view_model.is_show_mask = true

        --相机限制分层
        self.scene_render:change_layer_camera_limit(target_node)
        --相机lookAt
        local node_name = target_node:get_node_name()
        self:look_at_target(node_name, true)
        --玩家分层移动
        self.player:change_layer(target_node)
        --播放玩家出场特效
        self.player:play_change_layer_effect()

        effect.play_effect_async("Ui_Effect_Com_Zc03", effect_root, 1,
                function()
                    self.is_can_btn = true
                    --传送完成
                    self.network:req_explore_update_node_pos(target_node.node.Id)
                end,
                function()
                    explore_play_win.view_model.is_show_mask = false
                end)
    end, nil)
end

--endregion

--region guide

---刷新指引者信息
---@public
function explore_system:update_guide_info()
    self.scene_render:update_guide_info()
end

--endregion

--region dungeon

---初始化材料副本渲染器
---@public
---@param hero_obj UnityEngine.GameObject
function explore_system:init_dungeon_scene_render(hero_obj, hero_camera_id)
    self.hero_obj = hero_obj
    self.hero_camera_id = hero_camera_id
    self.dungeon_scene_render:init_born_point()
end

---材料副本怪物加载
---@public
function explore_system:load_dungeon_monster_sync()
    self.dungeon_scene_render:load_monster_sync()
end

---退出材料副本
---@public
function explore_system:exit_dungeon()
    self.hero_obj = nil
    self.hero_camera_id = nil
    self.dungeon_scene_render:clear()
end

---尝试材料副本战斗
---@public
function explore_system:try_dungeon_battle(index)
    index = tonumber(index)
    --log.info("[Explore] try_dungeon_battle : " .. index)

    ---缓存主角儿位置信息
    local cur_dungeon_id = game_data_manager.explore_dungeon.dungeon_data.Id
    local pos_x, pos_y, pos_z = self.hero_obj:GetPosition()
    local rotation_x, rotation_y, rotation_z = self.hero_obj:GetEulerAngles()
    local scale_x, scale_y, scale_z = self.hero_obj:GetLocalScale()
    ---@type born_point_info
    local point_info = {}
    point_info.pos_x = pos_x * 10000
    point_info.pos_y = pos_y * 10000
    point_info.pos_z = pos_z * 10000
    point_info.rotation_x = rotation_x * 10000
    point_info.rotation_y = rotation_y * 10000
    point_info.rotation_z = rotation_z * 10000
    point_info.scale_x = scale_x * 10000
    point_info.scale_y = scale_y * 10000
    point_info.scale_z = scale_y * 10000
    game_data_manager.explore_dungeon:set_born_point_info(cur_dungeon_id, point_info)
    
    --体力检测
    local power_has = game_data_manager.player:get_property_number("Power")
    local power_cost = game_data_manager.explore_dungeon:get_power_cost(index)
    if power_has < power_cost then
        local msg = localization.get_string(string_keys.Close_Auto_Battle_By_No_Power)
        message_box.show_tip_by_context(msg)
        message_box.create_message_box_by_id(tables.Prompt.ids.Prompt_Buy_Power, nil, function()
            --window.open(tables.Window.ids.BuyPower)
            message.broadcast(message_type.QUICK_BUY_OPEN_PANEL, "Power")
        end, nil, false, true)
        message.broadcast(message_type.STOP_PATH_FINDING_MESSAGE)
        return
    end

    ---@type record_row
    local monster_data = game_data_manager.explore_dungeon:get_cur_dungeon_monster_data(index)
    ---@type Ident
    local monster_uid = monster_data:get_value(tables.Player.records.ExploreDungeonMonsters.columns.Id)
    local game_play_id = monster_data:get_value(tables.Player.records.ExploreDungeonMonsters.columns.ExploreDungeonId)
    local battle_id = monster_data:get_value(tables.Player.records.ExploreDungeonMonsters.columns.BattleId)

    game_data_manager.explore_dungeon.last_battle_index = index

    --自动战斗
    local chapter_id = system_manager.explore.last_chapter_id
    local node_id = game_data_manager.explore:get_cur_map_pos(chapter_id)
    ---@type explore_node_data
    local node_data = game_data_manager.explore:get_explore_node_data_by_id(node_id)
    local node_name = node_data:get_node_name()
    local is_auto_battle = game_data_manager.explore_dungeon:is_auto_battle(node_name)
    if is_auto_battle then
        --锁定阵容，直接战斗
        local team_id = self:get_explore_default_team(battle_id)
        game_network.req_enter_battle(game_play_id, team_id, nil, nil, nil, nil, monster_uid, index)
        game_scene_mgr.set_keep_window(false)
        self:cache_battle_data(game_play_id, team_id, nil, nil, nil, nil, monster_uid, index)
    else
        --阵容锁定
        local flag = game_data_manager.explore_dungeon:is_lock_team()
        if flag then
            --锁定阵容，直接战斗
            local team_id = self:get_explore_default_team(battle_id)
            game_network.req_enter_battle(game_play_id, team_id, nil, nil, nil, nil, monster_uid, index)
            game_scene_mgr.set_keep_window(false)
            self:cache_battle_data(game_play_id, team_id, nil, nil, nil, nil, monster_uid, index)
        else
            --未锁定阵容，战前界面
            ---@type battle_ready_window_data
            local ready_data =
            {
                game_play_id = game_play_id,
                battle_mid = battle_id,
                keep_window = false,
                explore_dungeon_monster_id = monster_uid,
                explore_dungeon_monster_idx = index
            }
            message.broadcast(message_type.UI_SHOW_BATTLE_READY_WINDOW, ready_data)
        end
    end
end

---缓存战前数据（再次挑战-不走战备）
---private
function explore_system:cache_battle_data(game_play_id, team_id, continuous_count, auto_buy, challenge_id, replay_id, explore_dungeon_monster_id, explore_dungeon_monster_idx, assist_player_id, assist_witch_id, assist_witch_p_idx, scene_param)
    if ui_cache_data:get_cache_data(cache_keys.explore_dungeon_battle_enter_data) then
        ui_cache_data:del_cache_data(cache_keys.explore_dungeon_battle_enter_data)
    end
    local msg = {
        game_play_id = game_play_id,
        team_id = team_id,
        continuous_count = continuous_count,
        auto_buy = auto_buy,
        challenge_id = challenge_id,
        replay_id = replay_id,
        explore_dungeon_monster_id = explore_dungeon_monster_id,
        explore_dungeon_monster_idx = explore_dungeon_monster_idx,
        mercenary_player = assist_player_id,
        mercenary_unit = assist_witch_id,
        mercenary_idx = assist_witch_p_idx,
        scene_param = scene_param
    }
    ui_cache_data:add_cache_data(cache_keys.explore_dungeon_battle_enter_data, msg)
end

---尝试自动战斗
---@public
---@param index number
function explore_system:try_dungeon_auto_battle(index)
    if nil == index then
        --判断是否存在boss
        local is_has_boss = game_data_manager.explore_dungeon:check_has_boss()
        if is_has_boss then
            index = 10
        else
            ---@type explore_dungeon_monster_render_unit
            local min = nil
            ---获得最小距离
            ---@type table<number, explore_dungeon_monster_render_unit>
            local dict = self.dungeon_scene_render:get_monster_dict()
            for i, v in pairs(dict) do
                v:calc_distance(self.hero_obj)
                if nil == min then
                    min = v
                else
                    local d1 = min.distance
                    local d2 = v.distance
                    if d2 < d1 then
                        min = v
                    end
                end
            end

            index = min:get_index()
        end
    end

    local trigger_id = system_manager.trigger:get_explore_dungeon_trigger_id(index)
    ---@type distance_trigger
    local trigger = system_manager.trigger:get_trigger(trigger_id)
    if nil ~= trigger then
        trigger:on_tap_bubble()
    end
end

---检查材料副本是否第一次进入
---@public
function explore_system:play_dungeon_monster_born_anim()
    --TODO 播放材料副本怪物出生动画
    self.dungeon_scene_render:play_born_anim()
end

---卸载材料副本怪物
---@public
---@param index
function explore_system:unload_dungeon_monster(index)
    self.dungeon_scene_render:unload_monster(index)    
end

---材料副本怪物死亡
---@public
function explore_system:do_dungeon_monster_dead()
    self.dungeon_scene_render:do_monster_dead()
end

---加载材料副本boss
---@public
function explore_system:load_dungeon_boss()
    self.dungeon_scene_render:load_boss()
end

---设置常驻boss出生点位
---@public
function explore_system:set_dungeon_fake_boss_born_point()
    self.dungeon_scene_render:set_fake_boss_born_point()
end

---获得探索默认队伍
---@private
---@param battle_id string
---@return string
function explore_system:get_explore_default_team(battle_id)
    ---@type BTLBattle
    local battle_data = data.get(tables.BTLBattle.name, battle_id)
    if nil ~= battle_data then
        local team_type = battle_data.Label
        ---@type table<string, BTLTeamGroup>
        local tab = data.get_all(tables.BTLTeamGroup.name)
        local group_id = nil
        for i, v in pairs(tab) do
            ---@type BTLTeamGroup
            if team_type == v.Type then
                group_id = v.Id
                break
            end
        end

        if not group_id then
            log.error("初始化队伍失败 ", battle_id)
            return
        end

        local rows = game_data_manager.witch_team:get_team_data_rows()
        local team_id = nil
        for i, v in pairs(rows) do
            ---@type record_row
            local row = v
            local id = row:get_value(tables.Player.records.WitchTeams.columns.TeamId)
            local d_group_id = data.get(tables.BTLTeam.name, id, tables.BTLTeam.properties.TeamGroupID)
            if d_group_id == group_id then
                if data.get(tables.BTLTeam.name, id, tables.BTLTeam.properties.Index) == 1 then
                    team_id = id
                    break
                end
            end
        end
        
        return team_id
    end
    
    return nil
end

--endregion

--region story

---设置战前缓存信息
---@public
function explore_system:set_before_battle_info(node_id, state)
    self.story_ctrl:set_before_battle_info(node_id, state)
end

---检查播放路点开始剧情
---@public
---@param node_id string
---@param call_back function
function explore_system:check_node_start_story(node_id, call_back)
    self.story_ctrl:check_node_start_story(node_id, call_back)
end

---尝试生成后端剧情数据
---@public
function explore_system:try_generate_end_story_data()
    self.story_ctrl:try_generate_end_story_data(self.last_chapter_id)
end

---尝试生成后端剧情数据
---@public
function explore_system:try_generate_end_story_data2()
    self.story_ctrl:try_generate_end_story_data(self.cur_chapter_id)
end

---是否能播放后端剧情
---@public
---@param call_back function
function explore_system:check_node_end_story(call_back)
    self.story_ctrl:check_node_end_story(call_back)
end

--endregion

--region rare monster

---稀有怪倒计时生成
---@public
function explore_system:generate_rare_cool_down_logic()
    if nil == self.cur_chapter_id then
        self.cur_chapter_id = self.last_chapter_id
    end
    ---@type record_row[]
    local lst = game_data_manager.explore_rare:get_rare_data_lst_by_chapter_id(self.cur_chapter_id)
    local count = #lst
    for i = 1, count do
        ---@type record_row
        local row = lst[i]
        local node_id = row:get_value(tables.Player.records.ExploreElite.columns.ActiveExploreNode)
        if nil == self.rare_cool_down_dict[node_id] then
            local logic = rare_cool_down_logic.new(row)
            self.rare_cool_down_dict[node_id] = logic
        end
        
        --扩展数据
        ---@type explore_node_data
        local node_data = explore_data:get_explore_node_data_by_id(node_id)
        local rare_id = row:get_value(tables.Player.records.ExploreElite.columns.Id)
        ---@type ExploreElite
        local rare = data.get(tables.ExploreElite.name, rare_id)
        node_data:set_extend_data(explore_node_extend_type.RARE, rare)
    end
end

---删除指定倒计时逻辑
---@public
---@param node_id
function explore_system:del_rare_cool_down_logic(node_id)
    ---@type explore_rare_cool_down_logic
    local logic = self.rare_cool_down_dict[node_id]
    if nil ~= logic then
        logic:dispose()
        self.rare_cool_down_dict[node_id] = nil
    end
end

---@private
function explore_system:clear_rare_cool_down_logic()
    for i, v in pairs(self.rare_cool_down_dict) do
        v:dispose()
    end
    self.rare_cool_down_dict = {}
end

---还原路点
---@public
---@param node_id string
function explore_system:revert_rare_node(node_id)
    --删除扩展数据
    ---@type explore_node_data
    local node_data = explore_data:get_explore_node_data_by_id(node_id)
    node_data:clear_extend_data()

    --稀有怪路点隐藏
    local node_name = node_data:get_node_name()
    ---@type explore_node_render_unit
    local render = self.scene_render:get_node_render_unit(node_name)
    if nil ~= render then
        render:set_active(false)
    end
end

---显示指定稀有怪路点剩余时间
---@public
---@param node_id string
---@param is_show boolean
function explore_system:send_rare_cool_down_message(node_id, is_show)
    ---@type explore_rare_cool_down_logic
    local logic = self.rare_cool_down_dict[node_id]
    if nil ~= logic then
        logic:send_rare_cool_down_message(is_show)
    end
end

---播放稀有怪通告
---@private
function explore_system:play_rare_monster_anim()
    local flag = self:is_has_prepare_play_anim(explore_anim_type.NEW_RARE_MONSTER)
    if flag then
        ---@type explore_prepare_play_anima
        local play_anim = self:get_prepare_play_anim(explore_anim_type.NEW_RARE_MONSTER)
        if nil ~= play_anim and nil ~= play_anim.node_id then
            message.broadcast(message_type.UI_EXPLORE_RARE_PLAY_ANIM, play_anim.node_id)
        end
        self:del_prepare_play_anim(explore_anim_type.NEW_RARE_MONSTER)
    end
end

--endregion

--region dynamic change

---获得指定变换逻辑
---@public
---@param logic number
---@return base_change_logic
function explore_system:get_dynamic_change_logic(logic)
    return self.dynamic_change_ctrl:get_dynamic_change_logic(logic)
end

---正常执行变换
---@public
---@param id ArrayString
---@param state number
function explore_system:do_dynamic_change(id, state)
    state = tonumber(state)
    ---@type explore_building_render_unit
    local render_unit = self.scene_render:get_building_render_unit(id)
    if nil ~= render_unit then
        render_unit:change_state(state)        
    end
end

---立即执行变换
---@public
function explore_system:do_dynamic_change_immediately()
    ---@type string[]
    local ids = game_data_manager.explore_building:get_building_id_lst_by_chapter_id(self.cur_chapter_id)
    local count = #ids
    if count > 0 then
        for i = 1, count do
            local id = ids[i]
            local state = game_data_manager.explore_building:get_building_state(id)
            ---@type explore_building_render_unit
            local render_unit = self.scene_render:get_building_render_unit(id)
            if nil ~= render_unit then
                render_unit:change_state_immediately(state)
            end
        end        
    end
end


--endregion

--region task

---播放任务路点完成表现
---@public
---@param node_data explore_node_data
function explore_system:play_task_node_done_effect(node_data)
    local node_name = node_data:get_node_name()
    ---@type explore_task_node_render_unit
    local render = self.scene_render:get_node_render_unit(node_name)
    if nil ~= render then
        render:set_active(false)
    end

    self:check_node_and_mask_render_unit()
    self:check_new_node_anim()
end

--endregion

return explore_system
